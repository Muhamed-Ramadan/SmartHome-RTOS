
SmartHome_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000027c  00800100  00003dc0  00003e54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003dc0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c7e  0080037c  0080037c  000040d0  2**0
                  ALLOC
  3 .comment      000000bc  00000000  00000000  000040d0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000418c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000580  00000000  00000000  000041c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008a41  00000000  00000000  00004748  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001e46  00000000  00000000  0000d189  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003aec  00000000  00000000  0000efcf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001088  00000000  00000000  00012abc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001cfe  00000000  00000000  00013b44  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000061be  00000000  00000000  00015842  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000550  00000000  00000000  0001ba00  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	4d c0       	rjmp	.+154    	; 0x9c <__ctors_end>
       2:	00 00       	nop
       4:	69 c0       	rjmp	.+210    	; 0xd8 <__bad_interrupt>
       6:	00 00       	nop
       8:	67 c0       	rjmp	.+206    	; 0xd8 <__bad_interrupt>
       a:	00 00       	nop
       c:	65 c0       	rjmp	.+202    	; 0xd8 <__bad_interrupt>
       e:	00 00       	nop
      10:	63 c0       	rjmp	.+198    	; 0xd8 <__bad_interrupt>
      12:	00 00       	nop
      14:	61 c0       	rjmp	.+194    	; 0xd8 <__bad_interrupt>
      16:	00 00       	nop
      18:	5f c0       	rjmp	.+190    	; 0xd8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5d c0       	rjmp	.+186    	; 0xd8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	5b c0       	rjmp	.+182    	; 0xd8 <__bad_interrupt>
      22:	00 00       	nop
      24:	59 c0       	rjmp	.+178    	; 0xd8 <__bad_interrupt>
      26:	00 00       	nop
      28:	57 c0       	rjmp	.+174    	; 0xd8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	55 c0       	rjmp	.+170    	; 0xd8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 34 08 	jmp	0x1068	; 0x1068 <__vector_12>
      34:	51 c0       	rjmp	.+162    	; 0xd8 <__bad_interrupt>
      36:	00 00       	nop
      38:	4f c0       	rjmp	.+158    	; 0xd8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4d c0       	rjmp	.+154    	; 0xd8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	4b c0       	rjmp	.+150    	; 0xd8 <__bad_interrupt>
      42:	00 00       	nop
      44:	49 c0       	rjmp	.+146    	; 0xd8 <__bad_interrupt>
      46:	00 00       	nop
      48:	47 c0       	rjmp	.+142    	; 0xd8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	45 c0       	rjmp	.+138    	; 0xd8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	43 c0       	rjmp	.+134    	; 0xd8 <__bad_interrupt>
      52:	00 00       	nop
      54:	41 c0       	rjmp	.+130    	; 0xd8 <__bad_interrupt>
      56:	00 00       	nop
      58:	3f c0       	rjmp	.+126    	; 0xd8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	3d c0       	rjmp	.+122    	; 0xd8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	3b c0       	rjmp	.+118    	; 0xd8 <__bad_interrupt>
      62:	00 00       	nop
      64:	39 c0       	rjmp	.+114    	; 0xd8 <__bad_interrupt>
      66:	00 00       	nop
      68:	37 c0       	rjmp	.+110    	; 0xd8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	35 c0       	rjmp	.+106    	; 0xd8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	33 c0       	rjmp	.+102    	; 0xd8 <__bad_interrupt>
      72:	00 00       	nop
      74:	31 c0       	rjmp	.+98     	; 0xd8 <__bad_interrupt>
      76:	00 00       	nop
      78:	2f c0       	rjmp	.+94     	; 0xd8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2d c0       	rjmp	.+90     	; 0xd8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	2b c0       	rjmp	.+86     	; 0xd8 <__bad_interrupt>
      82:	00 00       	nop
      84:	29 c0       	rjmp	.+82     	; 0xd8 <__bad_interrupt>
      86:	00 00       	nop
      88:	27 c0       	rjmp	.+78     	; 0xd8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	c3 14       	cp	r12, r3
      8e:	c8 14       	cp	r12, r8
      90:	cd 14       	cp	r12, r13
      92:	d2 14       	cp	r13, r2
      94:	d7 14       	cp	r13, r7
      96:	dc 14       	cp	r13, r12
      98:	e1 14       	cp	r14, r1
      9a:	e6 14       	cp	r14, r6

0000009c <__ctors_end>:
      9c:	11 24       	eor	r1, r1
      9e:	1f be       	out	0x3f, r1	; 63
      a0:	cf ef       	ldi	r28, 0xFF	; 255
      a2:	d0 e1       	ldi	r29, 0x10	; 16
      a4:	de bf       	out	0x3e, r29	; 62
      a6:	cd bf       	out	0x3d, r28	; 61

000000a8 <__do_copy_data>:
      a8:	13 e0       	ldi	r17, 0x03	; 3
      aa:	a0 e0       	ldi	r26, 0x00	; 0
      ac:	b1 e0       	ldi	r27, 0x01	; 1
      ae:	e0 ec       	ldi	r30, 0xC0	; 192
      b0:	fd e3       	ldi	r31, 0x3D	; 61
      b2:	00 e0       	ldi	r16, 0x00	; 0
      b4:	0b bf       	out	0x3b, r16	; 59
      b6:	02 c0       	rjmp	.+4      	; 0xbc <__do_copy_data+0x14>
      b8:	07 90       	elpm	r0, Z+
      ba:	0d 92       	st	X+, r0
      bc:	ac 37       	cpi	r26, 0x7C	; 124
      be:	b1 07       	cpc	r27, r17
      c0:	d9 f7       	brne	.-10     	; 0xb8 <__do_copy_data+0x10>

000000c2 <__do_clear_bss>:
      c2:	2f e0       	ldi	r18, 0x0F	; 15
      c4:	ac e7       	ldi	r26, 0x7C	; 124
      c6:	b3 e0       	ldi	r27, 0x03	; 3
      c8:	01 c0       	rjmp	.+2      	; 0xcc <.do_clear_bss_start>

000000ca <.do_clear_bss_loop>:
      ca:	1d 92       	st	X+, r1

000000cc <.do_clear_bss_start>:
      cc:	aa 3f       	cpi	r26, 0xFA	; 250
      ce:	b2 07       	cpc	r27, r18
      d0:	e1 f7       	brne	.-8      	; 0xca <.do_clear_bss_loop>
      d2:	03 d0       	rcall	.+6      	; 0xda <main>
      d4:	0c 94 de 1e 	jmp	0x3dbc	; 0x3dbc <_exit>

000000d8 <__bad_interrupt>:
      d8:	93 cf       	rjmp	.-218    	; 0x0 <__vectors>

000000da <main>:



int main(void)
{
	Project_Init();
      da:	0e 94 05 1a 	call	0x340a	; 0x340a <Project_Init>
      de:	ff cf       	rjmp	.-2      	; 0xde <main+0x4>

000000e0 <DHT_start>:
      e0:	61 e0       	ldi	r22, 0x01	; 1
      e2:	82 e1       	ldi	r24, 0x12	; 18
      e4:	f5 d2       	rcall	.+1514   	; 0x6d0 <pinDirection>
      e6:	60 e0       	ldi	r22, 0x00	; 0
      e8:	82 e1       	ldi	r24, 0x12	; 18
      ea:	65 d2       	rcall	.+1226   	; 0x5b6 <writePin>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      ec:	8f e3       	ldi	r24, 0x3F	; 63
      ee:	9c e9       	ldi	r25, 0x9C	; 156
      f0:	01 97       	sbiw	r24, 0x01	; 1
      f2:	f1 f7       	brne	.-4      	; 0xf0 <DHT_start+0x10>
      f4:	00 c0       	rjmp	.+0      	; 0xf6 <DHT_start+0x16>
      f6:	00 00       	nop
      f8:	61 e0       	ldi	r22, 0x01	; 1
      fa:	82 e1       	ldi	r24, 0x12	; 18
      fc:	5c c2       	rjmp	.+1208   	; 0x5b6 <writePin>
      fe:	08 95       	ret

00000100 <DHT_read>:
     100:	cf 93       	push	r28
     102:	df 93       	push	r29
     104:	d8 e0       	ldi	r29, 0x08	; 8
     106:	c0 e0       	ldi	r28, 0x00	; 0
     108:	82 e1       	ldi	r24, 0x12	; 18
     10a:	6f d3       	rcall	.+1758   	; 0x7ea <readPin>
     10c:	88 23       	and	r24, r24
     10e:	e1 f3       	breq	.-8      	; 0x108 <DHT_read+0x8>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     110:	80 e5       	ldi	r24, 0x50	; 80
     112:	8a 95       	dec	r24
     114:	f1 f7       	brne	.-4      	; 0x112 <DHT_read+0x12>
     116:	82 e1       	ldi	r24, 0x12	; 18
     118:	68 d3       	rcall	.+1744   	; 0x7ea <readPin>
     11a:	81 11       	cpse	r24, r1
     11c:	02 c0       	rjmp	.+4      	; 0x122 <DHT_read+0x22>
     11e:	cc 0f       	add	r28, r28
     120:	02 c0       	rjmp	.+4      	; 0x126 <DHT_read+0x26>
     122:	cc 0f       	add	r28, r28
     124:	c1 60       	ori	r28, 0x01	; 1
     126:	82 e1       	ldi	r24, 0x12	; 18
     128:	60 d3       	rcall	.+1728   	; 0x7ea <readPin>
     12a:	81 11       	cpse	r24, r1
     12c:	fc cf       	rjmp	.-8      	; 0x126 <DHT_read+0x26>
     12e:	d1 50       	subi	r29, 0x01	; 1
     130:	59 f7       	brne	.-42     	; 0x108 <DHT_read+0x8>
     132:	8c 2f       	mov	r24, r28
     134:	df 91       	pop	r29
     136:	cf 91       	pop	r28
     138:	08 95       	ret

0000013a <DHT_Response>:
     13a:	60 e0       	ldi	r22, 0x00	; 0
     13c:	82 e1       	ldi	r24, 0x12	; 18
     13e:	c8 d2       	rcall	.+1424   	; 0x6d0 <pinDirection>
     140:	82 e1       	ldi	r24, 0x12	; 18
     142:	53 d3       	rcall	.+1702   	; 0x7ea <readPin>
     144:	81 11       	cpse	r24, r1
     146:	fc cf       	rjmp	.-8      	; 0x140 <DHT_Response+0x6>
     148:	82 e1       	ldi	r24, 0x12	; 18
     14a:	4f d3       	rcall	.+1694   	; 0x7ea <readPin>
     14c:	88 23       	and	r24, r24
     14e:	e1 f3       	breq	.-8      	; 0x148 <DHT_Response+0xe>
     150:	82 e1       	ldi	r24, 0x12	; 18
     152:	4b d3       	rcall	.+1686   	; 0x7ea <readPin>
     154:	81 11       	cpse	r24, r1
     156:	fc cf       	rjmp	.-8      	; 0x150 <DHT_Response+0x16>
     158:	08 95       	ret

0000015a <intTostring>:
     15a:	4f 92       	push	r4
     15c:	5f 92       	push	r5
     15e:	6f 92       	push	r6
     160:	7f 92       	push	r7
     162:	8f 92       	push	r8
     164:	9f 92       	push	r9
     166:	af 92       	push	r10
     168:	bf 92       	push	r11
     16a:	cf 92       	push	r12
     16c:	df 92       	push	r13
     16e:	ef 92       	push	r14
     170:	ff 92       	push	r15
     172:	0f 93       	push	r16
     174:	1f 93       	push	r17
     176:	cf 93       	push	r28
     178:	df 93       	push	r29
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	66 97       	sbiw	r28, 0x16	; 22
     180:	0f b6       	in	r0, 0x3f	; 63
     182:	f8 94       	cli
     184:	de bf       	out	0x3e, r29	; 62
     186:	0f be       	out	0x3f, r0	; 63
     188:	cd bf       	out	0x3d, r28	; 61
     18a:	3c 01       	movw	r6, r24
     18c:	5b 01       	movw	r10, r22
     18e:	4a 01       	movw	r8, r20
     190:	42 2e       	mov	r4, r18
     192:	53 2e       	mov	r5, r19
     194:	8e e2       	ldi	r24, 0x2E	; 46
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	9a 83       	std	Y+2, r25	; 0x02
     19a:	89 83       	std	Y+1, r24	; 0x01
     19c:	8a e0       	ldi	r24, 0x0A	; 10
     19e:	fe 01       	movw	r30, r28
     1a0:	33 96       	adiw	r30, 0x03	; 3
     1a2:	df 01       	movw	r26, r30
     1a4:	98 2f       	mov	r25, r24
     1a6:	1d 92       	st	X+, r1
     1a8:	9a 95       	dec	r25
     1aa:	e9 f7       	brne	.-6      	; 0x1a6 <intTostring+0x4c>
     1ac:	3a 96       	adiw	r30, 0x0a	; 10
     1ae:	df 01       	movw	r26, r30
     1b0:	1d 92       	st	X+, r1
     1b2:	8a 95       	dec	r24
     1b4:	e9 f7       	brne	.-6      	; 0x1b0 <intTostring+0x56>
     1b6:	77 23       	and	r23, r23
     1b8:	34 f4       	brge	.+12     	; 0x1c6 <intTostring+0x6c>
     1ba:	e8 94       	clt
     1bc:	b7 f8       	bld	r11, 7
     1be:	8d e2       	ldi	r24, 0x2D	; 45
     1c0:	fa 01       	movw	r30, r20
     1c2:	81 93       	st	Z+, r24
     1c4:	4f 01       	movw	r8, r30
     1c6:	95 01       	movw	r18, r10
     1c8:	ad ec       	ldi	r26, 0xCD	; 205
     1ca:	bc ec       	ldi	r27, 0xCC	; 204
     1cc:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <__umulhisi3>
     1d0:	6c 01       	movw	r12, r24
     1d2:	d6 94       	lsr	r13
     1d4:	c7 94       	ror	r12
     1d6:	d6 94       	lsr	r13
     1d8:	c7 94       	ror	r12
     1da:	d6 94       	lsr	r13
     1dc:	c7 94       	ror	r12
     1de:	df 92       	push	r13
     1e0:	cf 92       	push	r12
     1e2:	0e e4       	ldi	r16, 0x4E	; 78
     1e4:	11 e0       	ldi	r17, 0x01	; 1
     1e6:	1f 93       	push	r17
     1e8:	0f 93       	push	r16
     1ea:	9f 92       	push	r9
     1ec:	8f 92       	push	r8
     1ee:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <sprintf>
     1f2:	93 01       	movw	r18, r6
     1f4:	ad ec       	ldi	r26, 0xCD	; 205
     1f6:	bc ec       	ldi	r27, 0xCC	; 204
     1f8:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <__umulhisi3>
     1fc:	7c 01       	movw	r14, r24
     1fe:	f6 94       	lsr	r15
     200:	e7 94       	ror	r14
     202:	f6 94       	lsr	r15
     204:	e7 94       	ror	r14
     206:	f6 94       	lsr	r15
     208:	e7 94       	ror	r14
     20a:	ff 92       	push	r15
     20c:	ef 92       	push	r14
     20e:	1f 93       	push	r17
     210:	0f 93       	push	r16
     212:	5f 92       	push	r5
     214:	4f 92       	push	r4
     216:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <sprintf>
     21a:	c6 01       	movw	r24, r12
     21c:	88 0f       	add	r24, r24
     21e:	99 1f       	adc	r25, r25
     220:	cc 0c       	add	r12, r12
     222:	dd 1c       	adc	r13, r13
     224:	cc 0c       	add	r12, r12
     226:	dd 1c       	adc	r13, r13
     228:	cc 0c       	add	r12, r12
     22a:	dd 1c       	adc	r13, r13
     22c:	c8 0e       	add	r12, r24
     22e:	d9 1e       	adc	r13, r25
     230:	ac 18       	sub	r10, r12
     232:	bd 08       	sbc	r11, r13
     234:	bf 92       	push	r11
     236:	af 92       	push	r10
     238:	1f 93       	push	r17
     23a:	0f 93       	push	r16
     23c:	6e 01       	movw	r12, r28
     23e:	f3 e0       	ldi	r31, 0x03	; 3
     240:	cf 0e       	add	r12, r31
     242:	d1 1c       	adc	r13, r1
     244:	df 92       	push	r13
     246:	cf 92       	push	r12
     248:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <sprintf>
     24c:	c7 01       	movw	r24, r14
     24e:	88 0f       	add	r24, r24
     250:	99 1f       	adc	r25, r25
     252:	ee 0c       	add	r14, r14
     254:	ff 1c       	adc	r15, r15
     256:	ee 0c       	add	r14, r14
     258:	ff 1c       	adc	r15, r15
     25a:	ee 0c       	add	r14, r14
     25c:	ff 1c       	adc	r15, r15
     25e:	e8 0e       	add	r14, r24
     260:	f9 1e       	adc	r15, r25
     262:	6e 18       	sub	r6, r14
     264:	7f 08       	sbc	r7, r15
     266:	7f 92       	push	r7
     268:	6f 92       	push	r6
     26a:	1f 93       	push	r17
     26c:	0f 93       	push	r16
     26e:	8e 01       	movw	r16, r28
     270:	03 5f       	subi	r16, 0xF3	; 243
     272:	1f 4f       	sbci	r17, 0xFF	; 255
     274:	1f 93       	push	r17
     276:	0f 93       	push	r16
     278:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <sprintf>
     27c:	be 01       	movw	r22, r28
     27e:	6f 5f       	subi	r22, 0xFF	; 255
     280:	7f 4f       	sbci	r23, 0xFF	; 255
     282:	84 2d       	mov	r24, r4
     284:	95 2d       	mov	r25, r5
     286:	0e 94 a3 1b 	call	0x3746	; 0x3746 <strcat>
     28a:	be 01       	movw	r22, r28
     28c:	6f 5f       	subi	r22, 0xFF	; 255
     28e:	7f 4f       	sbci	r23, 0xFF	; 255
     290:	c4 01       	movw	r24, r8
     292:	0e 94 a3 1b 	call	0x3746	; 0x3746 <strcat>
     296:	b8 01       	movw	r22, r16
     298:	84 2d       	mov	r24, r4
     29a:	95 2d       	mov	r25, r5
     29c:	0e 94 a3 1b 	call	0x3746	; 0x3746 <strcat>
     2a0:	b6 01       	movw	r22, r12
     2a2:	c4 01       	movw	r24, r8
     2a4:	0e 94 a3 1b 	call	0x3746	; 0x3746 <strcat>
     2a8:	0f b6       	in	r0, 0x3f	; 63
     2aa:	f8 94       	cli
     2ac:	de bf       	out	0x3e, r29	; 62
     2ae:	0f be       	out	0x3f, r0	; 63
     2b0:	cd bf       	out	0x3d, r28	; 61
     2b2:	66 96       	adiw	r28, 0x16	; 22
     2b4:	0f b6       	in	r0, 0x3f	; 63
     2b6:	f8 94       	cli
     2b8:	de bf       	out	0x3e, r29	; 62
     2ba:	0f be       	out	0x3f, r0	; 63
     2bc:	cd bf       	out	0x3d, r28	; 61
     2be:	df 91       	pop	r29
     2c0:	cf 91       	pop	r28
     2c2:	1f 91       	pop	r17
     2c4:	0f 91       	pop	r16
     2c6:	ff 90       	pop	r15
     2c8:	ef 90       	pop	r14
     2ca:	df 90       	pop	r13
     2cc:	cf 90       	pop	r12
     2ce:	bf 90       	pop	r11
     2d0:	af 90       	pop	r10
     2d2:	9f 90       	pop	r9
     2d4:	8f 90       	pop	r8
     2d6:	7f 90       	pop	r7
     2d8:	6f 90       	pop	r6
     2da:	5f 90       	pop	r5
     2dc:	4f 90       	pop	r4
     2de:	08 95       	ret

000002e0 <DHT_Represent>:
     2e0:	df 92       	push	r13
     2e2:	ef 92       	push	r14
     2e4:	ff 92       	push	r15
     2e6:	0f 93       	push	r16
     2e8:	1f 93       	push	r17
     2ea:	cf 93       	push	r28
     2ec:	df 93       	push	r29
     2ee:	7c 01       	movw	r14, r24
     2f0:	8b 01       	movw	r16, r22
     2f2:	f6 de       	rcall	.-532    	; 0xe0 <DHT_start>
     2f4:	22 df       	rcall	.-444    	; 0x13a <DHT_Response>
     2f6:	04 df       	rcall	.-504    	; 0x100 <DHT_read>
     2f8:	d8 2e       	mov	r13, r24
     2fa:	02 df       	rcall	.-508    	; 0x100 <DHT_read>
     2fc:	d8 2f       	mov	r29, r24
     2fe:	00 df       	rcall	.-512    	; 0x100 <DHT_read>
     300:	c8 2f       	mov	r28, r24
     302:	fe de       	rcall	.-516    	; 0x100 <DHT_read>
     304:	6c 2f       	mov	r22, r28
     306:	70 e0       	ldi	r23, 0x00	; 0
     308:	76 2f       	mov	r23, r22
     30a:	66 27       	eor	r22, r22
     30c:	68 2b       	or	r22, r24
     30e:	8d 2f       	mov	r24, r29
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	97 01       	movw	r18, r14
     314:	a8 01       	movw	r20, r16
     316:	9d 29       	or	r25, r13
     318:	20 df       	rcall	.-448    	; 0x15a <intTostring>
     31a:	81 e0       	ldi	r24, 0x01	; 1
     31c:	df 91       	pop	r29
     31e:	cf 91       	pop	r28
     320:	1f 91       	pop	r17
     322:	0f 91       	pop	r16
     324:	ff 90       	pop	r15
     326:	ef 90       	pop	r14
     328:	df 90       	pop	r13
     32a:	08 95       	ret

0000032c <KEYPAD_Init>:
     32c:	41 e0       	ldi	r20, 0x01	; 1
     32e:	6f e0       	ldi	r22, 0x0F	; 15
     330:	87 e3       	ldi	r24, 0x37	; 55
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	a5 d2       	rcall	.+1354   	; 0x880 <pinsDirection>
     336:	41 e0       	ldi	r20, 0x01	; 1
     338:	6f e0       	ldi	r22, 0x0F	; 15
     33a:	88 e3       	ldi	r24, 0x38	; 56
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	91 d2       	rcall	.+1314   	; 0x862 <writePins>
     340:	40 e0       	ldi	r20, 0x00	; 0
     342:	60 e7       	ldi	r22, 0x70	; 112
     344:	87 e3       	ldi	r24, 0x37	; 55
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	9b d2       	rcall	.+1334   	; 0x880 <pinsDirection>
     34a:	41 e0       	ldi	r20, 0x01	; 1
     34c:	60 e7       	ldi	r22, 0x70	; 112
     34e:	88 e3       	ldi	r24, 0x38	; 56
     350:	90 e0       	ldi	r25, 0x00	; 0
     352:	87 c2       	rjmp	.+1294   	; 0x862 <writePins>
     354:	08 95       	ret

00000356 <GetKey>:
     356:	1f 93       	push	r17
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	d8 e0       	ldi	r29, 0x08	; 8
     35e:	1c e0       	ldi	r17, 0x0C	; 12
     360:	60 e0       	ldi	r22, 0x00	; 0
     362:	8d 2f       	mov	r24, r29
     364:	28 d1       	rcall	.+592    	; 0x5b6 <writePin>
     366:	c1 2f       	mov	r28, r17
     368:	8c 2f       	mov	r24, r28
     36a:	3f d2       	rcall	.+1150   	; 0x7ea <readPin>
     36c:	81 11       	cpse	r24, r1
     36e:	13 c0       	rjmp	.+38     	; 0x396 <GetKey+0x40>
     370:	8c 2f       	mov	r24, r28
     372:	3b d2       	rcall	.+1142   	; 0x7ea <readPin>
     374:	88 23       	and	r24, r24
     376:	e1 f3       	breq	.-8      	; 0x370 <GetKey+0x1a>
     378:	8d 2f       	mov	r24, r29
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	08 97       	sbiw	r24, 0x08	; 8
     37e:	fc 01       	movw	r30, r24
     380:	ee 0f       	add	r30, r30
     382:	ff 1f       	adc	r31, r31
     384:	e8 0f       	add	r30, r24
     386:	f9 1f       	adc	r31, r25
     388:	e0 50       	subi	r30, 0x00	; 0
     38a:	ff 4f       	sbci	r31, 0xFF	; 255
     38c:	ec 0f       	add	r30, r28
     38e:	f1 1d       	adc	r31, r1
     390:	3c 97       	sbiw	r30, 0x0c	; 12
     392:	80 81       	ld	r24, Z
     394:	0a c0       	rjmp	.+20     	; 0x3aa <GetKey+0x54>
     396:	cf 5f       	subi	r28, 0xFF	; 255
     398:	cf 30       	cpi	r28, 0x0F	; 15
     39a:	31 f7       	brne	.-52     	; 0x368 <GetKey+0x12>
     39c:	61 e0       	ldi	r22, 0x01	; 1
     39e:	8d 2f       	mov	r24, r29
     3a0:	0a d1       	rcall	.+532    	; 0x5b6 <writePin>
     3a2:	df 5f       	subi	r29, 0xFF	; 255
     3a4:	dc 30       	cpi	r29, 0x0C	; 12
     3a6:	e1 f6       	brne	.-72     	; 0x360 <GetKey+0xa>
     3a8:	80 e0       	ldi	r24, 0x00	; 0
     3aa:	df 91       	pop	r29
     3ac:	cf 91       	pop	r28
     3ae:	1f 91       	pop	r17
     3b0:	08 95       	ret

000003b2 <LCD_latch>:
     3b2:	61 e0       	ldi	r22, 0x01	; 1
     3b4:	83 e0       	ldi	r24, 0x03	; 3
     3b6:	ff d0       	rcall	.+510    	; 0x5b6 <writePin>
     3b8:	85 e8       	ldi	r24, 0x85	; 133
     3ba:	8a 95       	dec	r24
     3bc:	f1 f7       	brne	.-4      	; 0x3ba <LCD_latch+0x8>
     3be:	00 00       	nop
     3c0:	60 e0       	ldi	r22, 0x00	; 0
     3c2:	83 e0       	ldi	r24, 0x03	; 3
     3c4:	f8 d0       	rcall	.+496    	; 0x5b6 <writePin>
     3c6:	85 e8       	ldi	r24, 0x85	; 133
     3c8:	8a 95       	dec	r24
     3ca:	f1 f7       	brne	.-4      	; 0x3c8 <LCD_latch+0x16>
     3cc:	00 00       	nop
     3ce:	08 95       	ret

000003d0 <SendToLCD>:
     3d0:	cf 93       	push	r28
     3d2:	c8 2f       	mov	r28, r24
     3d4:	40 e0       	ldi	r20, 0x00	; 0
     3d6:	60 ef       	ldi	r22, 0xF0	; 240
     3d8:	8b e3       	ldi	r24, 0x3B	; 59
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	42 d2       	rcall	.+1156   	; 0x862 <writePins>
     3de:	6c 2f       	mov	r22, r28
     3e0:	60 7f       	andi	r22, 0xF0	; 240
     3e2:	41 e0       	ldi	r20, 0x01	; 1
     3e4:	8b e3       	ldi	r24, 0x3B	; 59
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	3c d2       	rcall	.+1144   	; 0x862 <writePins>
     3ea:	e3 df       	rcall	.-58     	; 0x3b2 <LCD_latch>
     3ec:	40 e0       	ldi	r20, 0x00	; 0
     3ee:	60 ef       	ldi	r22, 0xF0	; 240
     3f0:	8b e3       	ldi	r24, 0x3B	; 59
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	36 d2       	rcall	.+1132   	; 0x862 <writePins>
     3f6:	80 e1       	ldi	r24, 0x10	; 16
     3f8:	c8 9f       	mul	r28, r24
     3fa:	b0 01       	movw	r22, r0
     3fc:	11 24       	eor	r1, r1
     3fe:	41 e0       	ldi	r20, 0x01	; 1
     400:	8b e3       	ldi	r24, 0x3B	; 59
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	2e d2       	rcall	.+1116   	; 0x862 <writePins>
     406:	d5 df       	rcall	.-86     	; 0x3b2 <LCD_latch>
     408:	85 e8       	ldi	r24, 0x85	; 133
     40a:	8a 95       	dec	r24
     40c:	f1 f7       	brne	.-4      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     40e:	00 00       	nop
     410:	cf 91       	pop	r28
     412:	08 95       	ret

00000414 <LCD_send_cmd>:
     414:	cf 93       	push	r28
     416:	c8 2f       	mov	r28, r24
     418:	60 e0       	ldi	r22, 0x00	; 0
     41a:	82 e0       	ldi	r24, 0x02	; 2
     41c:	cc d0       	rcall	.+408    	; 0x5b6 <writePin>
     41e:	8c 2f       	mov	r24, r28
     420:	d7 df       	rcall	.-82     	; 0x3d0 <SendToLCD>
     422:	cf 91       	pop	r28
     424:	08 95       	ret

00000426 <LCD_CLEAR>:
     426:	81 e0       	ldi	r24, 0x01	; 1
     428:	f5 df       	rcall	.-22     	; 0x414 <LCD_send_cmd>
     42a:	8f e9       	ldi	r24, 0x9F	; 159
     42c:	9f e0       	ldi	r25, 0x0F	; 15
     42e:	01 97       	sbiw	r24, 0x01	; 1
     430:	f1 f7       	brne	.-4      	; 0x42e <LCD_CLEAR+0x8>
     432:	00 c0       	rjmp	.+0      	; 0x434 <LCD_CLEAR+0xe>
     434:	00 00       	nop
     436:	08 95       	ret

00000438 <LCD_ret_Home>:
     438:	82 e0       	ldi	r24, 0x02	; 2
     43a:	ec df       	rcall	.-40     	; 0x414 <LCD_send_cmd>
     43c:	8f e9       	ldi	r24, 0x9F	; 159
     43e:	9f e0       	ldi	r25, 0x0F	; 15
     440:	01 97       	sbiw	r24, 0x01	; 1
     442:	f1 f7       	brne	.-4      	; 0x440 <LCD_ret_Home+0x8>
     444:	00 c0       	rjmp	.+0      	; 0x446 <LCD_ret_Home+0xe>
     446:	00 00       	nop
     448:	08 95       	ret

0000044a <LCD_init>:
     44a:	41 e0       	ldi	r20, 0x01	; 1
     44c:	60 ef       	ldi	r22, 0xF0	; 240
     44e:	8a e3       	ldi	r24, 0x3A	; 58
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	16 d2       	rcall	.+1068   	; 0x880 <pinsDirection>
     454:	41 e0       	ldi	r20, 0x01	; 1
     456:	6c e0       	ldi	r22, 0x0C	; 12
     458:	8a e3       	ldi	r24, 0x3A	; 58
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	11 d2       	rcall	.+1058   	; 0x880 <pinsDirection>
     45e:	2f ef       	ldi	r18, 0xFF	; 255
     460:	89 ef       	ldi	r24, 0xF9	; 249
     462:	90 e0       	ldi	r25, 0x00	; 0
     464:	21 50       	subi	r18, 0x01	; 1
     466:	80 40       	sbci	r24, 0x00	; 0
     468:	90 40       	sbci	r25, 0x00	; 0
     46a:	e1 f7       	brne	.-8      	; 0x464 <LCD_init+0x1a>
     46c:	00 c0       	rjmp	.+0      	; 0x46e <LCD_init+0x24>
     46e:	00 00       	nop
     470:	e3 df       	rcall	.-58     	; 0x438 <LCD_ret_Home>
     472:	86 e0       	ldi	r24, 0x06	; 6
     474:	cf df       	rcall	.-98     	; 0x414 <LCD_send_cmd>
     476:	8c e0       	ldi	r24, 0x0C	; 12
     478:	cd df       	rcall	.-102    	; 0x414 <LCD_send_cmd>
     47a:	80 e1       	ldi	r24, 0x10	; 16
     47c:	cb df       	rcall	.-106    	; 0x414 <LCD_send_cmd>
     47e:	88 e2       	ldi	r24, 0x28	; 40
     480:	c9 df       	rcall	.-110    	; 0x414 <LCD_send_cmd>
     482:	d1 cf       	rjmp	.-94     	; 0x426 <LCD_CLEAR>
     484:	08 95       	ret

00000486 <LCD_send_data>:
     486:	cf 93       	push	r28
     488:	c8 2f       	mov	r28, r24
     48a:	61 e0       	ldi	r22, 0x01	; 1
     48c:	82 e0       	ldi	r24, 0x02	; 2
     48e:	93 d0       	rcall	.+294    	; 0x5b6 <writePin>
     490:	8c 2f       	mov	r24, r28
     492:	9e df       	rcall	.-196    	; 0x3d0 <SendToLCD>
     494:	cf 91       	pop	r28
     496:	08 95       	ret

00000498 <disp_str>:
     498:	0f 93       	push	r16
     49a:	1f 93       	push	r17
     49c:	cf 93       	push	r28
     49e:	fc 01       	movw	r30, r24
     4a0:	80 81       	ld	r24, Z
     4a2:	88 23       	and	r24, r24
     4a4:	51 f0       	breq	.+20     	; 0x4ba <disp_str+0x22>
     4a6:	8f 01       	movw	r16, r30
     4a8:	c0 e0       	ldi	r28, 0x00	; 0
     4aa:	ed df       	rcall	.-38     	; 0x486 <LCD_send_data>
     4ac:	cf 5f       	subi	r28, 0xFF	; 255
     4ae:	f8 01       	movw	r30, r16
     4b0:	ec 0f       	add	r30, r28
     4b2:	f1 1d       	adc	r31, r1
     4b4:	80 81       	ld	r24, Z
     4b6:	81 11       	cpse	r24, r1
     4b8:	f8 cf       	rjmp	.-16     	; 0x4aa <disp_str+0x12>
     4ba:	cf 91       	pop	r28
     4bc:	1f 91       	pop	r17
     4be:	0f 91       	pop	r16
     4c0:	08 95       	ret

000004c2 <LCD_GOTXY>:
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	21 f4       	brne	.+8      	; 0x4ce <LCD_GOTXY+0xc>
     4c6:	8f e7       	ldi	r24, 0x7F	; 127
     4c8:	86 0f       	add	r24, r22
     4ca:	a4 cf       	rjmp	.-184    	; 0x414 <LCD_send_cmd>
     4cc:	08 95       	ret
     4ce:	82 30       	cpi	r24, 0x02	; 2
     4d0:	21 f4       	brne	.+8      	; 0x4da <LCD_GOTXY+0x18>
     4d2:	8f eb       	ldi	r24, 0xBF	; 191
     4d4:	86 0f       	add	r24, r22
     4d6:	9e cf       	rjmp	.-196    	; 0x414 <LCD_send_cmd>
     4d8:	08 95       	ret
     4da:	83 30       	cpi	r24, 0x03	; 3
     4dc:	21 f4       	brne	.+8      	; 0x4e6 <LCD_GOTXY+0x24>
     4de:	8f e8       	ldi	r24, 0x8F	; 143
     4e0:	86 0f       	add	r24, r22
     4e2:	98 cf       	rjmp	.-208    	; 0x414 <LCD_send_cmd>
     4e4:	08 95       	ret
     4e6:	84 30       	cpi	r24, 0x04	; 4
     4e8:	19 f4       	brne	.+6      	; 0x4f0 <LCD_GOTXY+0x2e>
     4ea:	8f ec       	ldi	r24, 0xCF	; 207
     4ec:	86 0f       	add	r24, r22
     4ee:	92 cf       	rjmp	.-220    	; 0x414 <LCD_send_cmd>
     4f0:	08 95       	ret

000004f2 <disp_charXY>:
     4f2:	cf 93       	push	r28
     4f4:	c4 2f       	mov	r28, r20
     4f6:	e5 df       	rcall	.-54     	; 0x4c2 <LCD_GOTXY>
     4f8:	8c 2f       	mov	r24, r28
     4fa:	c5 df       	rcall	.-118    	; 0x486 <LCD_send_data>
     4fc:	cf 91       	pop	r28
     4fe:	08 95       	ret

00000500 <disp_strXY>:
     500:	cf 93       	push	r28
     502:	df 93       	push	r29
     504:	ea 01       	movw	r28, r20
     506:	dd df       	rcall	.-70     	; 0x4c2 <LCD_GOTXY>
     508:	ce 01       	movw	r24, r28
     50a:	c6 df       	rcall	.-116    	; 0x498 <disp_str>
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	08 95       	ret

00000512 <disp_int>:
     512:	0f 93       	push	r16
     514:	1f 93       	push	r17
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	cd b7       	in	r28, 0x3d	; 61
     51c:	de b7       	in	r29, 0x3e	; 62
     51e:	2b 97       	sbiw	r28, 0x0b	; 11
     520:	0f b6       	in	r0, 0x3f	; 63
     522:	f8 94       	cli
     524:	de bf       	out	0x3e, r29	; 62
     526:	0f be       	out	0x3f, r0	; 63
     528:	cd bf       	out	0x3d, r28	; 61
     52a:	8e 01       	movw	r16, r28
     52c:	0f 5f       	subi	r16, 0xFF	; 255
     52e:	1f 4f       	sbci	r17, 0xFF	; 255
     530:	2b e0       	ldi	r18, 0x0B	; 11
     532:	f8 01       	movw	r30, r16
     534:	11 92       	st	Z+, r1
     536:	2a 95       	dec	r18
     538:	e9 f7       	brne	.-6      	; 0x534 <disp_int+0x22>
     53a:	9f 93       	push	r25
     53c:	8f 93       	push	r24
     53e:	7f 93       	push	r23
     540:	6f 93       	push	r22
     542:	8e e4       	ldi	r24, 0x4E	; 78
     544:	91 e0       	ldi	r25, 0x01	; 1
     546:	9f 93       	push	r25
     548:	8f 93       	push	r24
     54a:	1f 93       	push	r17
     54c:	0f 93       	push	r16
     54e:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <sprintf>
     552:	c8 01       	movw	r24, r16
     554:	a1 df       	rcall	.-190    	; 0x498 <disp_str>
     556:	0f b6       	in	r0, 0x3f	; 63
     558:	f8 94       	cli
     55a:	de bf       	out	0x3e, r29	; 62
     55c:	0f be       	out	0x3f, r0	; 63
     55e:	cd bf       	out	0x3d, r28	; 61
     560:	2b 96       	adiw	r28, 0x0b	; 11
     562:	0f b6       	in	r0, 0x3f	; 63
     564:	f8 94       	cli
     566:	de bf       	out	0x3e, r29	; 62
     568:	0f be       	out	0x3f, r0	; 63
     56a:	cd bf       	out	0x3d, r28	; 61
     56c:	df 91       	pop	r29
     56e:	cf 91       	pop	r28
     570:	1f 91       	pop	r17
     572:	0f 91       	pop	r16
     574:	08 95       	ret

00000576 <disp_intXY>:
     576:	cf 92       	push	r12
     578:	df 92       	push	r13
     57a:	ef 92       	push	r14
     57c:	ff 92       	push	r15
     57e:	69 01       	movw	r12, r18
     580:	7a 01       	movw	r14, r20
     582:	9f df       	rcall	.-194    	; 0x4c2 <LCD_GOTXY>
     584:	c7 01       	movw	r24, r14
     586:	b6 01       	movw	r22, r12
     588:	c4 df       	rcall	.-120    	; 0x512 <disp_int>
     58a:	ff 90       	pop	r15
     58c:	ef 90       	pop	r14
     58e:	df 90       	pop	r13
     590:	cf 90       	pop	r12
     592:	08 95       	ret

00000594 <ADC_init>:
     594:	3e 9a       	sbi	0x07, 6	; 7
     596:	86 b1       	in	r24, 0x06	; 6
     598:	87 68       	ori	r24, 0x87	; 135
     59a:	86 b9       	out	0x06, r24	; 6
     59c:	08 95       	ret

0000059e <read_analog>:
     59e:	97 b1       	in	r25, 0x07	; 7
     5a0:	90 7e       	andi	r25, 0xE0	; 224
     5a2:	97 b9       	out	0x07, r25	; 7
     5a4:	97 b1       	in	r25, 0x07	; 7
     5a6:	89 2b       	or	r24, r25
     5a8:	87 b9       	out	0x07, r24	; 7
     5aa:	36 9a       	sbi	0x06, 6	; 6
     5ac:	36 99       	sbic	0x06, 6	; 6
     5ae:	fe cf       	rjmp	.-4      	; 0x5ac <read_analog+0xe>
     5b0:	84 b1       	in	r24, 0x04	; 4
     5b2:	95 b1       	in	r25, 0x05	; 5
     5b4:	08 95       	ret

000005b6 <writePin>:
     5b6:	88 30       	cpi	r24, 0x08	; 8
     5b8:	f8 f4       	brcc	.+62     	; 0x5f8 <writePin+0x42>
     5ba:	61 30       	cpi	r22, 0x01	; 1
     5bc:	69 f4       	brne	.+26     	; 0x5d8 <writePin+0x22>
     5be:	4b b3       	in	r20, 0x1b	; 27
     5c0:	21 e0       	ldi	r18, 0x01	; 1
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	b9 01       	movw	r22, r18
     5c6:	02 c0       	rjmp	.+4      	; 0x5cc <writePin+0x16>
     5c8:	66 0f       	add	r22, r22
     5ca:	77 1f       	adc	r23, r23
     5cc:	8a 95       	dec	r24
     5ce:	e2 f7       	brpl	.-8      	; 0x5c8 <writePin+0x12>
     5d0:	cb 01       	movw	r24, r22
     5d2:	84 2b       	or	r24, r20
     5d4:	8b bb       	out	0x1b, r24	; 27
     5d6:	08 95       	ret
     5d8:	61 11       	cpse	r22, r1
     5da:	79 c0       	rjmp	.+242    	; 0x6ce <writePin+0x118>
     5dc:	4b b3       	in	r20, 0x1b	; 27
     5de:	21 e0       	ldi	r18, 0x01	; 1
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	b9 01       	movw	r22, r18
     5e4:	02 c0       	rjmp	.+4      	; 0x5ea <writePin+0x34>
     5e6:	66 0f       	add	r22, r22
     5e8:	77 1f       	adc	r23, r23
     5ea:	8a 95       	dec	r24
     5ec:	e2 f7       	brpl	.-8      	; 0x5e6 <writePin+0x30>
     5ee:	cb 01       	movw	r24, r22
     5f0:	80 95       	com	r24
     5f2:	84 23       	and	r24, r20
     5f4:	8b bb       	out	0x1b, r24	; 27
     5f6:	08 95       	ret
     5f8:	98 ef       	ldi	r25, 0xF8	; 248
     5fa:	98 0f       	add	r25, r24
     5fc:	98 30       	cpi	r25, 0x08	; 8
     5fe:	00 f5       	brcc	.+64     	; 0x640 <writePin+0x8a>
     600:	61 30       	cpi	r22, 0x01	; 1
     602:	69 f4       	brne	.+26     	; 0x61e <writePin+0x68>
     604:	48 b3       	in	r20, 0x18	; 24
     606:	21 e0       	ldi	r18, 0x01	; 1
     608:	30 e0       	ldi	r19, 0x00	; 0
     60a:	b9 01       	movw	r22, r18
     60c:	02 c0       	rjmp	.+4      	; 0x612 <writePin+0x5c>
     60e:	66 0f       	add	r22, r22
     610:	77 1f       	adc	r23, r23
     612:	9a 95       	dec	r25
     614:	e2 f7       	brpl	.-8      	; 0x60e <writePin+0x58>
     616:	cb 01       	movw	r24, r22
     618:	84 2b       	or	r24, r20
     61a:	88 bb       	out	0x18, r24	; 24
     61c:	08 95       	ret
     61e:	61 11       	cpse	r22, r1
     620:	56 c0       	rjmp	.+172    	; 0x6ce <writePin+0x118>
     622:	48 b3       	in	r20, 0x18	; 24
     624:	88 50       	subi	r24, 0x08	; 8
     626:	21 e0       	ldi	r18, 0x01	; 1
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	b9 01       	movw	r22, r18
     62c:	02 c0       	rjmp	.+4      	; 0x632 <writePin+0x7c>
     62e:	66 0f       	add	r22, r22
     630:	77 1f       	adc	r23, r23
     632:	8a 95       	dec	r24
     634:	e2 f7       	brpl	.-8      	; 0x62e <writePin+0x78>
     636:	cb 01       	movw	r24, r22
     638:	80 95       	com	r24
     63a:	84 23       	and	r24, r20
     63c:	88 bb       	out	0x18, r24	; 24
     63e:	08 95       	ret
     640:	90 ef       	ldi	r25, 0xF0	; 240
     642:	98 0f       	add	r25, r24
     644:	98 30       	cpi	r25, 0x08	; 8
     646:	00 f5       	brcc	.+64     	; 0x688 <writePin+0xd2>
     648:	61 30       	cpi	r22, 0x01	; 1
     64a:	69 f4       	brne	.+26     	; 0x666 <writePin+0xb0>
     64c:	45 b3       	in	r20, 0x15	; 21
     64e:	21 e0       	ldi	r18, 0x01	; 1
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	b9 01       	movw	r22, r18
     654:	02 c0       	rjmp	.+4      	; 0x65a <writePin+0xa4>
     656:	66 0f       	add	r22, r22
     658:	77 1f       	adc	r23, r23
     65a:	9a 95       	dec	r25
     65c:	e2 f7       	brpl	.-8      	; 0x656 <writePin+0xa0>
     65e:	cb 01       	movw	r24, r22
     660:	84 2b       	or	r24, r20
     662:	85 bb       	out	0x15, r24	; 21
     664:	08 95       	ret
     666:	61 11       	cpse	r22, r1
     668:	32 c0       	rjmp	.+100    	; 0x6ce <writePin+0x118>
     66a:	45 b3       	in	r20, 0x15	; 21
     66c:	80 51       	subi	r24, 0x10	; 16
     66e:	21 e0       	ldi	r18, 0x01	; 1
     670:	30 e0       	ldi	r19, 0x00	; 0
     672:	b9 01       	movw	r22, r18
     674:	02 c0       	rjmp	.+4      	; 0x67a <writePin+0xc4>
     676:	66 0f       	add	r22, r22
     678:	77 1f       	adc	r23, r23
     67a:	8a 95       	dec	r24
     67c:	e2 f7       	brpl	.-8      	; 0x676 <writePin+0xc0>
     67e:	cb 01       	movw	r24, r22
     680:	80 95       	com	r24
     682:	84 23       	and	r24, r20
     684:	85 bb       	out	0x15, r24	; 21
     686:	08 95       	ret
     688:	98 ee       	ldi	r25, 0xE8	; 232
     68a:	98 0f       	add	r25, r24
     68c:	98 30       	cpi	r25, 0x08	; 8
     68e:	f8 f4       	brcc	.+62     	; 0x6ce <writePin+0x118>
     690:	61 30       	cpi	r22, 0x01	; 1
     692:	69 f4       	brne	.+26     	; 0x6ae <writePin+0xf8>
     694:	42 b3       	in	r20, 0x12	; 18
     696:	21 e0       	ldi	r18, 0x01	; 1
     698:	30 e0       	ldi	r19, 0x00	; 0
     69a:	b9 01       	movw	r22, r18
     69c:	02 c0       	rjmp	.+4      	; 0x6a2 <writePin+0xec>
     69e:	66 0f       	add	r22, r22
     6a0:	77 1f       	adc	r23, r23
     6a2:	9a 95       	dec	r25
     6a4:	e2 f7       	brpl	.-8      	; 0x69e <writePin+0xe8>
     6a6:	cb 01       	movw	r24, r22
     6a8:	84 2b       	or	r24, r20
     6aa:	82 bb       	out	0x12, r24	; 18
     6ac:	08 95       	ret
     6ae:	61 11       	cpse	r22, r1
     6b0:	0e c0       	rjmp	.+28     	; 0x6ce <writePin+0x118>
     6b2:	42 b3       	in	r20, 0x12	; 18
     6b4:	88 51       	subi	r24, 0x18	; 24
     6b6:	21 e0       	ldi	r18, 0x01	; 1
     6b8:	30 e0       	ldi	r19, 0x00	; 0
     6ba:	b9 01       	movw	r22, r18
     6bc:	02 c0       	rjmp	.+4      	; 0x6c2 <writePin+0x10c>
     6be:	66 0f       	add	r22, r22
     6c0:	77 1f       	adc	r23, r23
     6c2:	8a 95       	dec	r24
     6c4:	e2 f7       	brpl	.-8      	; 0x6be <writePin+0x108>
     6c6:	cb 01       	movw	r24, r22
     6c8:	80 95       	com	r24
     6ca:	84 23       	and	r24, r20
     6cc:	82 bb       	out	0x12, r24	; 18
     6ce:	08 95       	ret

000006d0 <pinDirection>:
     6d0:	88 30       	cpi	r24, 0x08	; 8
     6d2:	f8 f4       	brcc	.+62     	; 0x712 <pinDirection+0x42>
     6d4:	61 30       	cpi	r22, 0x01	; 1
     6d6:	69 f4       	brne	.+26     	; 0x6f2 <pinDirection+0x22>
     6d8:	4a b3       	in	r20, 0x1a	; 26
     6da:	21 e0       	ldi	r18, 0x01	; 1
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	b9 01       	movw	r22, r18
     6e0:	02 c0       	rjmp	.+4      	; 0x6e6 <pinDirection+0x16>
     6e2:	66 0f       	add	r22, r22
     6e4:	77 1f       	adc	r23, r23
     6e6:	8a 95       	dec	r24
     6e8:	e2 f7       	brpl	.-8      	; 0x6e2 <pinDirection+0x12>
     6ea:	cb 01       	movw	r24, r22
     6ec:	84 2b       	or	r24, r20
     6ee:	8a bb       	out	0x1a, r24	; 26
     6f0:	08 95       	ret
     6f2:	61 11       	cpse	r22, r1
     6f4:	79 c0       	rjmp	.+242    	; 0x7e8 <pinDirection+0x118>
     6f6:	4a b3       	in	r20, 0x1a	; 26
     6f8:	21 e0       	ldi	r18, 0x01	; 1
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	b9 01       	movw	r22, r18
     6fe:	02 c0       	rjmp	.+4      	; 0x704 <pinDirection+0x34>
     700:	66 0f       	add	r22, r22
     702:	77 1f       	adc	r23, r23
     704:	8a 95       	dec	r24
     706:	e2 f7       	brpl	.-8      	; 0x700 <pinDirection+0x30>
     708:	cb 01       	movw	r24, r22
     70a:	80 95       	com	r24
     70c:	84 23       	and	r24, r20
     70e:	8a bb       	out	0x1a, r24	; 26
     710:	08 95       	ret
     712:	98 ef       	ldi	r25, 0xF8	; 248
     714:	98 0f       	add	r25, r24
     716:	98 30       	cpi	r25, 0x08	; 8
     718:	00 f5       	brcc	.+64     	; 0x75a <pinDirection+0x8a>
     71a:	61 30       	cpi	r22, 0x01	; 1
     71c:	69 f4       	brne	.+26     	; 0x738 <pinDirection+0x68>
     71e:	47 b3       	in	r20, 0x17	; 23
     720:	21 e0       	ldi	r18, 0x01	; 1
     722:	30 e0       	ldi	r19, 0x00	; 0
     724:	b9 01       	movw	r22, r18
     726:	02 c0       	rjmp	.+4      	; 0x72c <pinDirection+0x5c>
     728:	66 0f       	add	r22, r22
     72a:	77 1f       	adc	r23, r23
     72c:	9a 95       	dec	r25
     72e:	e2 f7       	brpl	.-8      	; 0x728 <pinDirection+0x58>
     730:	cb 01       	movw	r24, r22
     732:	84 2b       	or	r24, r20
     734:	87 bb       	out	0x17, r24	; 23
     736:	08 95       	ret
     738:	61 11       	cpse	r22, r1
     73a:	56 c0       	rjmp	.+172    	; 0x7e8 <pinDirection+0x118>
     73c:	47 b3       	in	r20, 0x17	; 23
     73e:	88 50       	subi	r24, 0x08	; 8
     740:	21 e0       	ldi	r18, 0x01	; 1
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	b9 01       	movw	r22, r18
     746:	02 c0       	rjmp	.+4      	; 0x74c <pinDirection+0x7c>
     748:	66 0f       	add	r22, r22
     74a:	77 1f       	adc	r23, r23
     74c:	8a 95       	dec	r24
     74e:	e2 f7       	brpl	.-8      	; 0x748 <pinDirection+0x78>
     750:	cb 01       	movw	r24, r22
     752:	80 95       	com	r24
     754:	84 23       	and	r24, r20
     756:	87 bb       	out	0x17, r24	; 23
     758:	08 95       	ret
     75a:	90 ef       	ldi	r25, 0xF0	; 240
     75c:	98 0f       	add	r25, r24
     75e:	98 30       	cpi	r25, 0x08	; 8
     760:	00 f5       	brcc	.+64     	; 0x7a2 <pinDirection+0xd2>
     762:	61 30       	cpi	r22, 0x01	; 1
     764:	69 f4       	brne	.+26     	; 0x780 <pinDirection+0xb0>
     766:	44 b3       	in	r20, 0x14	; 20
     768:	21 e0       	ldi	r18, 0x01	; 1
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	b9 01       	movw	r22, r18
     76e:	02 c0       	rjmp	.+4      	; 0x774 <pinDirection+0xa4>
     770:	66 0f       	add	r22, r22
     772:	77 1f       	adc	r23, r23
     774:	9a 95       	dec	r25
     776:	e2 f7       	brpl	.-8      	; 0x770 <pinDirection+0xa0>
     778:	cb 01       	movw	r24, r22
     77a:	84 2b       	or	r24, r20
     77c:	84 bb       	out	0x14, r24	; 20
     77e:	08 95       	ret
     780:	61 11       	cpse	r22, r1
     782:	32 c0       	rjmp	.+100    	; 0x7e8 <pinDirection+0x118>
     784:	44 b3       	in	r20, 0x14	; 20
     786:	80 51       	subi	r24, 0x10	; 16
     788:	21 e0       	ldi	r18, 0x01	; 1
     78a:	30 e0       	ldi	r19, 0x00	; 0
     78c:	b9 01       	movw	r22, r18
     78e:	02 c0       	rjmp	.+4      	; 0x794 <pinDirection+0xc4>
     790:	66 0f       	add	r22, r22
     792:	77 1f       	adc	r23, r23
     794:	8a 95       	dec	r24
     796:	e2 f7       	brpl	.-8      	; 0x790 <pinDirection+0xc0>
     798:	cb 01       	movw	r24, r22
     79a:	80 95       	com	r24
     79c:	84 23       	and	r24, r20
     79e:	84 bb       	out	0x14, r24	; 20
     7a0:	08 95       	ret
     7a2:	98 ee       	ldi	r25, 0xE8	; 232
     7a4:	98 0f       	add	r25, r24
     7a6:	98 30       	cpi	r25, 0x08	; 8
     7a8:	f8 f4       	brcc	.+62     	; 0x7e8 <pinDirection+0x118>
     7aa:	61 30       	cpi	r22, 0x01	; 1
     7ac:	69 f4       	brne	.+26     	; 0x7c8 <pinDirection+0xf8>
     7ae:	41 b3       	in	r20, 0x11	; 17
     7b0:	21 e0       	ldi	r18, 0x01	; 1
     7b2:	30 e0       	ldi	r19, 0x00	; 0
     7b4:	b9 01       	movw	r22, r18
     7b6:	02 c0       	rjmp	.+4      	; 0x7bc <pinDirection+0xec>
     7b8:	66 0f       	add	r22, r22
     7ba:	77 1f       	adc	r23, r23
     7bc:	9a 95       	dec	r25
     7be:	e2 f7       	brpl	.-8      	; 0x7b8 <pinDirection+0xe8>
     7c0:	cb 01       	movw	r24, r22
     7c2:	84 2b       	or	r24, r20
     7c4:	81 bb       	out	0x11, r24	; 17
     7c6:	08 95       	ret
     7c8:	61 11       	cpse	r22, r1
     7ca:	0e c0       	rjmp	.+28     	; 0x7e8 <pinDirection+0x118>
     7cc:	41 b3       	in	r20, 0x11	; 17
     7ce:	88 51       	subi	r24, 0x18	; 24
     7d0:	21 e0       	ldi	r18, 0x01	; 1
     7d2:	30 e0       	ldi	r19, 0x00	; 0
     7d4:	b9 01       	movw	r22, r18
     7d6:	02 c0       	rjmp	.+4      	; 0x7dc <pinDirection+0x10c>
     7d8:	66 0f       	add	r22, r22
     7da:	77 1f       	adc	r23, r23
     7dc:	8a 95       	dec	r24
     7de:	e2 f7       	brpl	.-8      	; 0x7d8 <pinDirection+0x108>
     7e0:	cb 01       	movw	r24, r22
     7e2:	80 95       	com	r24
     7e4:	84 23       	and	r24, r20
     7e6:	81 bb       	out	0x11, r24	; 17
     7e8:	08 95       	ret

000007ea <readPin>:
     7ea:	88 30       	cpi	r24, 0x08	; 8
     7ec:	58 f4       	brcc	.+22     	; 0x804 <readPin+0x1a>
     7ee:	29 b3       	in	r18, 0x19	; 25
     7f0:	30 e0       	ldi	r19, 0x00	; 0
     7f2:	a9 01       	movw	r20, r18
     7f4:	02 c0       	rjmp	.+4      	; 0x7fa <readPin+0x10>
     7f6:	55 95       	asr	r21
     7f8:	47 95       	ror	r20
     7fa:	8a 95       	dec	r24
     7fc:	e2 f7       	brpl	.-8      	; 0x7f6 <readPin+0xc>
     7fe:	ca 01       	movw	r24, r20
     800:	81 70       	andi	r24, 0x01	; 1
     802:	08 95       	ret
     804:	98 ef       	ldi	r25, 0xF8	; 248
     806:	98 0f       	add	r25, r24
     808:	98 30       	cpi	r25, 0x08	; 8
     80a:	58 f4       	brcc	.+22     	; 0x822 <readPin+0x38>
     80c:	26 b3       	in	r18, 0x16	; 22
     80e:	30 e0       	ldi	r19, 0x00	; 0
     810:	a9 01       	movw	r20, r18
     812:	02 c0       	rjmp	.+4      	; 0x818 <readPin+0x2e>
     814:	55 95       	asr	r21
     816:	47 95       	ror	r20
     818:	9a 95       	dec	r25
     81a:	e2 f7       	brpl	.-8      	; 0x814 <readPin+0x2a>
     81c:	ca 01       	movw	r24, r20
     81e:	81 70       	andi	r24, 0x01	; 1
     820:	08 95       	ret
     822:	90 ef       	ldi	r25, 0xF0	; 240
     824:	98 0f       	add	r25, r24
     826:	98 30       	cpi	r25, 0x08	; 8
     828:	58 f4       	brcc	.+22     	; 0x840 <readPin+0x56>
     82a:	23 b3       	in	r18, 0x13	; 19
     82c:	30 e0       	ldi	r19, 0x00	; 0
     82e:	a9 01       	movw	r20, r18
     830:	02 c0       	rjmp	.+4      	; 0x836 <readPin+0x4c>
     832:	55 95       	asr	r21
     834:	47 95       	ror	r20
     836:	9a 95       	dec	r25
     838:	e2 f7       	brpl	.-8      	; 0x832 <readPin+0x48>
     83a:	ca 01       	movw	r24, r20
     83c:	81 70       	andi	r24, 0x01	; 1
     83e:	08 95       	ret
     840:	98 ee       	ldi	r25, 0xE8	; 232
     842:	98 0f       	add	r25, r24
     844:	98 30       	cpi	r25, 0x08	; 8
     846:	58 f4       	brcc	.+22     	; 0x85e <readPin+0x74>
     848:	20 b3       	in	r18, 0x10	; 16
     84a:	30 e0       	ldi	r19, 0x00	; 0
     84c:	a9 01       	movw	r20, r18
     84e:	02 c0       	rjmp	.+4      	; 0x854 <readPin+0x6a>
     850:	55 95       	asr	r21
     852:	47 95       	ror	r20
     854:	9a 95       	dec	r25
     856:	e2 f7       	brpl	.-8      	; 0x850 <readPin+0x66>
     858:	ca 01       	movw	r24, r20
     85a:	81 70       	andi	r24, 0x01	; 1
     85c:	08 95       	ret
     85e:	80 e0       	ldi	r24, 0x00	; 0
     860:	08 95       	ret

00000862 <writePins>:
     862:	41 30       	cpi	r20, 0x01	; 1
     864:	29 f4       	brne	.+10     	; 0x870 <writePins+0xe>
     866:	fc 01       	movw	r30, r24
     868:	20 81       	ld	r18, Z
     86a:	62 2b       	or	r22, r18
     86c:	60 83       	st	Z, r22
     86e:	08 95       	ret
     870:	41 11       	cpse	r20, r1
     872:	05 c0       	rjmp	.+10     	; 0x87e <writePins+0x1c>
     874:	fc 01       	movw	r30, r24
     876:	20 81       	ld	r18, Z
     878:	60 95       	com	r22
     87a:	62 23       	and	r22, r18
     87c:	60 83       	st	Z, r22
     87e:	08 95       	ret

00000880 <pinsDirection>:
     880:	41 30       	cpi	r20, 0x01	; 1
     882:	29 f4       	brne	.+10     	; 0x88e <pinsDirection+0xe>
     884:	fc 01       	movw	r30, r24
     886:	20 81       	ld	r18, Z
     888:	62 2b       	or	r22, r18
     88a:	60 83       	st	Z, r22
     88c:	08 95       	ret
     88e:	41 11       	cpse	r20, r1
     890:	05 c0       	rjmp	.+10     	; 0x89c <pinsDirection+0x1c>
     892:	fc 01       	movw	r30, r24
     894:	20 81       	ld	r18, Z
     896:	60 95       	com	r22
     898:	62 23       	and	r22, r18
     89a:	60 83       	st	Z, r22
     89c:	08 95       	ret

0000089e <Uart_Init>:
		/* Put data into buffer, sends the data */
		u8Data = UDR1;
		break;
	}
	return u8Data;
}
     89e:	cf 93       	push	r28
     8a0:	c8 2f       	mov	r28, r24
     8a2:	db 01       	movw	r26, r22
     8a4:	ca 01       	movw	r24, r20
     8a6:	88 0f       	add	r24, r24
     8a8:	99 1f       	adc	r25, r25
     8aa:	aa 1f       	adc	r26, r26
     8ac:	bb 1f       	adc	r27, r27
     8ae:	88 0f       	add	r24, r24
     8b0:	99 1f       	adc	r25, r25
     8b2:	aa 1f       	adc	r26, r26
     8b4:	bb 1f       	adc	r27, r27
     8b6:	9c 01       	movw	r18, r24
     8b8:	ad 01       	movw	r20, r26
     8ba:	22 0f       	add	r18, r18
     8bc:	33 1f       	adc	r19, r19
     8be:	44 1f       	adc	r20, r20
     8c0:	55 1f       	adc	r21, r21
     8c2:	22 0f       	add	r18, r18
     8c4:	33 1f       	adc	r19, r19
     8c6:	44 1f       	adc	r20, r20
     8c8:	55 1f       	adc	r21, r21
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	72 e1       	ldi	r23, 0x12	; 18
     8ce:	8a e7       	ldi	r24, 0x7A	; 122
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	0e 94 43 1b 	call	0x3686	; 0x3686 <__udivmodsi4>
     8d6:	21 50       	subi	r18, 0x01	; 1
     8d8:	31 09       	sbc	r19, r1
     8da:	cc 23       	and	r28, r28
     8dc:	19 f0       	breq	.+6      	; 0x8e4 <Uart_Init+0x46>
     8de:	c1 30       	cpi	r28, 0x01	; 1
     8e0:	51 f0       	breq	.+20     	; 0x8f6 <Uart_Init+0x58>
     8e2:	13 c0       	rjmp	.+38     	; 0x90a <Uart_Init+0x6c>
     8e4:	30 93 90 00 	sts	0x0090, r19	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     8e8:	29 b9       	out	0x09, r18	; 9
     8ea:	88 e1       	ldi	r24, 0x18	; 24
     8ec:	8a b9       	out	0x0a, r24	; 10
     8ee:	86 e0       	ldi	r24, 0x06	; 6
     8f0:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     8f4:	0a c0       	rjmp	.+20     	; 0x90a <Uart_Init+0x6c>
     8f6:	30 93 98 00 	sts	0x0098, r19	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     8fa:	20 93 99 00 	sts	0x0099, r18	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     8fe:	88 e1       	ldi	r24, 0x18	; 24
     900:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     904:	86 e0       	ldi	r24, 0x06	; 6
     906:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     90a:	57 9a       	sbi	0x0a, 7	; 10
     90c:	78 94       	sei
     90e:	cf 91       	pop	r28
     910:	08 95       	ret

00000912 <Uart_SendByte>:
     912:	88 23       	and	r24, r24
     914:	19 f0       	breq	.+6      	; 0x91c <Uart_SendByte+0xa>
     916:	81 30       	cpi	r24, 0x01	; 1
     918:	29 f0       	breq	.+10     	; 0x924 <Uart_SendByte+0x12>
     91a:	08 95       	ret
     91c:	5d 9b       	sbis	0x0b, 5	; 11
     91e:	fe cf       	rjmp	.-4      	; 0x91c <Uart_SendByte+0xa>
     920:	6c b9       	out	0x0c, r22	; 12
     922:	08 95       	ret
     924:	eb e9       	ldi	r30, 0x9B	; 155
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	80 81       	ld	r24, Z
     92a:	85 ff       	sbrs	r24, 5
     92c:	fd cf       	rjmp	.-6      	; 0x928 <Uart_SendByte+0x16>
     92e:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     932:	08 95       	ret

00000934 <Uart_SendStr>:

void	Uart_SendStr(UART_Type uartNum, u8* pu8Str){
     934:	1f 93       	push	r17
     936:	cf 93       	push	r28
     938:	df 93       	push	r29
     93a:	eb 01       	movw	r28, r22
	u32 ind = 0;
	while(pu8Str[ind] != 0){
     93c:	68 81       	ld	r22, Y
     93e:	66 23       	and	r22, r22
     940:	39 f0       	breq	.+14     	; 0x950 <Uart_SendStr+0x1c>
     942:	18 2f       	mov	r17, r24
     944:	21 96       	adiw	r28, 0x01	; 1
		Uart_SendByte(uartNum,pu8Str[ind]);
     946:	81 2f       	mov	r24, r17
     948:	e4 df       	rcall	.-56     	; 0x912 <Uart_SendByte>
	return u8Data;
}

void	Uart_SendStr(UART_Type uartNum, u8* pu8Str){
	u32 ind = 0;
	while(pu8Str[ind] != 0){
     94a:	69 91       	ld	r22, Y+
     94c:	61 11       	cpse	r22, r1
     94e:	fb cf       	rjmp	.-10     	; 0x946 <Uart_SendStr+0x12>
		Uart_SendByte(uartNum,pu8Str[ind]);
		ind++;
	}
}
     950:	df 91       	pop	r29
     952:	cf 91       	pop	r28
     954:	1f 91       	pop	r17
     956:	08 95       	ret

00000958 <xEventGroupCreate>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     958:	cf 93       	push	r28
     95a:	df 93       	push	r29
     95c:	8f e0       	ldi	r24, 0x0F	; 15
     95e:	90 e0       	ldi	r25, 0x00	; 0
     960:	63 d1       	rcall	.+710    	; 0xc28 <pvPortMalloc>
     962:	ec 01       	movw	r28, r24
     964:	00 97       	sbiw	r24, 0x00	; 0
     966:	39 f0       	breq	.+14     	; 0x976 <xEventGroupCreate+0x1e>
     968:	fc 01       	movw	r30, r24
     96a:	11 92       	st	Z+, r1
     96c:	11 92       	st	Z+, r1
     96e:	11 92       	st	Z+, r1
     970:	11 92       	st	Z+, r1
     972:	cf 01       	movw	r24, r30
     974:	8d d1       	rcall	.+794    	; 0xc90 <vListInitialise>
     976:	ce 01       	movw	r24, r28
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	08 95       	ret

0000097e <xEventGroupWaitBits>:
     97e:	2f 92       	push	r2
     980:	3f 92       	push	r3
     982:	4f 92       	push	r4
     984:	5f 92       	push	r5
     986:	6f 92       	push	r6
     988:	7f 92       	push	r7
     98a:	8f 92       	push	r8
     98c:	9f 92       	push	r9
     98e:	af 92       	push	r10
     990:	bf 92       	push	r11
     992:	cf 92       	push	r12
     994:	df 92       	push	r13
     996:	ef 92       	push	r14
     998:	ff 92       	push	r15
     99a:	0f 93       	push	r16
     99c:	1f 93       	push	r17
     99e:	cf 93       	push	r28
     9a0:	df 93       	push	r29
     9a2:	ec 01       	movw	r28, r24
     9a4:	4a 01       	movw	r8, r20
     9a6:	5b 01       	movw	r10, r22
     9a8:	62 2e       	mov	r6, r18
     9aa:	70 2e       	mov	r7, r16
     9ac:	85 d7       	rcall	.+3850   	; 0x18b8 <vTaskSuspendAll>
     9ae:	28 80       	ld	r2, Y
     9b0:	39 80       	ldd	r3, Y+1	; 0x01
     9b2:	4a 80       	ldd	r4, Y+2	; 0x02
     9b4:	5b 80       	ldd	r5, Y+3	; 0x03
     9b6:	01 11       	cpse	r16, r1
     9b8:	0d c0       	rjmp	.+26     	; 0x9d4 <xEventGroupWaitBits+0x56>
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	b2 01       	movw	r22, r4
     9be:	a1 01       	movw	r20, r2
     9c0:	48 21       	and	r20, r8
     9c2:	59 21       	and	r21, r9
     9c4:	6a 21       	and	r22, r10
     9c6:	7b 21       	and	r23, r11
     9c8:	45 2b       	or	r20, r21
     9ca:	46 2b       	or	r20, r22
     9cc:	47 2b       	or	r20, r23
     9ce:	79 f4       	brne	.+30     	; 0x9ee <xEventGroupWaitBits+0x70>
     9d0:	80 e0       	ldi	r24, 0x00	; 0
     9d2:	0d c0       	rjmp	.+26     	; 0x9ee <xEventGroupWaitBits+0x70>
     9d4:	81 e0       	ldi	r24, 0x01	; 1
     9d6:	b2 01       	movw	r22, r4
     9d8:	a1 01       	movw	r20, r2
     9da:	48 21       	and	r20, r8
     9dc:	59 21       	and	r21, r9
     9de:	6a 21       	and	r22, r10
     9e0:	7b 21       	and	r23, r11
     9e2:	48 15       	cp	r20, r8
     9e4:	59 05       	cpc	r21, r9
     9e6:	6a 05       	cpc	r22, r10
     9e8:	7b 05       	cpc	r23, r11
     9ea:	09 f0       	breq	.+2      	; 0x9ee <xEventGroupWaitBits+0x70>
     9ec:	80 e0       	ldi	r24, 0x00	; 0
     9ee:	88 23       	and	r24, r24
     9f0:	81 f0       	breq	.+32     	; 0xa12 <xEventGroupWaitBits+0x94>
     9f2:	66 20       	and	r6, r6
     9f4:	09 f4       	brne	.+2      	; 0x9f8 <xEventGroupWaitBits+0x7a>
     9f6:	6b c0       	rjmp	.+214    	; 0xace <xEventGroupWaitBits+0x150>
     9f8:	80 94       	com	r8
     9fa:	90 94       	com	r9
     9fc:	a0 94       	com	r10
     9fe:	b0 94       	com	r11
     a00:	82 20       	and	r8, r2
     a02:	93 20       	and	r9, r3
     a04:	a4 20       	and	r10, r4
     a06:	b5 20       	and	r11, r5
     a08:	88 82       	st	Y, r8
     a0a:	99 82       	std	Y+1, r9	; 0x01
     a0c:	aa 82       	std	Y+2, r10	; 0x02
     a0e:	bb 82       	std	Y+3, r11	; 0x03
     a10:	5e c0       	rjmp	.+188    	; 0xace <xEventGroupWaitBits+0x150>
     a12:	c1 14       	cp	r12, r1
     a14:	d1 04       	cpc	r13, r1
     a16:	e1 04       	cpc	r14, r1
     a18:	f1 04       	cpc	r15, r1
     a1a:	09 f4       	brne	.+2      	; 0xa1e <xEventGroupWaitBits+0xa0>
     a1c:	58 c0       	rjmp	.+176    	; 0xace <xEventGroupWaitBits+0x150>
     a1e:	66 20       	and	r6, r6
     a20:	29 f0       	breq	.+10     	; 0xa2c <xEventGroupWaitBits+0xae>
     a22:	40 e0       	ldi	r20, 0x00	; 0
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	60 e0       	ldi	r22, 0x00	; 0
     a28:	71 e0       	ldi	r23, 0x01	; 1
     a2a:	03 c0       	rjmp	.+6      	; 0xa32 <xEventGroupWaitBits+0xb4>
     a2c:	40 e0       	ldi	r20, 0x00	; 0
     a2e:	50 e0       	ldi	r21, 0x00	; 0
     a30:	ba 01       	movw	r22, r20
     a32:	71 10       	cpse	r7, r1
     a34:	74 60       	ori	r23, 0x04	; 4
     a36:	48 29       	or	r20, r8
     a38:	59 29       	or	r21, r9
     a3a:	6a 29       	or	r22, r10
     a3c:	7b 29       	or	r23, r11
     a3e:	97 01       	movw	r18, r14
     a40:	86 01       	movw	r16, r12
     a42:	ce 01       	movw	r24, r28
     a44:	04 96       	adiw	r24, 0x04	; 4
     a46:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <vTaskPlaceOnUnorderedEventList>
     a4a:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <xTaskResumeAll>
     a4e:	81 11       	cpse	r24, r1
     a50:	01 c0       	rjmp	.+2      	; 0xa54 <xEventGroupWaitBits+0xd6>
     a52:	58 d2       	rcall	.+1200   	; 0xf04 <vPortYield>
     a54:	0e 94 56 10 	call	0x20ac	; 0x20ac <uxTaskResetEventItemValue>
     a58:	91 fd       	sbrc	r25, 1
     a5a:	35 c0       	rjmp	.+106    	; 0xac6 <xEventGroupWaitBits+0x148>
     a5c:	0f b6       	in	r0, 0x3f	; 63
     a5e:	f8 94       	cli
     a60:	0f 92       	push	r0
     a62:	68 81       	ld	r22, Y
     a64:	79 81       	ldd	r23, Y+1	; 0x01
     a66:	8a 81       	ldd	r24, Y+2	; 0x02
     a68:	9b 81       	ldd	r25, Y+3	; 0x03
     a6a:	71 10       	cpse	r7, r1
     a6c:	0d c0       	rjmp	.+26     	; 0xa88 <xEventGroupWaitBits+0x10a>
     a6e:	21 e0       	ldi	r18, 0x01	; 1
     a70:	75 01       	movw	r14, r10
     a72:	64 01       	movw	r12, r8
     a74:	c6 22       	and	r12, r22
     a76:	d7 22       	and	r13, r23
     a78:	e8 22       	and	r14, r24
     a7a:	f9 22       	and	r15, r25
     a7c:	cd 28       	or	r12, r13
     a7e:	ce 28       	or	r12, r14
     a80:	cf 28       	or	r12, r15
     a82:	79 f4       	brne	.+30     	; 0xaa2 <xEventGroupWaitBits+0x124>
     a84:	20 e0       	ldi	r18, 0x00	; 0
     a86:	0d c0       	rjmp	.+26     	; 0xaa2 <xEventGroupWaitBits+0x124>
     a88:	21 e0       	ldi	r18, 0x01	; 1
     a8a:	75 01       	movw	r14, r10
     a8c:	64 01       	movw	r12, r8
     a8e:	c6 22       	and	r12, r22
     a90:	d7 22       	and	r13, r23
     a92:	e8 22       	and	r14, r24
     a94:	f9 22       	and	r15, r25
     a96:	c8 14       	cp	r12, r8
     a98:	d9 04       	cpc	r13, r9
     a9a:	ea 04       	cpc	r14, r10
     a9c:	fb 04       	cpc	r15, r11
     a9e:	09 f0       	breq	.+2      	; 0xaa2 <xEventGroupWaitBits+0x124>
     aa0:	20 e0       	ldi	r18, 0x00	; 0
     aa2:	22 23       	and	r18, r18
     aa4:	71 f0       	breq	.+28     	; 0xac2 <xEventGroupWaitBits+0x144>
     aa6:	66 20       	and	r6, r6
     aa8:	61 f0       	breq	.+24     	; 0xac2 <xEventGroupWaitBits+0x144>
     aaa:	80 94       	com	r8
     aac:	90 94       	com	r9
     aae:	a0 94       	com	r10
     ab0:	b0 94       	com	r11
     ab2:	86 22       	and	r8, r22
     ab4:	97 22       	and	r9, r23
     ab6:	a8 22       	and	r10, r24
     ab8:	b9 22       	and	r11, r25
     aba:	88 82       	st	Y, r8
     abc:	99 82       	std	Y+1, r9	; 0x01
     abe:	aa 82       	std	Y+2, r10	; 0x02
     ac0:	bb 82       	std	Y+3, r11	; 0x03
     ac2:	0f 90       	pop	r0
     ac4:	0f be       	out	0x3f, r0	; 63
     ac6:	1b 01       	movw	r2, r22
     ac8:	2c 01       	movw	r4, r24
     aca:	55 24       	eor	r5, r5
     acc:	01 c0       	rjmp	.+2      	; 0xad0 <xEventGroupWaitBits+0x152>
     ace:	d2 d7       	rcall	.+4004   	; 0x1a74 <xTaskResumeAll>
     ad0:	c2 01       	movw	r24, r4
     ad2:	b1 01       	movw	r22, r2
     ad4:	df 91       	pop	r29
     ad6:	cf 91       	pop	r28
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	df 90       	pop	r13
     ae2:	cf 90       	pop	r12
     ae4:	bf 90       	pop	r11
     ae6:	af 90       	pop	r10
     ae8:	9f 90       	pop	r9
     aea:	8f 90       	pop	r8
     aec:	7f 90       	pop	r7
     aee:	6f 90       	pop	r6
     af0:	5f 90       	pop	r5
     af2:	4f 90       	pop	r4
     af4:	3f 90       	pop	r3
     af6:	2f 90       	pop	r2
     af8:	08 95       	ret

00000afa <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     afa:	4f 92       	push	r4
     afc:	5f 92       	push	r5
     afe:	6f 92       	push	r6
     b00:	7f 92       	push	r7
     b02:	8f 92       	push	r8
     b04:	9f 92       	push	r9
     b06:	af 92       	push	r10
     b08:	bf 92       	push	r11
     b0a:	cf 92       	push	r12
     b0c:	df 92       	push	r13
     b0e:	ef 92       	push	r14
     b10:	ff 92       	push	r15
     b12:	0f 93       	push	r16
     b14:	1f 93       	push	r17
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	ec 01       	movw	r28, r24
     b1c:	6a 01       	movw	r12, r20
     b1e:	7b 01       	movw	r14, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b20:	8c 01       	movw	r16, r24
     b22:	09 5f       	subi	r16, 0xF9	; 249
     b24:	1f 4f       	sbci	r17, 0xFF	; 255
	vTaskSuspendAll();
     b26:	c8 d6       	rcall	.+3472   	; 0x18b8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     b28:	eb 85       	ldd	r30, Y+11	; 0x0b
     b2a:	fc 85       	ldd	r31, Y+12	; 0x0c

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     b2c:	88 81       	ld	r24, Y
     b2e:	99 81       	ldd	r25, Y+1	; 0x01
     b30:	aa 81       	ldd	r26, Y+2	; 0x02
     b32:	bb 81       	ldd	r27, Y+3	; 0x03
     b34:	c8 2a       	or	r12, r24
     b36:	d9 2a       	or	r13, r25
     b38:	ea 2a       	or	r14, r26
     b3a:	fb 2a       	or	r15, r27
     b3c:	c8 82       	st	Y, r12
     b3e:	d9 82       	std	Y+1, r13	; 0x01
     b40:	ea 82       	std	Y+2, r14	; 0x02
     b42:	fb 82       	std	Y+3, r15	; 0x03

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     b44:	0e 17       	cp	r16, r30
     b46:	1f 07       	cpc	r17, r31
     b48:	09 f4       	brne	.+2      	; 0xb4c <xEventGroupSetBits+0x52>
     b4a:	45 c0       	rjmp	.+138    	; 0xbd6 <xEventGroupSetBits+0xdc>
     b4c:	c1 2c       	mov	r12, r1
     b4e:	d1 2c       	mov	r13, r1
     b50:	76 01       	movw	r14, r12
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     b52:	99 24       	eor	r9, r9
     b54:	93 94       	inc	r9
     b56:	81 2c       	mov	r8, r1
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     b58:	a4 80       	ldd	r10, Z+4	; 0x04
     b5a:	b5 80       	ldd	r11, Z+5	; 0x05
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     b5c:	80 81       	ld	r24, Z
     b5e:	91 81       	ldd	r25, Z+1	; 0x01
     b60:	a2 81       	ldd	r26, Z+2	; 0x02
     b62:	b3 81       	ldd	r27, Z+3	; 0x03
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     b64:	ac 01       	movw	r20, r24
     b66:	bd 01       	movw	r22, r26
     b68:	77 27       	eor	r23, r23

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     b6a:	b2 fd       	sbrc	r27, 2
     b6c:	0f c0       	rjmp	.+30     	; 0xb8c <xEventGroupSetBits+0x92>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     b6e:	48 80       	ld	r4, Y
     b70:	59 80       	ldd	r5, Y+1	; 0x01
     b72:	6a 80       	ldd	r6, Y+2	; 0x02
     b74:	7b 80       	ldd	r7, Y+3	; 0x03
     b76:	44 22       	and	r4, r20
     b78:	55 22       	and	r5, r21
     b7a:	66 22       	and	r6, r22
     b7c:	77 22       	and	r7, r23
     b7e:	29 2d       	mov	r18, r9
     b80:	45 28       	or	r4, r5
     b82:	46 28       	or	r4, r6
     b84:	47 28       	or	r4, r7
     b86:	89 f4       	brne	.+34     	; 0xbaa <xEventGroupSetBits+0xb0>
     b88:	28 2d       	mov	r18, r8
     b8a:	0f c0       	rjmp	.+30     	; 0xbaa <xEventGroupSetBits+0xb0>
     b8c:	48 80       	ld	r4, Y
     b8e:	59 80       	ldd	r5, Y+1	; 0x01
     b90:	6a 80       	ldd	r6, Y+2	; 0x02
     b92:	7b 80       	ldd	r7, Y+3	; 0x03
     b94:	44 22       	and	r4, r20
     b96:	55 22       	and	r5, r21
     b98:	66 22       	and	r6, r22
     b9a:	77 22       	and	r7, r23
     b9c:	29 2d       	mov	r18, r9
     b9e:	44 16       	cp	r4, r20
     ba0:	55 06       	cpc	r5, r21
     ba2:	66 06       	cpc	r6, r22
     ba4:	77 06       	cpc	r7, r23
     ba6:	09 f0       	breq	.+2      	; 0xbaa <xEventGroupSetBits+0xb0>
     ba8:	28 2d       	mov	r18, r8
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     baa:	22 23       	and	r18, r18
     bac:	71 f0       	breq	.+28     	; 0xbca <xEventGroupSetBits+0xd0>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     bae:	b0 ff       	sbrs	r27, 0
     bb0:	04 c0       	rjmp	.+8      	; 0xbba <xEventGroupSetBits+0xc0>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     bb2:	c4 2a       	or	r12, r20
     bb4:	d5 2a       	or	r13, r21
     bb6:	e6 2a       	or	r14, r22
     bb8:	f7 2a       	or	r15, r23
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     bba:	48 81       	ld	r20, Y
     bbc:	59 81       	ldd	r21, Y+1	; 0x01
     bbe:	6a 81       	ldd	r22, Y+2	; 0x02
     bc0:	7b 81       	ldd	r23, Y+3	; 0x03
     bc2:	72 60       	ori	r23, 0x02	; 2
     bc4:	cf 01       	movw	r24, r30
     bc6:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <xTaskRemoveFromUnorderedEventList>
     bca:	ea 2d       	mov	r30, r10
     bcc:	fb 2d       	mov	r31, r11

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     bce:	0e 17       	cp	r16, r30
     bd0:	1f 07       	cpc	r17, r31
     bd2:	11 f6       	brne	.-124    	; 0xb58 <xEventGroupSetBits+0x5e>
     bd4:	03 c0       	rjmp	.+6      	; 0xbdc <xEventGroupSetBits+0xe2>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     bd6:	c1 2c       	mov	r12, r1
     bd8:	d1 2c       	mov	r13, r1
     bda:	76 01       	movw	r14, r12
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     bdc:	c0 94       	com	r12
     bde:	d0 94       	com	r13
     be0:	e0 94       	com	r14
     be2:	f0 94       	com	r15
     be4:	88 81       	ld	r24, Y
     be6:	99 81       	ldd	r25, Y+1	; 0x01
     be8:	aa 81       	ldd	r26, Y+2	; 0x02
     bea:	bb 81       	ldd	r27, Y+3	; 0x03
     bec:	c8 22       	and	r12, r24
     bee:	d9 22       	and	r13, r25
     bf0:	ea 22       	and	r14, r26
     bf2:	fb 22       	and	r15, r27
     bf4:	c8 82       	st	Y, r12
     bf6:	d9 82       	std	Y+1, r13	; 0x01
     bf8:	ea 82       	std	Y+2, r14	; 0x02
	}
	( void ) xTaskResumeAll();
     bfa:	fb 82       	std	Y+3, r15	; 0x03
     bfc:	3b d7       	rcall	.+3702   	; 0x1a74 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     bfe:	68 81       	ld	r22, Y
     c00:	79 81       	ldd	r23, Y+1	; 0x01
     c02:	8a 81       	ldd	r24, Y+2	; 0x02
     c04:	9b 81       	ldd	r25, Y+3	; 0x03
}
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	ff 90       	pop	r15
     c10:	ef 90       	pop	r14
     c12:	df 90       	pop	r13
     c14:	cf 90       	pop	r12
     c16:	bf 90       	pop	r11
     c18:	af 90       	pop	r10
     c1a:	9f 90       	pop	r9
     c1c:	8f 90       	pop	r8
     c1e:	7f 90       	pop	r7
     c20:	6f 90       	pop	r6
     c22:	5f 90       	pop	r5
     c24:	4f 90       	pop	r4
     c26:	08 95       	ret

00000c28 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     c28:	cf 93       	push	r28
     c2a:	df 93       	push	r29
     c2c:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     c2e:	44 d6       	rcall	.+3208   	; 0x18b8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     c30:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <__data_end>
     c34:	90 91 7d 03 	lds	r25, 0x037D	; 0x80037d <__data_end+0x1>
     c38:	89 2b       	or	r24, r25
     c3a:	31 f4       	brne	.+12     	; 0xc48 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     c3c:	81 e8       	ldi	r24, 0x81	; 129
     c3e:	93 e0       	ldi	r25, 0x03	; 3
     c40:	90 93 7d 03 	sts	0x037D, r25	; 0x80037d <__data_end+0x1>
     c44:	80 93 7c 03 	sts	0x037C, r24	; 0x80037c <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     c48:	20 91 7e 03 	lds	r18, 0x037E	; 0x80037e <xNextFreeByte>
     c4c:	30 91 7f 03 	lds	r19, 0x037F	; 0x80037f <xNextFreeByte+0x1>
     c50:	c9 01       	movw	r24, r18
     c52:	8c 0f       	add	r24, r28
     c54:	9d 1f       	adc	r25, r29
     c56:	83 35       	cpi	r24, 0x53	; 83
     c58:	4b e0       	ldi	r20, 0x0B	; 11
     c5a:	94 07       	cpc	r25, r20
     c5c:	70 f4       	brcc	.+28     	; 0xc7a <pvPortMalloc+0x52>
     c5e:	28 17       	cp	r18, r24
     c60:	39 07       	cpc	r19, r25
     c62:	70 f4       	brcc	.+28     	; 0xc80 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     c64:	c0 91 7c 03 	lds	r28, 0x037C	; 0x80037c <__data_end>
     c68:	d0 91 7d 03 	lds	r29, 0x037D	; 0x80037d <__data_end+0x1>
     c6c:	c2 0f       	add	r28, r18
     c6e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     c70:	90 93 7f 03 	sts	0x037F, r25	; 0x80037f <xNextFreeByte+0x1>
     c74:	80 93 7e 03 	sts	0x037E, r24	; 0x80037e <xNextFreeByte>
     c78:	05 c0       	rjmp	.+10     	; 0xc84 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     c7a:	c0 e0       	ldi	r28, 0x00	; 0
     c7c:	d0 e0       	ldi	r29, 0x00	; 0
     c7e:	02 c0       	rjmp	.+4      	; 0xc84 <pvPortMalloc+0x5c>
     c80:	c0 e0       	ldi	r28, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c82:	d0 e0       	ldi	r29, 0x00	; 0
     c84:	f7 d6       	rcall	.+3566   	; 0x1a74 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c86:	ce 01       	movw	r24, r28
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
     c8c:	08 95       	ret

00000c8e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c8e:	08 95       	ret

00000c90 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     c90:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c92:	03 96       	adiw	r24, 0x03	; 3
     c94:	92 83       	std	Z+2, r25	; 0x02
     c96:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c98:	4f ef       	ldi	r20, 0xFF	; 255
     c9a:	5f ef       	ldi	r21, 0xFF	; 255
     c9c:	ba 01       	movw	r22, r20
     c9e:	43 83       	std	Z+3, r20	; 0x03
     ca0:	54 83       	std	Z+4, r21	; 0x04
     ca2:	65 83       	std	Z+5, r22	; 0x05
     ca4:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ca6:	90 87       	std	Z+8, r25	; 0x08
     ca8:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     caa:	92 87       	std	Z+10, r25	; 0x0a
     cac:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     cae:	10 82       	st	Z, r1
     cb0:	08 95       	ret

00000cb2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     cb2:	fc 01       	movw	r30, r24
     cb4:	13 86       	std	Z+11, r1	; 0x0b
     cb6:	12 86       	std	Z+10, r1	; 0x0a
     cb8:	08 95       	ret

00000cba <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	9c 01       	movw	r18, r24
     cc0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     cc2:	dc 01       	movw	r26, r24
     cc4:	11 96       	adiw	r26, 0x01	; 1
     cc6:	cd 91       	ld	r28, X+
     cc8:	dc 91       	ld	r29, X
     cca:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     ccc:	d5 83       	std	Z+5, r29	; 0x05
     cce:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     cd0:	8e 81       	ldd	r24, Y+6	; 0x06
     cd2:	9f 81       	ldd	r25, Y+7	; 0x07
     cd4:	97 83       	std	Z+7, r25	; 0x07
     cd6:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     cd8:	8e 81       	ldd	r24, Y+6	; 0x06
     cda:	9f 81       	ldd	r25, Y+7	; 0x07
     cdc:	dc 01       	movw	r26, r24
     cde:	15 96       	adiw	r26, 0x05	; 5
     ce0:	7c 93       	st	X, r23
     ce2:	6e 93       	st	-X, r22
     ce4:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     ce6:	7f 83       	std	Y+7, r23	; 0x07
     ce8:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     cea:	33 87       	std	Z+11, r19	; 0x0b
     cec:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     cee:	f9 01       	movw	r30, r18
     cf0:	80 81       	ld	r24, Z
     cf2:	8f 5f       	subi	r24, 0xFF	; 255
     cf4:	80 83       	st	Z, r24
}
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	08 95       	ret

00000cfc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     cfc:	0f 93       	push	r16
     cfe:	1f 93       	push	r17
     d00:	cf 93       	push	r28
     d02:	df 93       	push	r29
     d04:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     d06:	08 81       	ld	r16, Y
     d08:	19 81       	ldd	r17, Y+1	; 0x01
     d0a:	2a 81       	ldd	r18, Y+2	; 0x02
     d0c:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d0e:	0f 3f       	cpi	r16, 0xFF	; 255
     d10:	4f ef       	ldi	r20, 0xFF	; 255
     d12:	14 07       	cpc	r17, r20
     d14:	24 07       	cpc	r18, r20
     d16:	34 07       	cpc	r19, r20
     d18:	21 f4       	brne	.+8      	; 0xd22 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d1a:	fc 01       	movw	r30, r24
     d1c:	a1 85       	ldd	r26, Z+9	; 0x09
     d1e:	b2 85       	ldd	r27, Z+10	; 0x0a
     d20:	11 c0       	rjmp	.+34     	; 0xd44 <vListInsert+0x48>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d22:	dc 01       	movw	r26, r24
     d24:	13 96       	adiw	r26, 0x03	; 3
     d26:	01 c0       	rjmp	.+2      	; 0xd2a <vListInsert+0x2e>
     d28:	df 01       	movw	r26, r30
     d2a:	14 96       	adiw	r26, 0x04	; 4
     d2c:	ed 91       	ld	r30, X+
     d2e:	fc 91       	ld	r31, X
     d30:	15 97       	sbiw	r26, 0x05	; 5
     d32:	40 81       	ld	r20, Z
     d34:	51 81       	ldd	r21, Z+1	; 0x01
     d36:	62 81       	ldd	r22, Z+2	; 0x02
     d38:	73 81       	ldd	r23, Z+3	; 0x03
     d3a:	04 17       	cp	r16, r20
     d3c:	15 07       	cpc	r17, r21
     d3e:	26 07       	cpc	r18, r22
     d40:	37 07       	cpc	r19, r23
     d42:	90 f7       	brcc	.-28     	; 0xd28 <vListInsert+0x2c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     d44:	14 96       	adiw	r26, 0x04	; 4
     d46:	ed 91       	ld	r30, X+
     d48:	fc 91       	ld	r31, X
     d4a:	15 97       	sbiw	r26, 0x05	; 5
     d4c:	fd 83       	std	Y+5, r31	; 0x05
     d4e:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     d50:	d7 83       	std	Z+7, r29	; 0x07
     d52:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     d54:	bf 83       	std	Y+7, r27	; 0x07
     d56:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     d58:	15 96       	adiw	r26, 0x05	; 5
     d5a:	dc 93       	st	X, r29
     d5c:	ce 93       	st	-X, r28
     d5e:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d60:	9b 87       	std	Y+11, r25	; 0x0b
     d62:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     d64:	fc 01       	movw	r30, r24
     d66:	20 81       	ld	r18, Z
     d68:	2f 5f       	subi	r18, 0xFF	; 255
     d6a:	20 83       	st	Z, r18
}
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	1f 91       	pop	r17
     d72:	0f 91       	pop	r16
     d74:	08 95       	ret

00000d76 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     d76:	cf 93       	push	r28
     d78:	df 93       	push	r29
     d7a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     d7c:	a2 85       	ldd	r26, Z+10	; 0x0a
     d7e:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     d80:	c4 81       	ldd	r28, Z+4	; 0x04
     d82:	d5 81       	ldd	r29, Z+5	; 0x05
     d84:	86 81       	ldd	r24, Z+6	; 0x06
     d86:	97 81       	ldd	r25, Z+7	; 0x07
     d88:	9f 83       	std	Y+7, r25	; 0x07
     d8a:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     d8c:	c6 81       	ldd	r28, Z+6	; 0x06
     d8e:	d7 81       	ldd	r29, Z+7	; 0x07
     d90:	84 81       	ldd	r24, Z+4	; 0x04
     d92:	95 81       	ldd	r25, Z+5	; 0x05
     d94:	9d 83       	std	Y+5, r25	; 0x05
     d96:	8c 83       	std	Y+4, r24	; 0x04

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     d98:	11 96       	adiw	r26, 0x01	; 1
     d9a:	8d 91       	ld	r24, X+
     d9c:	9c 91       	ld	r25, X
     d9e:	12 97       	sbiw	r26, 0x02	; 2
     da0:	e8 17       	cp	r30, r24
     da2:	f9 07       	cpc	r31, r25
     da4:	31 f4       	brne	.+12     	; 0xdb2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     da6:	86 81       	ldd	r24, Z+6	; 0x06
     da8:	97 81       	ldd	r25, Z+7	; 0x07
     daa:	12 96       	adiw	r26, 0x02	; 2
     dac:	9c 93       	st	X, r25
     dae:	8e 93       	st	-X, r24
     db0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     db2:	13 86       	std	Z+11, r1	; 0x0b
     db4:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     db6:	8c 91       	ld	r24, X
     db8:	81 50       	subi	r24, 0x01	; 1
     dba:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     dbc:	df 91       	pop	r29
     dbe:	cf 91       	pop	r28
     dc0:	08 95       	ret

00000dc2 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     dc2:	31 e1       	ldi	r19, 0x11	; 17
     dc4:	fc 01       	movw	r30, r24
     dc6:	30 83       	st	Z, r19
     dc8:	31 97       	sbiw	r30, 0x01	; 1
     dca:	22 e2       	ldi	r18, 0x22	; 34
     dcc:	20 83       	st	Z, r18
     dce:	31 97       	sbiw	r30, 0x01	; 1
     dd0:	a3 e3       	ldi	r26, 0x33	; 51
     dd2:	a0 83       	st	Z, r26
     dd4:	31 97       	sbiw	r30, 0x01	; 1
     dd6:	60 83       	st	Z, r22
     dd8:	31 97       	sbiw	r30, 0x01	; 1
     dda:	70 83       	st	Z, r23
     ddc:	31 97       	sbiw	r30, 0x01	; 1
     dde:	10 82       	st	Z, r1
     de0:	31 97       	sbiw	r30, 0x01	; 1
     de2:	60 e8       	ldi	r22, 0x80	; 128
     de4:	60 83       	st	Z, r22
     de6:	31 97       	sbiw	r30, 0x01	; 1
     de8:	10 82       	st	Z, r1
     dea:	31 97       	sbiw	r30, 0x01	; 1
     dec:	62 e0       	ldi	r22, 0x02	; 2
     dee:	60 83       	st	Z, r22
     df0:	31 97       	sbiw	r30, 0x01	; 1
     df2:	63 e0       	ldi	r22, 0x03	; 3
     df4:	60 83       	st	Z, r22
     df6:	31 97       	sbiw	r30, 0x01	; 1
     df8:	64 e0       	ldi	r22, 0x04	; 4
     dfa:	60 83       	st	Z, r22
     dfc:	31 97       	sbiw	r30, 0x01	; 1
     dfe:	65 e0       	ldi	r22, 0x05	; 5
     e00:	60 83       	st	Z, r22
     e02:	31 97       	sbiw	r30, 0x01	; 1
     e04:	66 e0       	ldi	r22, 0x06	; 6
     e06:	60 83       	st	Z, r22
     e08:	31 97       	sbiw	r30, 0x01	; 1
     e0a:	67 e0       	ldi	r22, 0x07	; 7
     e0c:	60 83       	st	Z, r22
     e0e:	31 97       	sbiw	r30, 0x01	; 1
     e10:	68 e0       	ldi	r22, 0x08	; 8
     e12:	60 83       	st	Z, r22
     e14:	31 97       	sbiw	r30, 0x01	; 1
     e16:	69 e0       	ldi	r22, 0x09	; 9
     e18:	60 83       	st	Z, r22
     e1a:	31 97       	sbiw	r30, 0x01	; 1
     e1c:	60 e1       	ldi	r22, 0x10	; 16
     e1e:	60 83       	st	Z, r22
     e20:	31 97       	sbiw	r30, 0x01	; 1
     e22:	30 83       	st	Z, r19
     e24:	31 97       	sbiw	r30, 0x01	; 1
     e26:	32 e1       	ldi	r19, 0x12	; 18
     e28:	30 83       	st	Z, r19
     e2a:	31 97       	sbiw	r30, 0x01	; 1
     e2c:	33 e1       	ldi	r19, 0x13	; 19
     e2e:	30 83       	st	Z, r19
     e30:	31 97       	sbiw	r30, 0x01	; 1
     e32:	34 e1       	ldi	r19, 0x14	; 20
     e34:	30 83       	st	Z, r19
     e36:	31 97       	sbiw	r30, 0x01	; 1
     e38:	35 e1       	ldi	r19, 0x15	; 21
     e3a:	30 83       	st	Z, r19
     e3c:	31 97       	sbiw	r30, 0x01	; 1
     e3e:	36 e1       	ldi	r19, 0x16	; 22
     e40:	30 83       	st	Z, r19
     e42:	31 97       	sbiw	r30, 0x01	; 1
     e44:	37 e1       	ldi	r19, 0x17	; 23
     e46:	30 83       	st	Z, r19
     e48:	31 97       	sbiw	r30, 0x01	; 1
     e4a:	38 e1       	ldi	r19, 0x18	; 24
     e4c:	30 83       	st	Z, r19
     e4e:	31 97       	sbiw	r30, 0x01	; 1
     e50:	39 e1       	ldi	r19, 0x19	; 25
     e52:	30 83       	st	Z, r19
     e54:	31 97       	sbiw	r30, 0x01	; 1
     e56:	30 e2       	ldi	r19, 0x20	; 32
     e58:	30 83       	st	Z, r19
     e5a:	31 97       	sbiw	r30, 0x01	; 1
     e5c:	31 e2       	ldi	r19, 0x21	; 33
     e5e:	30 83       	st	Z, r19
     e60:	31 97       	sbiw	r30, 0x01	; 1
     e62:	20 83       	st	Z, r18
     e64:	31 97       	sbiw	r30, 0x01	; 1
     e66:	23 e2       	ldi	r18, 0x23	; 35
     e68:	20 83       	st	Z, r18
     e6a:	31 97       	sbiw	r30, 0x01	; 1
     e6c:	40 83       	st	Z, r20
     e6e:	31 97       	sbiw	r30, 0x01	; 1
     e70:	50 83       	st	Z, r21
     e72:	31 97       	sbiw	r30, 0x01	; 1
     e74:	26 e2       	ldi	r18, 0x26	; 38
     e76:	20 83       	st	Z, r18
     e78:	31 97       	sbiw	r30, 0x01	; 1
     e7a:	27 e2       	ldi	r18, 0x27	; 39
     e7c:	20 83       	st	Z, r18
     e7e:	31 97       	sbiw	r30, 0x01	; 1
     e80:	28 e2       	ldi	r18, 0x28	; 40
     e82:	20 83       	st	Z, r18
     e84:	31 97       	sbiw	r30, 0x01	; 1
     e86:	29 e2       	ldi	r18, 0x29	; 41
     e88:	20 83       	st	Z, r18
     e8a:	31 97       	sbiw	r30, 0x01	; 1
     e8c:	20 e3       	ldi	r18, 0x30	; 48
     e8e:	20 83       	st	Z, r18
     e90:	31 97       	sbiw	r30, 0x01	; 1
     e92:	21 e3       	ldi	r18, 0x31	; 49
     e94:	20 83       	st	Z, r18
     e96:	86 97       	sbiw	r24, 0x26	; 38
     e98:	08 95       	ret

00000e9a <xPortStartScheduler>:
     e9a:	1b bc       	out	0x2b, r1	; 43
     e9c:	8c e7       	ldi	r24, 0x7C	; 124
     e9e:	8a bd       	out	0x2a, r24	; 42
     ea0:	8b e0       	ldi	r24, 0x0B	; 11
     ea2:	8e bd       	out	0x2e, r24	; 46
     ea4:	87 b7       	in	r24, 0x37	; 55
     ea6:	80 61       	ori	r24, 0x10	; 16
     ea8:	87 bf       	out	0x37, r24	; 55
     eaa:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
     eae:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
     eb2:	cd 91       	ld	r28, X+
     eb4:	cd bf       	out	0x3d, r28	; 61
     eb6:	dd 91       	ld	r29, X+
     eb8:	de bf       	out	0x3e, r29	; 62
     eba:	ff 91       	pop	r31
     ebc:	ef 91       	pop	r30
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	bf 91       	pop	r27
     ec4:	af 91       	pop	r26
     ec6:	9f 91       	pop	r25
     ec8:	8f 91       	pop	r24
     eca:	7f 91       	pop	r23
     ecc:	6f 91       	pop	r22
     ece:	5f 91       	pop	r21
     ed0:	4f 91       	pop	r20
     ed2:	3f 91       	pop	r19
     ed4:	2f 91       	pop	r18
     ed6:	1f 91       	pop	r17
     ed8:	0f 91       	pop	r16
     eda:	ff 90       	pop	r15
     edc:	ef 90       	pop	r14
     ede:	df 90       	pop	r13
     ee0:	cf 90       	pop	r12
     ee2:	bf 90       	pop	r11
     ee4:	af 90       	pop	r10
     ee6:	9f 90       	pop	r9
     ee8:	8f 90       	pop	r8
     eea:	7f 90       	pop	r7
     eec:	6f 90       	pop	r6
     eee:	5f 90       	pop	r5
     ef0:	4f 90       	pop	r4
     ef2:	3f 90       	pop	r3
     ef4:	2f 90       	pop	r2
     ef6:	1f 90       	pop	r1
     ef8:	0f 90       	pop	r0
     efa:	0f be       	out	0x3f, r0	; 63
     efc:	0f 90       	pop	r0
     efe:	08 95       	ret
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	08 95       	ret

00000f04 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f04:	0f 92       	push	r0
     f06:	0f b6       	in	r0, 0x3f	; 63
     f08:	f8 94       	cli
     f0a:	0f 92       	push	r0
     f0c:	1f 92       	push	r1
     f0e:	11 24       	eor	r1, r1
     f10:	2f 92       	push	r2
     f12:	3f 92       	push	r3
     f14:	4f 92       	push	r4
     f16:	5f 92       	push	r5
     f18:	6f 92       	push	r6
     f1a:	7f 92       	push	r7
     f1c:	8f 92       	push	r8
     f1e:	9f 92       	push	r9
     f20:	af 92       	push	r10
     f22:	bf 92       	push	r11
     f24:	cf 92       	push	r12
     f26:	df 92       	push	r13
     f28:	ef 92       	push	r14
     f2a:	ff 92       	push	r15
     f2c:	0f 93       	push	r16
     f2e:	1f 93       	push	r17
     f30:	2f 93       	push	r18
     f32:	3f 93       	push	r19
     f34:	4f 93       	push	r20
     f36:	5f 93       	push	r21
     f38:	6f 93       	push	r22
     f3a:	7f 93       	push	r23
     f3c:	8f 93       	push	r24
     f3e:	9f 93       	push	r25
     f40:	af 93       	push	r26
     f42:	bf 93       	push	r27
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
     f48:	ef 93       	push	r30
     f4a:	ff 93       	push	r31
     f4c:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
     f50:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
     f54:	0d b6       	in	r0, 0x3d	; 61
     f56:	0d 92       	st	X+, r0
     f58:	0e b6       	in	r0, 0x3e	; 62
     f5a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f5c:	67 d6       	rcall	.+3278   	; 0x1c2c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f5e:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
     f62:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
     f66:	cd 91       	ld	r28, X+
     f68:	cd bf       	out	0x3d, r28	; 61
     f6a:	dd 91       	ld	r29, X+
     f6c:	de bf       	out	0x3e, r29	; 62
     f6e:	ff 91       	pop	r31
     f70:	ef 91       	pop	r30
     f72:	df 91       	pop	r29
     f74:	cf 91       	pop	r28
     f76:	bf 91       	pop	r27
     f78:	af 91       	pop	r26
     f7a:	9f 91       	pop	r25
     f7c:	8f 91       	pop	r24
     f7e:	7f 91       	pop	r23
     f80:	6f 91       	pop	r22
     f82:	5f 91       	pop	r21
     f84:	4f 91       	pop	r20
     f86:	3f 91       	pop	r19
     f88:	2f 91       	pop	r18
     f8a:	1f 91       	pop	r17
     f8c:	0f 91       	pop	r16
     f8e:	ff 90       	pop	r15
     f90:	ef 90       	pop	r14
     f92:	df 90       	pop	r13
     f94:	cf 90       	pop	r12
     f96:	bf 90       	pop	r11
     f98:	af 90       	pop	r10
     f9a:	9f 90       	pop	r9
     f9c:	8f 90       	pop	r8
     f9e:	7f 90       	pop	r7
     fa0:	6f 90       	pop	r6
     fa2:	5f 90       	pop	r5
     fa4:	4f 90       	pop	r4
     fa6:	3f 90       	pop	r3
     fa8:	2f 90       	pop	r2
     faa:	1f 90       	pop	r1
     fac:	0f 90       	pop	r0
     fae:	0f be       	out	0x3f, r0	; 63
     fb0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     fb2:	08 95       	ret

00000fb4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     fb4:	0f 92       	push	r0
     fb6:	0f b6       	in	r0, 0x3f	; 63
     fb8:	f8 94       	cli
     fba:	0f 92       	push	r0
     fbc:	1f 92       	push	r1
     fbe:	11 24       	eor	r1, r1
     fc0:	2f 92       	push	r2
     fc2:	3f 92       	push	r3
     fc4:	4f 92       	push	r4
     fc6:	5f 92       	push	r5
     fc8:	6f 92       	push	r6
     fca:	7f 92       	push	r7
     fcc:	8f 92       	push	r8
     fce:	9f 92       	push	r9
     fd0:	af 92       	push	r10
     fd2:	bf 92       	push	r11
     fd4:	cf 92       	push	r12
     fd6:	df 92       	push	r13
     fd8:	ef 92       	push	r14
     fda:	ff 92       	push	r15
     fdc:	0f 93       	push	r16
     fde:	1f 93       	push	r17
     fe0:	2f 93       	push	r18
     fe2:	3f 93       	push	r19
     fe4:	4f 93       	push	r20
     fe6:	5f 93       	push	r21
     fe8:	6f 93       	push	r22
     fea:	7f 93       	push	r23
     fec:	8f 93       	push	r24
     fee:	9f 93       	push	r25
     ff0:	af 93       	push	r26
     ff2:	bf 93       	push	r27
     ff4:	cf 93       	push	r28
     ff6:	df 93       	push	r29
     ff8:	ef 93       	push	r30
     ffa:	ff 93       	push	r31
     ffc:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
    1000:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1004:	0d b6       	in	r0, 0x3d	; 61
    1006:	0d 92       	st	X+, r0
    1008:	0e b6       	in	r0, 0x3e	; 62
    100a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    100c:	5b d4       	rcall	.+2230   	; 0x18c4 <xTaskIncrementTick>
    100e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1010:	0d d6       	rcall	.+3098   	; 0x1c2c <vTaskSwitchContext>
    1012:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
    1016:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    101a:	cd 91       	ld	r28, X+
    101c:	cd bf       	out	0x3d, r28	; 61
    101e:	dd 91       	ld	r29, X+
    1020:	de bf       	out	0x3e, r29	; 62
    1022:	ff 91       	pop	r31
    1024:	ef 91       	pop	r30
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	bf 91       	pop	r27
    102c:	af 91       	pop	r26
    102e:	9f 91       	pop	r25
    1030:	8f 91       	pop	r24
    1032:	7f 91       	pop	r23
    1034:	6f 91       	pop	r22
    1036:	5f 91       	pop	r21
    1038:	4f 91       	pop	r20
    103a:	3f 91       	pop	r19
    103c:	2f 91       	pop	r18
    103e:	1f 91       	pop	r17
    1040:	0f 91       	pop	r16
    1042:	ff 90       	pop	r15
    1044:	ef 90       	pop	r14
    1046:	df 90       	pop	r13
    1048:	cf 90       	pop	r12
    104a:	bf 90       	pop	r11
    104c:	af 90       	pop	r10
    104e:	9f 90       	pop	r9
    1050:	8f 90       	pop	r8
    1052:	7f 90       	pop	r7
    1054:	6f 90       	pop	r6
    1056:	5f 90       	pop	r5
    1058:	4f 90       	pop	r4
    105a:	3f 90       	pop	r3
    105c:	2f 90       	pop	r2
    105e:	1f 90       	pop	r1
    1060:	0f 90       	pop	r0
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	0f 90       	pop	r0
    1066:	08 95       	ret

00001068 <__vector_12>:

	asm volatile ( "ret" );
    1068:	a5 df       	rcall	.-182    	; 0xfb4 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    106a:	18 95       	reti

0000106c <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    106c:	1f 93       	push	r17
    106e:	cf 93       	push	r28
    1070:	df 93       	push	r29
    1072:	ec 01       	movw	r28, r24
    1074:	14 2f       	mov	r17, r20
    1076:	48 a1       	ldd	r20, Y+32	; 0x20
    1078:	41 11       	cpse	r20, r1
    107a:	0b c0       	rjmp	.+22     	; 0x1092 <prvCopyDataToQueue+0x26>
    107c:	88 81       	ld	r24, Y
    107e:	99 81       	ldd	r25, Y+1	; 0x01
    1080:	89 2b       	or	r24, r25
    1082:	09 f0       	breq	.+2      	; 0x1086 <prvCopyDataToQueue+0x1a>
    1084:	44 c0       	rjmp	.+136    	; 0x110e <__stack+0xf>
    1086:	8a 81       	ldd	r24, Y+2	; 0x02
    1088:	9b 81       	ldd	r25, Y+3	; 0x03
    108a:	d0 d7       	rcall	.+4000   	; 0x202c <xTaskPriorityDisinherit>
    108c:	1b 82       	std	Y+3, r1	; 0x03
    108e:	1a 82       	std	Y+2, r1	; 0x02
    1090:	45 c0       	rjmp	.+138    	; 0x111c <__stack+0x1d>
    1092:	11 11       	cpse	r17, r1
    1094:	17 c0       	rjmp	.+46     	; 0x10c4 <prvCopyDataToQueue+0x58>
    1096:	50 e0       	ldi	r21, 0x00	; 0
    1098:	8c 81       	ldd	r24, Y+4	; 0x04
    109a:	9d 81       	ldd	r25, Y+5	; 0x05
    109c:	0e 94 9a 1b 	call	0x3734	; 0x3734 <memcpy>
    10a0:	28 a1       	ldd	r18, Y+32	; 0x20
    10a2:	8c 81       	ldd	r24, Y+4	; 0x04
    10a4:	9d 81       	ldd	r25, Y+5	; 0x05
    10a6:	82 0f       	add	r24, r18
    10a8:	91 1d       	adc	r25, r1
    10aa:	9d 83       	std	Y+5, r25	; 0x05
    10ac:	8c 83       	std	Y+4, r24	; 0x04
    10ae:	2a 81       	ldd	r18, Y+2	; 0x02
    10b0:	3b 81       	ldd	r19, Y+3	; 0x03
    10b2:	82 17       	cp	r24, r18
    10b4:	93 07       	cpc	r25, r19
    10b6:	68 f1       	brcs	.+90     	; 0x1112 <__stack+0x13>
    10b8:	88 81       	ld	r24, Y
    10ba:	99 81       	ldd	r25, Y+1	; 0x01
    10bc:	9d 83       	std	Y+5, r25	; 0x05
    10be:	8c 83       	std	Y+4, r24	; 0x04
    10c0:	80 e0       	ldi	r24, 0x00	; 0
    10c2:	2c c0       	rjmp	.+88     	; 0x111c <__stack+0x1d>
    10c4:	50 e0       	ldi	r21, 0x00	; 0
    10c6:	8e 81       	ldd	r24, Y+6	; 0x06
    10c8:	9f 81       	ldd	r25, Y+7	; 0x07
    10ca:	0e 94 9a 1b 	call	0x3734	; 0x3734 <memcpy>
    10ce:	88 a1       	ldd	r24, Y+32	; 0x20
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	91 95       	neg	r25
    10d4:	81 95       	neg	r24
    10d6:	91 09       	sbc	r25, r1
    10d8:	2e 81       	ldd	r18, Y+6	; 0x06
    10da:	3f 81       	ldd	r19, Y+7	; 0x07
    10dc:	28 0f       	add	r18, r24
    10de:	39 1f       	adc	r19, r25
    10e0:	3f 83       	std	Y+7, r19	; 0x07
    10e2:	2e 83       	std	Y+6, r18	; 0x06
    10e4:	48 81       	ld	r20, Y
    10e6:	59 81       	ldd	r21, Y+1	; 0x01
    10e8:	24 17       	cp	r18, r20
    10ea:	35 07       	cpc	r19, r21
    10ec:	30 f4       	brcc	.+12     	; 0x10fa <prvCopyDataToQueue+0x8e>
    10ee:	2a 81       	ldd	r18, Y+2	; 0x02
    10f0:	3b 81       	ldd	r19, Y+3	; 0x03
    10f2:	82 0f       	add	r24, r18
    10f4:	93 1f       	adc	r25, r19
    10f6:	9f 83       	std	Y+7, r25	; 0x07
    10f8:	8e 83       	std	Y+6, r24	; 0x06
    10fa:	12 30       	cpi	r17, 0x02	; 2
    10fc:	61 f4       	brne	.+24     	; 0x1116 <__stack+0x17>
    10fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1100:	88 23       	and	r24, r24
    1102:	59 f0       	breq	.+22     	; 0x111a <__stack+0x1b>
    1104:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1106:	81 50       	subi	r24, 0x01	; 1
    1108:	8e 8f       	std	Y+30, r24	; 0x1e
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	07 c0       	rjmp	.+14     	; 0x111c <__stack+0x1d>
    110e:	80 e0       	ldi	r24, 0x00	; 0
    1110:	05 c0       	rjmp	.+10     	; 0x111c <__stack+0x1d>
    1112:	80 e0       	ldi	r24, 0x00	; 0
    1114:	03 c0       	rjmp	.+6      	; 0x111c <__stack+0x1d>
    1116:	80 e0       	ldi	r24, 0x00	; 0
    1118:	01 c0       	rjmp	.+2      	; 0x111c <__stack+0x1d>
    111a:	80 e0       	ldi	r24, 0x00	; 0
    111c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    111e:	9f 5f       	subi	r25, 0xFF	; 255
    1120:	9e 8f       	std	Y+30, r25	; 0x1e
    1122:	df 91       	pop	r29
    1124:	cf 91       	pop	r28
    1126:	1f 91       	pop	r17
    1128:	08 95       	ret

0000112a <prvCopyDataFromQueue>:
    112a:	fc 01       	movw	r30, r24
    112c:	40 a1       	ldd	r20, Z+32	; 0x20
    112e:	44 23       	and	r20, r20
    1130:	a9 f0       	breq	.+42     	; 0x115c <prvCopyDataFromQueue+0x32>
    1132:	50 e0       	ldi	r21, 0x00	; 0
    1134:	26 81       	ldd	r18, Z+6	; 0x06
    1136:	37 81       	ldd	r19, Z+7	; 0x07
    1138:	24 0f       	add	r18, r20
    113a:	35 1f       	adc	r19, r21
    113c:	37 83       	std	Z+7, r19	; 0x07
    113e:	26 83       	std	Z+6, r18	; 0x06
    1140:	82 81       	ldd	r24, Z+2	; 0x02
    1142:	93 81       	ldd	r25, Z+3	; 0x03
    1144:	28 17       	cp	r18, r24
    1146:	39 07       	cpc	r19, r25
    1148:	20 f0       	brcs	.+8      	; 0x1152 <prvCopyDataFromQueue+0x28>
    114a:	80 81       	ld	r24, Z
    114c:	91 81       	ldd	r25, Z+1	; 0x01
    114e:	97 83       	std	Z+7, r25	; 0x07
    1150:	86 83       	std	Z+6, r24	; 0x06
    1152:	cb 01       	movw	r24, r22
    1154:	66 81       	ldd	r22, Z+6	; 0x06
    1156:	77 81       	ldd	r23, Z+7	; 0x07
    1158:	0c 94 9a 1b 	jmp	0x3734	; 0x3734 <memcpy>
    115c:	08 95       	ret

0000115e <prvUnlockQueue>:
    115e:	0f 93       	push	r16
    1160:	1f 93       	push	r17
    1162:	cf 93       	push	r28
    1164:	df 93       	push	r29
    1166:	ec 01       	movw	r28, r24
    1168:	0f b6       	in	r0, 0x3f	; 63
    116a:	f8 94       	cli
    116c:	0f 92       	push	r0
    116e:	8a a1       	ldd	r24, Y+34	; 0x22
    1170:	18 16       	cp	r1, r24
    1172:	ac f4       	brge	.+42     	; 0x119e <prvUnlockQueue+0x40>
    1174:	8b 89       	ldd	r24, Y+19	; 0x13
    1176:	81 11       	cpse	r24, r1
    1178:	05 c0       	rjmp	.+10     	; 0x1184 <prvUnlockQueue+0x26>
    117a:	11 c0       	rjmp	.+34     	; 0x119e <prvUnlockQueue+0x40>
    117c:	8b 89       	ldd	r24, Y+19	; 0x13
    117e:	81 11       	cpse	r24, r1
    1180:	04 c0       	rjmp	.+8      	; 0x118a <prvUnlockQueue+0x2c>
    1182:	0d c0       	rjmp	.+26     	; 0x119e <prvUnlockQueue+0x40>
    1184:	8e 01       	movw	r16, r28
    1186:	0d 5e       	subi	r16, 0xED	; 237
    1188:	1f 4f       	sbci	r17, 0xFF	; 255
    118a:	c8 01       	movw	r24, r16
    118c:	0a d6       	rcall	.+3092   	; 0x1da2 <xTaskRemoveFromEventList>
    118e:	81 11       	cpse	r24, r1
    1190:	eb d6       	rcall	.+3542   	; 0x1f68 <vTaskMissedYield>
    1192:	8a a1       	ldd	r24, Y+34	; 0x22
    1194:	81 50       	subi	r24, 0x01	; 1
    1196:	8a a3       	std	Y+34, r24	; 0x22
    1198:	8a a1       	ldd	r24, Y+34	; 0x22
    119a:	18 16       	cp	r1, r24
    119c:	7c f3       	brlt	.-34     	; 0x117c <prvUnlockQueue+0x1e>
    119e:	8f ef       	ldi	r24, 0xFF	; 255
    11a0:	8a a3       	std	Y+34, r24	; 0x22
    11a2:	0f 90       	pop	r0
    11a4:	0f be       	out	0x3f, r0	; 63
    11a6:	0f b6       	in	r0, 0x3f	; 63
    11a8:	f8 94       	cli
    11aa:	0f 92       	push	r0
    11ac:	89 a1       	ldd	r24, Y+33	; 0x21
    11ae:	18 16       	cp	r1, r24
    11b0:	ac f4       	brge	.+42     	; 0x11dc <prvUnlockQueue+0x7e>
    11b2:	88 85       	ldd	r24, Y+8	; 0x08
    11b4:	81 11       	cpse	r24, r1
    11b6:	05 c0       	rjmp	.+10     	; 0x11c2 <prvUnlockQueue+0x64>
    11b8:	11 c0       	rjmp	.+34     	; 0x11dc <prvUnlockQueue+0x7e>
    11ba:	88 85       	ldd	r24, Y+8	; 0x08
    11bc:	81 11       	cpse	r24, r1
    11be:	04 c0       	rjmp	.+8      	; 0x11c8 <prvUnlockQueue+0x6a>
    11c0:	0d c0       	rjmp	.+26     	; 0x11dc <prvUnlockQueue+0x7e>
    11c2:	8e 01       	movw	r16, r28
    11c4:	08 5f       	subi	r16, 0xF8	; 248
    11c6:	1f 4f       	sbci	r17, 0xFF	; 255
    11c8:	c8 01       	movw	r24, r16
    11ca:	eb d5       	rcall	.+3030   	; 0x1da2 <xTaskRemoveFromEventList>
    11cc:	81 11       	cpse	r24, r1
    11ce:	cc d6       	rcall	.+3480   	; 0x1f68 <vTaskMissedYield>
    11d0:	89 a1       	ldd	r24, Y+33	; 0x21
    11d2:	81 50       	subi	r24, 0x01	; 1
    11d4:	89 a3       	std	Y+33, r24	; 0x21
    11d6:	89 a1       	ldd	r24, Y+33	; 0x21
    11d8:	18 16       	cp	r1, r24
    11da:	7c f3       	brlt	.-34     	; 0x11ba <prvUnlockQueue+0x5c>
    11dc:	8f ef       	ldi	r24, 0xFF	; 255
    11de:	89 a3       	std	Y+33, r24	; 0x21
    11e0:	0f 90       	pop	r0
    11e2:	0f be       	out	0x3f, r0	; 63
    11e4:	df 91       	pop	r29
    11e6:	cf 91       	pop	r28
    11e8:	1f 91       	pop	r17
    11ea:	0f 91       	pop	r16
    11ec:	08 95       	ret

000011ee <xQueueGenericReset>:
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	ec 01       	movw	r28, r24
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	f8 94       	cli
    11f8:	0f 92       	push	r0
    11fa:	48 81       	ld	r20, Y
    11fc:	59 81       	ldd	r21, Y+1	; 0x01
    11fe:	28 a1       	ldd	r18, Y+32	; 0x20
    1200:	30 e0       	ldi	r19, 0x00	; 0
    1202:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1204:	72 9f       	mul	r23, r18
    1206:	c0 01       	movw	r24, r0
    1208:	73 9f       	mul	r23, r19
    120a:	90 0d       	add	r25, r0
    120c:	11 24       	eor	r1, r1
    120e:	fa 01       	movw	r30, r20
    1210:	e8 0f       	add	r30, r24
    1212:	f9 1f       	adc	r31, r25
    1214:	fb 83       	std	Y+3, r31	; 0x03
    1216:	ea 83       	std	Y+2, r30	; 0x02
    1218:	1e 8e       	std	Y+30, r1	; 0x1e
    121a:	5d 83       	std	Y+5, r21	; 0x05
    121c:	4c 83       	std	Y+4, r20	; 0x04
    121e:	82 1b       	sub	r24, r18
    1220:	93 0b       	sbc	r25, r19
    1222:	84 0f       	add	r24, r20
    1224:	95 1f       	adc	r25, r21
    1226:	9f 83       	std	Y+7, r25	; 0x07
    1228:	8e 83       	std	Y+6, r24	; 0x06
    122a:	8f ef       	ldi	r24, 0xFF	; 255
    122c:	89 a3       	std	Y+33, r24	; 0x21
    122e:	8a a3       	std	Y+34, r24	; 0x22
    1230:	61 11       	cpse	r22, r1
    1232:	0a c0       	rjmp	.+20     	; 0x1248 <xQueueGenericReset+0x5a>
    1234:	88 85       	ldd	r24, Y+8	; 0x08
    1236:	88 23       	and	r24, r24
    1238:	69 f0       	breq	.+26     	; 0x1254 <xQueueGenericReset+0x66>
    123a:	ce 01       	movw	r24, r28
    123c:	08 96       	adiw	r24, 0x08	; 8
    123e:	b1 d5       	rcall	.+2914   	; 0x1da2 <xTaskRemoveFromEventList>
    1240:	81 30       	cpi	r24, 0x01	; 1
    1242:	41 f4       	brne	.+16     	; 0x1254 <xQueueGenericReset+0x66>
    1244:	5f de       	rcall	.-834    	; 0xf04 <vPortYield>
    1246:	06 c0       	rjmp	.+12     	; 0x1254 <xQueueGenericReset+0x66>
    1248:	ce 01       	movw	r24, r28
    124a:	08 96       	adiw	r24, 0x08	; 8
    124c:	21 dd       	rcall	.-1470   	; 0xc90 <vListInitialise>
    124e:	ce 01       	movw	r24, r28
    1250:	43 96       	adiw	r24, 0x13	; 19
    1252:	1e dd       	rcall	.-1476   	; 0xc90 <vListInitialise>
    1254:	0f 90       	pop	r0
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	df 91       	pop	r29
    125c:	cf 91       	pop	r28
    125e:	08 95       	ret

00001260 <xQueueGenericCreate>:
    1260:	0f 93       	push	r16
    1262:	1f 93       	push	r17
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	88 23       	and	r24, r24
    126a:	e1 f0       	breq	.+56     	; 0x12a4 <xQueueGenericCreate+0x44>
    126c:	06 2f       	mov	r16, r22
    126e:	18 2f       	mov	r17, r24
    1270:	83 e2       	ldi	r24, 0x23	; 35
    1272:	90 e0       	ldi	r25, 0x00	; 0
    1274:	d9 dc       	rcall	.-1614   	; 0xc28 <pvPortMalloc>
    1276:	ec 01       	movw	r28, r24
    1278:	89 2b       	or	r24, r25
    127a:	b1 f0       	breq	.+44     	; 0x12a8 <xQueueGenericCreate+0x48>
    127c:	10 9f       	mul	r17, r16
    127e:	c0 01       	movw	r24, r0
    1280:	11 24       	eor	r1, r1
    1282:	01 96       	adiw	r24, 0x01	; 1
    1284:	d1 dc       	rcall	.-1630   	; 0xc28 <pvPortMalloc>
    1286:	99 83       	std	Y+1, r25	; 0x01
    1288:	88 83       	st	Y, r24
    128a:	89 2b       	or	r24, r25
    128c:	31 f0       	breq	.+12     	; 0x129a <xQueueGenericCreate+0x3a>
    128e:	1f 8f       	std	Y+31, r17	; 0x1f
    1290:	08 a3       	std	Y+32, r16	; 0x20
    1292:	61 e0       	ldi	r22, 0x01	; 1
    1294:	ce 01       	movw	r24, r28
    1296:	ab df       	rcall	.-170    	; 0x11ee <xQueueGenericReset>
    1298:	07 c0       	rjmp	.+14     	; 0x12a8 <xQueueGenericCreate+0x48>
    129a:	ce 01       	movw	r24, r28
    129c:	f8 dc       	rcall	.-1552   	; 0xc8e <vPortFree>
    129e:	c0 e0       	ldi	r28, 0x00	; 0
    12a0:	d0 e0       	ldi	r29, 0x00	; 0
    12a2:	02 c0       	rjmp	.+4      	; 0x12a8 <xQueueGenericCreate+0x48>
    12a4:	c0 e0       	ldi	r28, 0x00	; 0
    12a6:	d0 e0       	ldi	r29, 0x00	; 0
    12a8:	ce 01       	movw	r24, r28
    12aa:	df 91       	pop	r29
    12ac:	cf 91       	pop	r28
    12ae:	1f 91       	pop	r17
    12b0:	0f 91       	pop	r16
    12b2:	08 95       	ret

000012b4 <xQueueGenericSend>:
    12b4:	9f 92       	push	r9
    12b6:	af 92       	push	r10
    12b8:	bf 92       	push	r11
    12ba:	cf 92       	push	r12
    12bc:	df 92       	push	r13
    12be:	ef 92       	push	r14
    12c0:	ff 92       	push	r15
    12c2:	0f 93       	push	r16
    12c4:	1f 93       	push	r17
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
    12ca:	cd b7       	in	r28, 0x3d	; 61
    12cc:	de b7       	in	r29, 0x3e	; 62
    12ce:	29 97       	sbiw	r28, 0x09	; 9
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	7c 01       	movw	r14, r24
    12dc:	5b 01       	movw	r10, r22
    12de:	2e 83       	std	Y+6, r18	; 0x06
    12e0:	3f 83       	std	Y+7, r19	; 0x07
    12e2:	48 87       	std	Y+8, r20	; 0x08
    12e4:	59 87       	std	Y+9, r21	; 0x09
    12e6:	10 e0       	ldi	r17, 0x00	; 0
    12e8:	99 24       	eor	r9, r9
    12ea:	93 94       	inc	r9
    12ec:	6c 01       	movw	r12, r24
    12ee:	88 e0       	ldi	r24, 0x08	; 8
    12f0:	c8 0e       	add	r12, r24
    12f2:	d1 1c       	adc	r13, r1
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	0f 92       	push	r0
    12fa:	f7 01       	movw	r30, r14
    12fc:	96 8d       	ldd	r25, Z+30	; 0x1e
    12fe:	87 8d       	ldd	r24, Z+31	; 0x1f
    1300:	98 17       	cp	r25, r24
    1302:	10 f0       	brcs	.+4      	; 0x1308 <xQueueGenericSend+0x54>
    1304:	02 30       	cpi	r16, 0x02	; 2
    1306:	a9 f4       	brne	.+42     	; 0x1332 <xQueueGenericSend+0x7e>
    1308:	40 2f       	mov	r20, r16
    130a:	b5 01       	movw	r22, r10
    130c:	c7 01       	movw	r24, r14
    130e:	ae de       	rcall	.-676    	; 0x106c <prvCopyDataToQueue>
    1310:	f7 01       	movw	r30, r14
    1312:	93 89       	ldd	r25, Z+19	; 0x13
    1314:	99 23       	and	r25, r25
    1316:	39 f0       	breq	.+14     	; 0x1326 <xQueueGenericSend+0x72>
    1318:	c7 01       	movw	r24, r14
    131a:	43 96       	adiw	r24, 0x13	; 19
    131c:	42 d5       	rcall	.+2692   	; 0x1da2 <xTaskRemoveFromEventList>
    131e:	81 30       	cpi	r24, 0x01	; 1
    1320:	21 f4       	brne	.+8      	; 0x132a <xQueueGenericSend+0x76>
    1322:	f0 dd       	rcall	.-1056   	; 0xf04 <vPortYield>
    1324:	02 c0       	rjmp	.+4      	; 0x132a <xQueueGenericSend+0x76>
    1326:	81 11       	cpse	r24, r1
    1328:	ed dd       	rcall	.-1062   	; 0xf04 <vPortYield>
    132a:	0f 90       	pop	r0
    132c:	0f be       	out	0x3f, r0	; 63
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	4b c0       	rjmp	.+150    	; 0x13c8 <xQueueGenericSend+0x114>
    1332:	8e 81       	ldd	r24, Y+6	; 0x06
    1334:	9f 81       	ldd	r25, Y+7	; 0x07
    1336:	a8 85       	ldd	r26, Y+8	; 0x08
    1338:	b9 85       	ldd	r27, Y+9	; 0x09
    133a:	89 2b       	or	r24, r25
    133c:	8a 2b       	or	r24, r26
    133e:	8b 2b       	or	r24, r27
    1340:	21 f4       	brne	.+8      	; 0x134a <xQueueGenericSend+0x96>
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63
    1346:	80 e0       	ldi	r24, 0x00	; 0
    1348:	3f c0       	rjmp	.+126    	; 0x13c8 <xQueueGenericSend+0x114>
    134a:	11 11       	cpse	r17, r1
    134c:	04 c0       	rjmp	.+8      	; 0x1356 <xQueueGenericSend+0xa2>
    134e:	ce 01       	movw	r24, r28
    1350:	01 96       	adiw	r24, 0x01	; 1
    1352:	9f d5       	rcall	.+2878   	; 0x1e92 <vTaskSetTimeOutState>
    1354:	19 2d       	mov	r17, r9
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	ae d2       	rcall	.+1372   	; 0x18b8 <vTaskSuspendAll>
    135c:	0f b6       	in	r0, 0x3f	; 63
    135e:	f8 94       	cli
    1360:	0f 92       	push	r0
    1362:	f7 01       	movw	r30, r14
    1364:	81 a1       	ldd	r24, Z+33	; 0x21
    1366:	8f 3f       	cpi	r24, 0xFF	; 255
    1368:	09 f4       	brne	.+2      	; 0x136c <xQueueGenericSend+0xb8>
    136a:	11 a2       	std	Z+33, r1	; 0x21
    136c:	f7 01       	movw	r30, r14
    136e:	82 a1       	ldd	r24, Z+34	; 0x22
    1370:	8f 3f       	cpi	r24, 0xFF	; 255
    1372:	09 f4       	brne	.+2      	; 0x1376 <xQueueGenericSend+0xc2>
    1374:	12 a2       	std	Z+34, r1	; 0x22
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	be 01       	movw	r22, r28
    137c:	6a 5f       	subi	r22, 0xFA	; 250
    137e:	7f 4f       	sbci	r23, 0xFF	; 255
    1380:	ce 01       	movw	r24, r28
    1382:	01 96       	adiw	r24, 0x01	; 1
    1384:	97 d5       	rcall	.+2862   	; 0x1eb4 <xTaskCheckForTimeOut>
    1386:	81 11       	cpse	r24, r1
    1388:	1b c0       	rjmp	.+54     	; 0x13c0 <xQueueGenericSend+0x10c>
    138a:	0f b6       	in	r0, 0x3f	; 63
    138c:	f8 94       	cli
    138e:	0f 92       	push	r0
    1390:	f7 01       	movw	r30, r14
    1392:	96 8d       	ldd	r25, Z+30	; 0x1e
    1394:	0f 90       	pop	r0
    1396:	0f be       	out	0x3f, r0	; 63
    1398:	87 8d       	ldd	r24, Z+31	; 0x1f
    139a:	98 13       	cpse	r25, r24
    139c:	0d c0       	rjmp	.+26     	; 0x13b8 <xQueueGenericSend+0x104>
    139e:	4e 81       	ldd	r20, Y+6	; 0x06
    13a0:	5f 81       	ldd	r21, Y+7	; 0x07
    13a2:	68 85       	ldd	r22, Y+8	; 0x08
    13a4:	79 85       	ldd	r23, Y+9	; 0x09
    13a6:	c6 01       	movw	r24, r12
    13a8:	9f d4       	rcall	.+2366   	; 0x1ce8 <vTaskPlaceOnEventList>
    13aa:	c7 01       	movw	r24, r14
    13ac:	d8 de       	rcall	.-592    	; 0x115e <prvUnlockQueue>
    13ae:	62 d3       	rcall	.+1732   	; 0x1a74 <xTaskResumeAll>
    13b0:	81 11       	cpse	r24, r1
    13b2:	a0 cf       	rjmp	.-192    	; 0x12f4 <xQueueGenericSend+0x40>
    13b4:	a7 dd       	rcall	.-1202   	; 0xf04 <vPortYield>
    13b6:	9e cf       	rjmp	.-196    	; 0x12f4 <xQueueGenericSend+0x40>
    13b8:	c7 01       	movw	r24, r14
    13ba:	d1 de       	rcall	.-606    	; 0x115e <prvUnlockQueue>
    13bc:	5b d3       	rcall	.+1718   	; 0x1a74 <xTaskResumeAll>
    13be:	9a cf       	rjmp	.-204    	; 0x12f4 <xQueueGenericSend+0x40>
    13c0:	c7 01       	movw	r24, r14
    13c2:	cd de       	rcall	.-614    	; 0x115e <prvUnlockQueue>
    13c4:	57 d3       	rcall	.+1710   	; 0x1a74 <xTaskResumeAll>
    13c6:	80 e0       	ldi	r24, 0x00	; 0
    13c8:	29 96       	adiw	r28, 0x09	; 9
    13ca:	0f b6       	in	r0, 0x3f	; 63
    13cc:	f8 94       	cli
    13ce:	de bf       	out	0x3e, r29	; 62
    13d0:	0f be       	out	0x3f, r0	; 63
    13d2:	cd bf       	out	0x3d, r28	; 61
    13d4:	df 91       	pop	r29
    13d6:	cf 91       	pop	r28
    13d8:	1f 91       	pop	r17
    13da:	0f 91       	pop	r16
    13dc:	ff 90       	pop	r15
    13de:	ef 90       	pop	r14
    13e0:	df 90       	pop	r13
    13e2:	cf 90       	pop	r12
    13e4:	bf 90       	pop	r11
    13e6:	af 90       	pop	r10
    13e8:	9f 90       	pop	r9
    13ea:	08 95       	ret

000013ec <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    13ec:	9f 92       	push	r9
    13ee:	af 92       	push	r10
    13f0:	bf 92       	push	r11
    13f2:	cf 92       	push	r12
    13f4:	df 92       	push	r13
    13f6:	ef 92       	push	r14
    13f8:	ff 92       	push	r15
    13fa:	0f 93       	push	r16
    13fc:	1f 93       	push	r17
    13fe:	cf 93       	push	r28
    1400:	df 93       	push	r29
    1402:	cd b7       	in	r28, 0x3d	; 61
    1404:	de b7       	in	r29, 0x3e	; 62
    1406:	29 97       	sbiw	r28, 0x09	; 9
    1408:	0f b6       	in	r0, 0x3f	; 63
    140a:	f8 94       	cli
    140c:	de bf       	out	0x3e, r29	; 62
    140e:	0f be       	out	0x3f, r0	; 63
    1410:	cd bf       	out	0x3d, r28	; 61
    1412:	7c 01       	movw	r14, r24
    1414:	5b 01       	movw	r10, r22
    1416:	2e 83       	std	Y+6, r18	; 0x06
    1418:	3f 83       	std	Y+7, r19	; 0x07
    141a:	48 87       	std	Y+8, r20	; 0x08
    141c:	59 87       	std	Y+9, r21	; 0x09
BaseType_t xEntryTimeSet = pdFALSE;
    141e:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1420:	99 24       	eor	r9, r9
    1422:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1424:	6c 01       	movw	r12, r24
    1426:	83 e1       	ldi	r24, 0x13	; 19
    1428:	c8 0e       	add	r12, r24
    142a:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1432:	f7 01       	movw	r30, r14
    1434:	86 8d       	ldd	r24, Z+30	; 0x1e
    1436:	88 23       	and	r24, r24
    1438:	69 f1       	breq	.+90     	; 0x1494 <xQueueGenericReceive+0xa8>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    143a:	c6 80       	ldd	r12, Z+6	; 0x06
    143c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    143e:	b5 01       	movw	r22, r10
    1440:	c7 01       	movw	r24, r14
    1442:	73 de       	rcall	.-794    	; 0x112a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1444:	01 11       	cpse	r16, r1
    1446:	17 c0       	rjmp	.+46     	; 0x1476 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1448:	f7 01       	movw	r30, r14
    144a:	86 8d       	ldd	r24, Z+30	; 0x1e
    144c:	81 50       	subi	r24, 0x01	; 1
    144e:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1450:	80 81       	ld	r24, Z
    1452:	91 81       	ldd	r25, Z+1	; 0x01
    1454:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1456:	21 f4       	brne	.+8      	; 0x1460 <xQueueGenericReceive+0x74>
    1458:	53 d6       	rcall	.+3238   	; 0x2100 <pvTaskIncrementMutexHeldCount>
    145a:	f7 01       	movw	r30, r14
    145c:	93 83       	std	Z+3, r25	; 0x03
    145e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1460:	f7 01       	movw	r30, r14
    1462:	80 85       	ldd	r24, Z+8	; 0x08
    1464:	88 23       	and	r24, r24
    1466:	91 f0       	breq	.+36     	; 0x148c <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1468:	c7 01       	movw	r24, r14
    146a:	08 96       	adiw	r24, 0x08	; 8
    146c:	9a d4       	rcall	.+2356   	; 0x1da2 <xTaskRemoveFromEventList>
    146e:	81 30       	cpi	r24, 0x01	; 1
						{
							queueYIELD_IF_USING_PREEMPTION();
    1470:	69 f4       	brne	.+26     	; 0x148c <xQueueGenericReceive+0xa0>
    1472:	48 dd       	rcall	.-1392   	; 0xf04 <vPortYield>
    1474:	0b c0       	rjmp	.+22     	; 0x148c <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1476:	f7 01       	movw	r30, r14
    1478:	d7 82       	std	Z+7, r13	; 0x07
    147a:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    147c:	83 89       	ldd	r24, Z+19	; 0x13
    147e:	88 23       	and	r24, r24
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1480:	29 f0       	breq	.+10     	; 0x148c <xQueueGenericReceive+0xa0>
    1482:	c7 01       	movw	r24, r14
    1484:	43 96       	adiw	r24, 0x13	; 19
    1486:	8d d4       	rcall	.+2330   	; 0x1da2 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1488:	81 11       	cpse	r24, r1
    148a:	3c dd       	rcall	.-1416   	; 0xf04 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    148c:	0f 90       	pop	r0
    148e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1490:	81 e0       	ldi	r24, 0x01	; 1
    1492:	56 c0       	rjmp	.+172    	; 0x1540 <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1494:	8e 81       	ldd	r24, Y+6	; 0x06
    1496:	9f 81       	ldd	r25, Y+7	; 0x07
    1498:	a8 85       	ldd	r26, Y+8	; 0x08
    149a:	b9 85       	ldd	r27, Y+9	; 0x09
    149c:	89 2b       	or	r24, r25
    149e:	8a 2b       	or	r24, r26
    14a0:	8b 2b       	or	r24, r27
    14a2:	21 f4       	brne	.+8      	; 0x14ac <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14a4:	0f 90       	pop	r0
    14a6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    14a8:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
    14aa:	4a c0       	rjmp	.+148    	; 0x1540 <xQueueGenericReceive+0x154>
    14ac:	11 11       	cpse	r17, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14ae:	04 c0       	rjmp	.+8      	; 0x14b8 <xQueueGenericReceive+0xcc>
    14b0:	ce 01       	movw	r24, r28
    14b2:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    14b4:	ee d4       	rcall	.+2524   	; 0x1e92 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    14b6:	19 2d       	mov	r17, r9
    14b8:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14ba:	0f be       	out	0x3f, r0	; 63
    14bc:	fd d1       	rcall	.+1018   	; 0x18b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14be:	0f b6       	in	r0, 0x3f	; 63
    14c0:	f8 94       	cli
    14c2:	0f 92       	push	r0
    14c4:	f7 01       	movw	r30, r14
    14c6:	81 a1       	ldd	r24, Z+33	; 0x21
    14c8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ca:	09 f4       	brne	.+2      	; 0x14ce <xQueueGenericReceive+0xe2>
    14cc:	11 a2       	std	Z+33, r1	; 0x21
    14ce:	f7 01       	movw	r30, r14
    14d0:	82 a1       	ldd	r24, Z+34	; 0x22
    14d2:	8f 3f       	cpi	r24, 0xFF	; 255
    14d4:	09 f4       	brne	.+2      	; 0x14d8 <xQueueGenericReceive+0xec>
    14d6:	12 a2       	std	Z+34, r1	; 0x22
    14d8:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14da:	0f be       	out	0x3f, r0	; 63
    14dc:	be 01       	movw	r22, r28
    14de:	6a 5f       	subi	r22, 0xFA	; 250
    14e0:	7f 4f       	sbci	r23, 0xFF	; 255
    14e2:	ce 01       	movw	r24, r28
    14e4:	01 96       	adiw	r24, 0x01	; 1
    14e6:	e6 d4       	rcall	.+2508   	; 0x1eb4 <xTaskCheckForTimeOut>
    14e8:	81 11       	cpse	r24, r1
    14ea:	26 c0       	rjmp	.+76     	; 0x1538 <xQueueGenericReceive+0x14c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14ec:	0f b6       	in	r0, 0x3f	; 63
    14ee:	f8 94       	cli
    14f0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    14f2:	f7 01       	movw	r30, r14
    14f4:	86 8d       	ldd	r24, Z+30	; 0x1e
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14f6:	0f 90       	pop	r0
    14f8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    14fa:	81 11       	cpse	r24, r1
    14fc:	19 c0       	rjmp	.+50     	; 0x1530 <xQueueGenericReceive+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14fe:	80 81       	ld	r24, Z
    1500:	91 81       	ldd	r25, Z+1	; 0x01
    1502:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
    1504:	41 f4       	brne	.+16     	; 0x1516 <xQueueGenericReceive+0x12a>
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    150a:	0f 92       	push	r0
    150c:	82 81       	ldd	r24, Z+2	; 0x02
    150e:	93 81       	ldd	r25, Z+3	; 0x03
						}
						taskEXIT_CRITICAL();
    1510:	2f d5       	rcall	.+2654   	; 0x1f70 <vTaskPriorityInherit>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1512:	0f 90       	pop	r0
    1514:	0f be       	out	0x3f, r0	; 63
    1516:	4e 81       	ldd	r20, Y+6	; 0x06
    1518:	5f 81       	ldd	r21, Y+7	; 0x07
    151a:	68 85       	ldd	r22, Y+8	; 0x08
				prvUnlockQueue( pxQueue );
    151c:	79 85       	ldd	r23, Y+9	; 0x09
    151e:	c6 01       	movw	r24, r12
				if( xTaskResumeAll() == pdFALSE )
    1520:	e3 d3       	rcall	.+1990   	; 0x1ce8 <vTaskPlaceOnEventList>
    1522:	c7 01       	movw	r24, r14
    1524:	1c de       	rcall	.-968    	; 0x115e <prvUnlockQueue>
    1526:	a6 d2       	rcall	.+1356   	; 0x1a74 <xTaskResumeAll>
				{
					portYIELD_WITHIN_API();
    1528:	81 11       	cpse	r24, r1
    152a:	80 cf       	rjmp	.-256    	; 0x142c <xQueueGenericReceive+0x40>
    152c:	eb dc       	rcall	.-1578   	; 0xf04 <vPortYield>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    152e:	7e cf       	rjmp	.-260    	; 0x142c <xQueueGenericReceive+0x40>
    1530:	c7 01       	movw	r24, r14
    1532:	15 de       	rcall	.-982    	; 0x115e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1534:	9f d2       	rcall	.+1342   	; 0x1a74 <xTaskResumeAll>
    1536:	7a cf       	rjmp	.-268    	; 0x142c <xQueueGenericReceive+0x40>
    1538:	c7 01       	movw	r24, r14
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    153a:	11 de       	rcall	.-990    	; 0x115e <prvUnlockQueue>
    153c:	9b d2       	rcall	.+1334   	; 0x1a74 <xTaskResumeAll>
    153e:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
    1540:	29 96       	adiw	r28, 0x09	; 9
    1542:	0f b6       	in	r0, 0x3f	; 63
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1544:	f8 94       	cli
		}
	}
}
    1546:	de bf       	out	0x3e, r29	; 62
    1548:	0f be       	out	0x3f, r0	; 63
    154a:	cd bf       	out	0x3d, r28	; 61
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	1f 91       	pop	r17
    1552:	0f 91       	pop	r16
    1554:	ff 90       	pop	r15
    1556:	ef 90       	pop	r14
    1558:	df 90       	pop	r13
    155a:	cf 90       	pop	r12
    155c:	bf 90       	pop	r11
    155e:	af 90       	pop	r10
    1560:	9f 90       	pop	r9
    1562:	08 95       	ret

00001564 <prvResetNextTaskUnblockTime>:
    1564:	e0 91 f9 0e 	lds	r30, 0x0EF9	; 0x800ef9 <pxDelayedTaskList>
    1568:	f0 91 fa 0e 	lds	r31, 0x0EFA	; 0x800efa <pxDelayedTaskList+0x1>
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    156c:	80 81       	ld	r24, Z
    156e:	81 11       	cpse	r24, r1
    1570:	0c c0       	rjmp	.+24     	; 0x158a <prvResetNextTaskUnblockTime+0x26>
    1572:	8f ef       	ldi	r24, 0xFF	; 255
    1574:	9f ef       	ldi	r25, 0xFF	; 255
    1576:	dc 01       	movw	r26, r24
    1578:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
    157c:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
    1580:	a0 93 0e 01 	sts	0x010E, r26	; 0x80010e <xNextTaskUnblockTime+0x2>
    1584:	b0 93 0f 01 	sts	0x010F, r27	; 0x80010f <xNextTaskUnblockTime+0x3>
    1588:	08 95       	ret
    158a:	e0 91 f9 0e 	lds	r30, 0x0EF9	; 0x800ef9 <pxDelayedTaskList>
    158e:	f0 91 fa 0e 	lds	r31, 0x0EFA	; 0x800efa <pxDelayedTaskList+0x1>
    1592:	07 80       	ldd	r0, Z+7	; 0x07
    1594:	f0 85       	ldd	r31, Z+8	; 0x08
    1596:	e0 2d       	mov	r30, r0
    1598:	00 84       	ldd	r0, Z+8	; 0x08
    159a:	f1 85       	ldd	r31, Z+9	; 0x09
    159c:	e0 2d       	mov	r30, r0
    159e:	82 81       	ldd	r24, Z+2	; 0x02
    15a0:	93 81       	ldd	r25, Z+3	; 0x03
    15a2:	a4 81       	ldd	r26, Z+4	; 0x04
    15a4:	b5 81       	ldd	r27, Z+5	; 0x05
    15a6:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
    15aa:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
    15ae:	a0 93 0e 01 	sts	0x010E, r26	; 0x80010e <xNextTaskUnblockTime+0x2>
    15b2:	b0 93 0f 01 	sts	0x010F, r27	; 0x80010f <xNextTaskUnblockTime+0x3>
    15b6:	08 95       	ret

000015b8 <prvAddCurrentTaskToDelayedList>:
    15b8:	cf 92       	push	r12
    15ba:	df 92       	push	r13
    15bc:	ef 92       	push	r14
    15be:	ff 92       	push	r15
    15c0:	6b 01       	movw	r12, r22
    15c2:	7c 01       	movw	r14, r24
    15c4:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    15c8:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    15cc:	62 83       	std	Z+2, r22	; 0x02
    15ce:	73 83       	std	Z+3, r23	; 0x03
    15d0:	84 83       	std	Z+4, r24	; 0x04
    15d2:	95 83       	std	Z+5, r25	; 0x05
    15d4:	80 91 db 0e 	lds	r24, 0x0EDB	; 0x800edb <xTickCount>
    15d8:	90 91 dc 0e 	lds	r25, 0x0EDC	; 0x800edc <xTickCount+0x1>
    15dc:	a0 91 dd 0e 	lds	r26, 0x0EDD	; 0x800edd <xTickCount+0x2>
    15e0:	b0 91 de 0e 	lds	r27, 0x0EDE	; 0x800ede <xTickCount+0x3>
    15e4:	c8 16       	cp	r12, r24
    15e6:	d9 06       	cpc	r13, r25
    15e8:	ea 06       	cpc	r14, r26
    15ea:	fb 06       	cpc	r15, r27
    15ec:	60 f4       	brcc	.+24     	; 0x1606 <prvAddCurrentTaskToDelayedList+0x4e>
    15ee:	60 91 ed 0f 	lds	r22, 0x0FED	; 0x800fed <pxCurrentTCB>
    15f2:	70 91 ee 0f 	lds	r23, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    15f6:	80 91 f7 0e 	lds	r24, 0x0EF7	; 0x800ef7 <pxOverflowDelayedTaskList>
    15fa:	90 91 f8 0e 	lds	r25, 0x0EF8	; 0x800ef8 <pxOverflowDelayedTaskList+0x1>
    15fe:	6e 5f       	subi	r22, 0xFE	; 254
    1600:	7f 4f       	sbci	r23, 0xFF	; 255
    1602:	7c db       	rcall	.-2312   	; 0xcfc <vListInsert>
    1604:	20 c0       	rjmp	.+64     	; 0x1646 <prvAddCurrentTaskToDelayedList+0x8e>
    1606:	60 91 ed 0f 	lds	r22, 0x0FED	; 0x800fed <pxCurrentTCB>
    160a:	70 91 ee 0f 	lds	r23, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    160e:	80 91 f9 0e 	lds	r24, 0x0EF9	; 0x800ef9 <pxDelayedTaskList>
    1612:	90 91 fa 0e 	lds	r25, 0x0EFA	; 0x800efa <pxDelayedTaskList+0x1>
    1616:	6e 5f       	subi	r22, 0xFE	; 254
    1618:	7f 4f       	sbci	r23, 0xFF	; 255
    161a:	70 db       	rcall	.-2336   	; 0xcfc <vListInsert>
    161c:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xNextTaskUnblockTime>
    1620:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xNextTaskUnblockTime+0x1>
    1624:	a0 91 0e 01 	lds	r26, 0x010E	; 0x80010e <xNextTaskUnblockTime+0x2>
    1628:	b0 91 0f 01 	lds	r27, 0x010F	; 0x80010f <xNextTaskUnblockTime+0x3>
    162c:	c8 16       	cp	r12, r24
    162e:	d9 06       	cpc	r13, r25
    1630:	ea 06       	cpc	r14, r26
    1632:	fb 06       	cpc	r15, r27
    1634:	40 f4       	brcc	.+16     	; 0x1646 <prvAddCurrentTaskToDelayedList+0x8e>
    1636:	c0 92 0c 01 	sts	0x010C, r12	; 0x80010c <xNextTaskUnblockTime>
    163a:	d0 92 0d 01 	sts	0x010D, r13	; 0x80010d <xNextTaskUnblockTime+0x1>
    163e:	e0 92 0e 01 	sts	0x010E, r14	; 0x80010e <xNextTaskUnblockTime+0x2>
    1642:	f0 92 0f 01 	sts	0x010F, r15	; 0x80010f <xNextTaskUnblockTime+0x3>
    1646:	ff 90       	pop	r15
    1648:	ef 90       	pop	r14
    164a:	df 90       	pop	r13
    164c:	cf 90       	pop	r12
    164e:	08 95       	ret

00001650 <xTaskGenericCreate>:
    1650:	4f 92       	push	r4
    1652:	5f 92       	push	r5
    1654:	6f 92       	push	r6
    1656:	7f 92       	push	r7
    1658:	8f 92       	push	r8
    165a:	9f 92       	push	r9
    165c:	af 92       	push	r10
    165e:	bf 92       	push	r11
    1660:	cf 92       	push	r12
    1662:	df 92       	push	r13
    1664:	ef 92       	push	r14
    1666:	ff 92       	push	r15
    1668:	0f 93       	push	r16
    166a:	1f 93       	push	r17
    166c:	cf 93       	push	r28
    166e:	df 93       	push	r29
    1670:	4c 01       	movw	r8, r24
    1672:	eb 01       	movw	r28, r22
    1674:	5a 01       	movw	r10, r20
    1676:	29 01       	movw	r4, r18
    1678:	83 e3       	ldi	r24, 0x33	; 51
    167a:	90 e0       	ldi	r25, 0x00	; 0
    167c:	d5 da       	rcall	.-2646   	; 0xc28 <pvPortMalloc>
    167e:	3c 01       	movw	r6, r24
    1680:	00 97       	sbiw	r24, 0x00	; 0
    1682:	09 f4       	brne	.+2      	; 0x1686 <xTaskGenericCreate+0x36>
    1684:	da c0       	rjmp	.+436    	; 0x183a <xTaskGenericCreate+0x1ea>
    1686:	c1 14       	cp	r12, r1
    1688:	d1 04       	cpc	r13, r1
    168a:	09 f0       	breq	.+2      	; 0x168e <xTaskGenericCreate+0x3e>
    168c:	d2 c0       	rjmp	.+420    	; 0x1832 <xTaskGenericCreate+0x1e2>
    168e:	c5 01       	movw	r24, r10
    1690:	cb da       	rcall	.-2666   	; 0xc28 <pvPortMalloc>
    1692:	f3 01       	movw	r30, r6
    1694:	94 8f       	std	Z+28, r25	; 0x1c
    1696:	83 8f       	std	Z+27, r24	; 0x1b
    1698:	89 2b       	or	r24, r25
    169a:	19 f4       	brne	.+6      	; 0x16a2 <xTaskGenericCreate+0x52>
    169c:	c3 01       	movw	r24, r6
    169e:	f7 da       	rcall	.-2578   	; 0xc8e <vPortFree>
    16a0:	cc c0       	rjmp	.+408    	; 0x183a <xTaskGenericCreate+0x1ea>
    16a2:	f1 e0       	ldi	r31, 0x01	; 1
    16a4:	af 1a       	sub	r10, r31
    16a6:	b1 08       	sbc	r11, r1
    16a8:	f3 01       	movw	r30, r6
    16aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    16ac:	94 8d       	ldd	r25, Z+28	; 0x1c
    16ae:	a8 0e       	add	r10, r24
    16b0:	b9 1e       	adc	r11, r25
    16b2:	88 81       	ld	r24, Y
    16b4:	85 8f       	std	Z+29, r24	; 0x1d
    16b6:	88 81       	ld	r24, Y
    16b8:	88 23       	and	r24, r24
    16ba:	81 f0       	breq	.+32     	; 0x16dc <xTaskGenericCreate+0x8c>
    16bc:	d3 01       	movw	r26, r6
    16be:	5e 96       	adiw	r26, 0x1e	; 30
    16c0:	fe 01       	movw	r30, r28
    16c2:	31 96       	adiw	r30, 0x01	; 1
    16c4:	9e 01       	movw	r18, r28
    16c6:	2c 5e       	subi	r18, 0xEC	; 236
    16c8:	3f 4f       	sbci	r19, 0xFF	; 255
    16ca:	ef 01       	movw	r28, r30
    16cc:	81 91       	ld	r24, Z+
    16ce:	8d 93       	st	X+, r24
    16d0:	88 81       	ld	r24, Y
    16d2:	88 23       	and	r24, r24
    16d4:	19 f0       	breq	.+6      	; 0x16dc <xTaskGenericCreate+0x8c>
    16d6:	2e 17       	cp	r18, r30
    16d8:	3f 07       	cpc	r19, r31
    16da:	b9 f7       	brne	.-18     	; 0x16ca <xTaskGenericCreate+0x7a>
    16dc:	f3 01       	movw	r30, r6
    16de:	10 aa       	std	Z+48, r1	; 0x30
    16e0:	10 2f       	mov	r17, r16
    16e2:	04 31       	cpi	r16, 0x14	; 20
    16e4:	08 f0       	brcs	.+2      	; 0x16e8 <xTaskGenericCreate+0x98>
    16e6:	13 e1       	ldi	r17, 0x13	; 19
    16e8:	f3 01       	movw	r30, r6
    16ea:	12 8f       	std	Z+26, r17	; 0x1a
    16ec:	11 ab       	std	Z+49, r17	; 0x31
    16ee:	12 aa       	std	Z+50, r1	; 0x32
    16f0:	e3 01       	movw	r28, r6
    16f2:	22 96       	adiw	r28, 0x02	; 2
    16f4:	ce 01       	movw	r24, r28
    16f6:	dd da       	rcall	.-2630   	; 0xcb2 <vListInitialiseItem>
    16f8:	c3 01       	movw	r24, r6
    16fa:	0e 96       	adiw	r24, 0x0e	; 14
    16fc:	da da       	rcall	.-2636   	; 0xcb2 <vListInitialiseItem>
    16fe:	f3 01       	movw	r30, r6
    1700:	73 86       	std	Z+11, r7	; 0x0b
    1702:	62 86       	std	Z+10, r6	; 0x0a
    1704:	84 e1       	ldi	r24, 0x14	; 20
    1706:	90 e0       	ldi	r25, 0x00	; 0
    1708:	a0 e0       	ldi	r26, 0x00	; 0
    170a:	b0 e0       	ldi	r27, 0x00	; 0
    170c:	81 1b       	sub	r24, r17
    170e:	91 09       	sbc	r25, r1
    1710:	a1 09       	sbc	r26, r1
    1712:	b1 09       	sbc	r27, r1
    1714:	86 87       	std	Z+14, r24	; 0x0e
    1716:	97 87       	std	Z+15, r25	; 0x0f
    1718:	a0 8b       	std	Z+16, r26	; 0x10
    171a:	b1 8b       	std	Z+17, r27	; 0x11
    171c:	77 8a       	std	Z+23, r7	; 0x17
    171e:	66 8a       	std	Z+22, r6	; 0x16
    1720:	a2 01       	movw	r20, r4
    1722:	b4 01       	movw	r22, r8
    1724:	c5 01       	movw	r24, r10
    1726:	4d db       	rcall	.-2406   	; 0xdc2 <pxPortInitialiseStack>
    1728:	f3 01       	movw	r30, r6
    172a:	91 83       	std	Z+1, r25	; 0x01
    172c:	80 83       	st	Z, r24
    172e:	e1 14       	cp	r14, r1
    1730:	f1 04       	cpc	r15, r1
    1732:	19 f0       	breq	.+6      	; 0x173a <xTaskGenericCreate+0xea>
    1734:	f7 01       	movw	r30, r14
    1736:	71 82       	std	Z+1, r7	; 0x01
    1738:	60 82       	st	Z, r6
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	0f 92       	push	r0
    1740:	80 91 df 0e 	lds	r24, 0x0EDF	; 0x800edf <uxCurrentNumberOfTasks>
    1744:	8f 5f       	subi	r24, 0xFF	; 255
    1746:	80 93 df 0e 	sts	0x0EDF, r24	; 0x800edf <uxCurrentNumberOfTasks>
    174a:	80 91 ed 0f 	lds	r24, 0x0FED	; 0x800fed <pxCurrentTCB>
    174e:	90 91 ee 0f 	lds	r25, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1752:	89 2b       	or	r24, r25
    1754:	b1 f5       	brne	.+108    	; 0x17c2 <xTaskGenericCreate+0x172>
    1756:	70 92 ee 0f 	sts	0x0FEE, r7	; 0x800fee <pxCurrentTCB+0x1>
    175a:	60 92 ed 0f 	sts	0x0FED, r6	; 0x800fed <pxCurrentTCB>
    175e:	80 91 df 0e 	lds	r24, 0x0EDF	; 0x800edf <uxCurrentNumberOfTasks>
    1762:	81 30       	cpi	r24, 0x01	; 1
    1764:	09 f0       	breq	.+2      	; 0x1768 <xTaskGenericCreate+0x118>
    1766:	3c c0       	rjmp	.+120    	; 0x17e0 <xTaskGenericCreate+0x190>
    1768:	0f 2e       	mov	r0, r31
    176a:	f1 e1       	ldi	r31, 0x11	; 17
    176c:	ef 2e       	mov	r14, r31
    176e:	ff e0       	ldi	r31, 0x0F	; 15
    1770:	ff 2e       	mov	r15, r31
    1772:	f0 2d       	mov	r31, r0
    1774:	0f 2e       	mov	r0, r31
    1776:	fd ee       	ldi	r31, 0xED	; 237
    1778:	cf 2e       	mov	r12, r31
    177a:	ff e0       	ldi	r31, 0x0F	; 15
    177c:	df 2e       	mov	r13, r31
    177e:	f0 2d       	mov	r31, r0
    1780:	c7 01       	movw	r24, r14
    1782:	86 da       	rcall	.-2804   	; 0xc90 <vListInitialise>
    1784:	fb e0       	ldi	r31, 0x0B	; 11
    1786:	ef 0e       	add	r14, r31
    1788:	f1 1c       	adc	r15, r1
    178a:	ce 14       	cp	r12, r14
    178c:	df 04       	cpc	r13, r15
    178e:	c1 f7       	brne	.-16     	; 0x1780 <xTaskGenericCreate+0x130>
    1790:	86 e0       	ldi	r24, 0x06	; 6
    1792:	9f e0       	ldi	r25, 0x0F	; 15
    1794:	7d da       	rcall	.-2822   	; 0xc90 <vListInitialise>
    1796:	8b ef       	ldi	r24, 0xFB	; 251
    1798:	9e e0       	ldi	r25, 0x0E	; 14
    179a:	7a da       	rcall	.-2828   	; 0xc90 <vListInitialise>
    179c:	8c ee       	ldi	r24, 0xEC	; 236
    179e:	9e e0       	ldi	r25, 0x0E	; 14
    17a0:	77 da       	rcall	.-2834   	; 0xc90 <vListInitialise>
    17a2:	81 ee       	ldi	r24, 0xE1	; 225
    17a4:	9e e0       	ldi	r25, 0x0E	; 14
    17a6:	74 da       	rcall	.-2840   	; 0xc90 <vListInitialise>
    17a8:	86 e0       	ldi	r24, 0x06	; 6
    17aa:	9f e0       	ldi	r25, 0x0F	; 15
    17ac:	90 93 fa 0e 	sts	0x0EFA, r25	; 0x800efa <pxDelayedTaskList+0x1>
    17b0:	80 93 f9 0e 	sts	0x0EF9, r24	; 0x800ef9 <pxDelayedTaskList>
    17b4:	8b ef       	ldi	r24, 0xFB	; 251
    17b6:	9e e0       	ldi	r25, 0x0E	; 14
    17b8:	90 93 f8 0e 	sts	0x0EF8, r25	; 0x800ef8 <pxOverflowDelayedTaskList+0x1>
    17bc:	80 93 f7 0e 	sts	0x0EF7, r24	; 0x800ef7 <pxOverflowDelayedTaskList>
    17c0:	0f c0       	rjmp	.+30     	; 0x17e0 <xTaskGenericCreate+0x190>
    17c2:	80 91 d9 0e 	lds	r24, 0x0ED9	; 0x800ed9 <xSchedulerRunning>
    17c6:	81 11       	cpse	r24, r1
    17c8:	0b c0       	rjmp	.+22     	; 0x17e0 <xTaskGenericCreate+0x190>
    17ca:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    17ce:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    17d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    17d4:	08 17       	cp	r16, r24
    17d6:	20 f0       	brcs	.+8      	; 0x17e0 <xTaskGenericCreate+0x190>
    17d8:	70 92 ee 0f 	sts	0x0FEE, r7	; 0x800fee <pxCurrentTCB+0x1>
    17dc:	60 92 ed 0f 	sts	0x0FED, r6	; 0x800fed <pxCurrentTCB>
    17e0:	80 91 d5 0e 	lds	r24, 0x0ED5	; 0x800ed5 <uxTaskNumber>
    17e4:	8f 5f       	subi	r24, 0xFF	; 255
    17e6:	80 93 d5 0e 	sts	0x0ED5, r24	; 0x800ed5 <uxTaskNumber>
    17ea:	f3 01       	movw	r30, r6
    17ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    17ee:	90 91 da 0e 	lds	r25, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    17f2:	98 17       	cp	r25, r24
    17f4:	10 f4       	brcc	.+4      	; 0x17fa <xTaskGenericCreate+0x1aa>
    17f6:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    17fa:	fb e0       	ldi	r31, 0x0B	; 11
    17fc:	8f 9f       	mul	r24, r31
    17fe:	c0 01       	movw	r24, r0
    1800:	11 24       	eor	r1, r1
    1802:	be 01       	movw	r22, r28
    1804:	8f 5e       	subi	r24, 0xEF	; 239
    1806:	90 4f       	sbci	r25, 0xF0	; 240
    1808:	58 da       	rcall	.-2896   	; 0xcba <vListInsertEnd>
    180a:	0f 90       	pop	r0
    180c:	0f be       	out	0x3f, r0	; 63
    180e:	80 91 d9 0e 	lds	r24, 0x0ED9	; 0x800ed9 <xSchedulerRunning>
    1812:	88 23       	and	r24, r24
    1814:	51 f0       	breq	.+20     	; 0x182a <xTaskGenericCreate+0x1da>
    1816:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    181a:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    181e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1820:	80 17       	cp	r24, r16
    1822:	28 f4       	brcc	.+10     	; 0x182e <xTaskGenericCreate+0x1de>
    1824:	6f db       	rcall	.-2338   	; 0xf04 <vPortYield>
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	09 c0       	rjmp	.+18     	; 0x183c <xTaskGenericCreate+0x1ec>
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	07 c0       	rjmp	.+14     	; 0x183c <xTaskGenericCreate+0x1ec>
    182e:	81 e0       	ldi	r24, 0x01	; 1
    1830:	05 c0       	rjmp	.+10     	; 0x183c <xTaskGenericCreate+0x1ec>
    1832:	fc 01       	movw	r30, r24
    1834:	d4 8e       	std	Z+28, r13	; 0x1c
    1836:	c3 8e       	std	Z+27, r12	; 0x1b
    1838:	34 cf       	rjmp	.-408    	; 0x16a2 <xTaskGenericCreate+0x52>
    183a:	8f ef       	ldi	r24, 0xFF	; 255
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	df 90       	pop	r13
    184a:	cf 90       	pop	r12
    184c:	bf 90       	pop	r11
    184e:	af 90       	pop	r10
    1850:	9f 90       	pop	r9
    1852:	8f 90       	pop	r8
    1854:	7f 90       	pop	r7
    1856:	6f 90       	pop	r6
    1858:	5f 90       	pop	r5
    185a:	4f 90       	pop	r4
    185c:	08 95       	ret

0000185e <vTaskStartScheduler>:
    185e:	af 92       	push	r10
    1860:	bf 92       	push	r11
    1862:	cf 92       	push	r12
    1864:	df 92       	push	r13
    1866:	ef 92       	push	r14
    1868:	ff 92       	push	r15
    186a:	0f 93       	push	r16
    186c:	a1 2c       	mov	r10, r1
    186e:	b1 2c       	mov	r11, r1
    1870:	c1 2c       	mov	r12, r1
    1872:	d1 2c       	mov	r13, r1
    1874:	e1 2c       	mov	r14, r1
    1876:	f1 2c       	mov	r15, r1
    1878:	00 e0       	ldi	r16, 0x00	; 0
    187a:	20 e0       	ldi	r18, 0x00	; 0
    187c:	30 e0       	ldi	r19, 0x00	; 0
    187e:	45 e5       	ldi	r20, 0x55	; 85
    1880:	50 e0       	ldi	r21, 0x00	; 0
    1882:	61 e5       	ldi	r22, 0x51	; 81
    1884:	71 e0       	ldi	r23, 0x01	; 1
    1886:	8f ed       	ldi	r24, 0xDF	; 223
    1888:	9d e0       	ldi	r25, 0x0D	; 13
    188a:	e2 de       	rcall	.-572    	; 0x1650 <xTaskGenericCreate>
    188c:	81 30       	cpi	r24, 0x01	; 1
    188e:	61 f4       	brne	.+24     	; 0x18a8 <vTaskStartScheduler+0x4a>
    1890:	f8 94       	cli
    1892:	80 93 d9 0e 	sts	0x0ED9, r24	; 0x800ed9 <xSchedulerRunning>
    1896:	10 92 db 0e 	sts	0x0EDB, r1	; 0x800edb <xTickCount>
    189a:	10 92 dc 0e 	sts	0x0EDC, r1	; 0x800edc <xTickCount+0x1>
    189e:	10 92 dd 0e 	sts	0x0EDD, r1	; 0x800edd <xTickCount+0x2>
    18a2:	10 92 de 0e 	sts	0x0EDE, r1	; 0x800ede <xTickCount+0x3>
    18a6:	f9 da       	rcall	.-2574   	; 0xe9a <xPortStartScheduler>
    18a8:	0f 91       	pop	r16
    18aa:	ff 90       	pop	r15
    18ac:	ef 90       	pop	r14
    18ae:	df 90       	pop	r13
    18b0:	cf 90       	pop	r12
    18b2:	bf 90       	pop	r11
    18b4:	af 90       	pop	r10
    18b6:	08 95       	ret

000018b8 <vTaskSuspendAll>:
    18b8:	80 91 d4 0e 	lds	r24, 0x0ED4	; 0x800ed4 <uxSchedulerSuspended>
    18bc:	8f 5f       	subi	r24, 0xFF	; 255
    18be:	80 93 d4 0e 	sts	0x0ED4, r24	; 0x800ed4 <uxSchedulerSuspended>
    18c2:	08 95       	ret

000018c4 <xTaskIncrementTick>:
    18c4:	9f 92       	push	r9
    18c6:	af 92       	push	r10
    18c8:	bf 92       	push	r11
    18ca:	cf 92       	push	r12
    18cc:	df 92       	push	r13
    18ce:	ef 92       	push	r14
    18d0:	ff 92       	push	r15
    18d2:	0f 93       	push	r16
    18d4:	1f 93       	push	r17
    18d6:	cf 93       	push	r28
    18d8:	df 93       	push	r29
    18da:	80 91 d4 0e 	lds	r24, 0x0ED4	; 0x800ed4 <uxSchedulerSuspended>
    18de:	81 11       	cpse	r24, r1
    18e0:	b0 c0       	rjmp	.+352    	; 0x1a42 <xTaskIncrementTick+0x17e>
    18e2:	80 91 db 0e 	lds	r24, 0x0EDB	; 0x800edb <xTickCount>
    18e6:	90 91 dc 0e 	lds	r25, 0x0EDC	; 0x800edc <xTickCount+0x1>
    18ea:	a0 91 dd 0e 	lds	r26, 0x0EDD	; 0x800edd <xTickCount+0x2>
    18ee:	b0 91 de 0e 	lds	r27, 0x0EDE	; 0x800ede <xTickCount+0x3>
    18f2:	01 96       	adiw	r24, 0x01	; 1
    18f4:	a1 1d       	adc	r26, r1
    18f6:	b1 1d       	adc	r27, r1
    18f8:	80 93 db 0e 	sts	0x0EDB, r24	; 0x800edb <xTickCount>
    18fc:	90 93 dc 0e 	sts	0x0EDC, r25	; 0x800edc <xTickCount+0x1>
    1900:	a0 93 dd 0e 	sts	0x0EDD, r26	; 0x800edd <xTickCount+0x2>
    1904:	b0 93 de 0e 	sts	0x0EDE, r27	; 0x800ede <xTickCount+0x3>
    1908:	c0 90 db 0e 	lds	r12, 0x0EDB	; 0x800edb <xTickCount>
    190c:	d0 90 dc 0e 	lds	r13, 0x0EDC	; 0x800edc <xTickCount+0x1>
    1910:	e0 90 dd 0e 	lds	r14, 0x0EDD	; 0x800edd <xTickCount+0x2>
    1914:	f0 90 de 0e 	lds	r15, 0x0EDE	; 0x800ede <xTickCount+0x3>
    1918:	c1 14       	cp	r12, r1
    191a:	d1 04       	cpc	r13, r1
    191c:	e1 04       	cpc	r14, r1
    191e:	f1 04       	cpc	r15, r1
    1920:	b1 f4       	brne	.+44     	; 0x194e <xTaskIncrementTick+0x8a>
    1922:	80 91 f9 0e 	lds	r24, 0x0EF9	; 0x800ef9 <pxDelayedTaskList>
    1926:	90 91 fa 0e 	lds	r25, 0x0EFA	; 0x800efa <pxDelayedTaskList+0x1>
    192a:	20 91 f7 0e 	lds	r18, 0x0EF7	; 0x800ef7 <pxOverflowDelayedTaskList>
    192e:	30 91 f8 0e 	lds	r19, 0x0EF8	; 0x800ef8 <pxOverflowDelayedTaskList+0x1>
    1932:	30 93 fa 0e 	sts	0x0EFA, r19	; 0x800efa <pxDelayedTaskList+0x1>
    1936:	20 93 f9 0e 	sts	0x0EF9, r18	; 0x800ef9 <pxDelayedTaskList>
    193a:	90 93 f8 0e 	sts	0x0EF8, r25	; 0x800ef8 <pxOverflowDelayedTaskList+0x1>
    193e:	80 93 f7 0e 	sts	0x0EF7, r24	; 0x800ef7 <pxOverflowDelayedTaskList>
    1942:	80 91 d6 0e 	lds	r24, 0x0ED6	; 0x800ed6 <xNumOfOverflows>
    1946:	8f 5f       	subi	r24, 0xFF	; 255
    1948:	80 93 d6 0e 	sts	0x0ED6, r24	; 0x800ed6 <xNumOfOverflows>
    194c:	0b de       	rcall	.-1002   	; 0x1564 <prvResetNextTaskUnblockTime>
    194e:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xNextTaskUnblockTime>
    1952:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xNextTaskUnblockTime+0x1>
    1956:	a0 91 0e 01 	lds	r26, 0x010E	; 0x80010e <xNextTaskUnblockTime+0x2>
    195a:	b0 91 0f 01 	lds	r27, 0x010F	; 0x80010f <xNextTaskUnblockTime+0x3>
    195e:	c8 16       	cp	r12, r24
    1960:	d9 06       	cpc	r13, r25
    1962:	ea 06       	cpc	r14, r26
    1964:	fb 06       	cpc	r15, r27
    1966:	10 f4       	brcc	.+4      	; 0x196c <xTaskIncrementTick+0xa8>
    1968:	b1 2c       	mov	r11, r1
    196a:	5a c0       	rjmp	.+180    	; 0x1a20 <xTaskIncrementTick+0x15c>
    196c:	b1 2c       	mov	r11, r1
    196e:	0f 2e       	mov	r0, r31
    1970:	fb e0       	ldi	r31, 0x0B	; 11
    1972:	af 2e       	mov	r10, r31
    1974:	f0 2d       	mov	r31, r0
    1976:	99 24       	eor	r9, r9
    1978:	93 94       	inc	r9
    197a:	e0 91 f9 0e 	lds	r30, 0x0EF9	; 0x800ef9 <pxDelayedTaskList>
    197e:	f0 91 fa 0e 	lds	r31, 0x0EFA	; 0x800efa <pxDelayedTaskList+0x1>
    1982:	80 81       	ld	r24, Z
    1984:	81 11       	cpse	r24, r1
    1986:	0c c0       	rjmp	.+24     	; 0x19a0 <xTaskIncrementTick+0xdc>
    1988:	8f ef       	ldi	r24, 0xFF	; 255
    198a:	9f ef       	ldi	r25, 0xFF	; 255
    198c:	dc 01       	movw	r26, r24
    198e:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
    1992:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
    1996:	a0 93 0e 01 	sts	0x010E, r26	; 0x80010e <xNextTaskUnblockTime+0x2>
    199a:	b0 93 0f 01 	sts	0x010F, r27	; 0x80010f <xNextTaskUnblockTime+0x3>
    199e:	40 c0       	rjmp	.+128    	; 0x1a20 <xTaskIncrementTick+0x15c>
    19a0:	e0 91 f9 0e 	lds	r30, 0x0EF9	; 0x800ef9 <pxDelayedTaskList>
    19a4:	f0 91 fa 0e 	lds	r31, 0x0EFA	; 0x800efa <pxDelayedTaskList+0x1>
    19a8:	07 80       	ldd	r0, Z+7	; 0x07
    19aa:	f0 85       	ldd	r31, Z+8	; 0x08
    19ac:	e0 2d       	mov	r30, r0
    19ae:	c0 85       	ldd	r28, Z+8	; 0x08
    19b0:	d1 85       	ldd	r29, Z+9	; 0x09
    19b2:	8a 81       	ldd	r24, Y+2	; 0x02
    19b4:	9b 81       	ldd	r25, Y+3	; 0x03
    19b6:	ac 81       	ldd	r26, Y+4	; 0x04
    19b8:	bd 81       	ldd	r27, Y+5	; 0x05
    19ba:	c8 16       	cp	r12, r24
    19bc:	d9 06       	cpc	r13, r25
    19be:	ea 06       	cpc	r14, r26
    19c0:	fb 06       	cpc	r15, r27
    19c2:	48 f4       	brcc	.+18     	; 0x19d6 <xTaskIncrementTick+0x112>
    19c4:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
    19c8:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
    19cc:	a0 93 0e 01 	sts	0x010E, r26	; 0x80010e <xNextTaskUnblockTime+0x2>
    19d0:	b0 93 0f 01 	sts	0x010F, r27	; 0x80010f <xNextTaskUnblockTime+0x3>
    19d4:	25 c0       	rjmp	.+74     	; 0x1a20 <xTaskIncrementTick+0x15c>
    19d6:	8e 01       	movw	r16, r28
    19d8:	0e 5f       	subi	r16, 0xFE	; 254
    19da:	1f 4f       	sbci	r17, 0xFF	; 255
    19dc:	c8 01       	movw	r24, r16
    19de:	cb d9       	rcall	.-3178   	; 0xd76 <uxListRemove>
    19e0:	88 8d       	ldd	r24, Y+24	; 0x18
    19e2:	99 8d       	ldd	r25, Y+25	; 0x19
    19e4:	89 2b       	or	r24, r25
    19e6:	19 f0       	breq	.+6      	; 0x19ee <xTaskIncrementTick+0x12a>
    19e8:	ce 01       	movw	r24, r28
    19ea:	0e 96       	adiw	r24, 0x0e	; 14
    19ec:	c4 d9       	rcall	.-3192   	; 0xd76 <uxListRemove>
    19ee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19f0:	90 91 da 0e 	lds	r25, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    19f4:	98 17       	cp	r25, r24
    19f6:	10 f4       	brcc	.+4      	; 0x19fc <xTaskIncrementTick+0x138>
    19f8:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    19fc:	a8 9e       	mul	r10, r24
    19fe:	c0 01       	movw	r24, r0
    1a00:	11 24       	eor	r1, r1
    1a02:	b8 01       	movw	r22, r16
    1a04:	8f 5e       	subi	r24, 0xEF	; 239
    1a06:	90 4f       	sbci	r25, 0xF0	; 240
    1a08:	58 d9       	rcall	.-3408   	; 0xcba <vListInsertEnd>
    1a0a:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    1a0e:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1a12:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a14:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a16:	98 17       	cp	r25, r24
    1a18:	08 f4       	brcc	.+2      	; 0x1a1c <xTaskIncrementTick+0x158>
    1a1a:	af cf       	rjmp	.-162    	; 0x197a <xTaskIncrementTick+0xb6>
    1a1c:	b9 2c       	mov	r11, r9
    1a1e:	ad cf       	rjmp	.-166    	; 0x197a <xTaskIncrementTick+0xb6>
    1a20:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    1a24:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1a28:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1a2a:	8b e0       	ldi	r24, 0x0B	; 11
    1a2c:	e8 9f       	mul	r30, r24
    1a2e:	f0 01       	movw	r30, r0
    1a30:	11 24       	eor	r1, r1
    1a32:	ef 5e       	subi	r30, 0xEF	; 239
    1a34:	f0 4f       	sbci	r31, 0xF0	; 240
    1a36:	80 81       	ld	r24, Z
    1a38:	82 30       	cpi	r24, 0x02	; 2
    1a3a:	48 f0       	brcs	.+18     	; 0x1a4e <xTaskIncrementTick+0x18a>
    1a3c:	bb 24       	eor	r11, r11
    1a3e:	b3 94       	inc	r11
    1a40:	06 c0       	rjmp	.+12     	; 0x1a4e <xTaskIncrementTick+0x18a>
    1a42:	80 91 d8 0e 	lds	r24, 0x0ED8	; 0x800ed8 <uxPendedTicks>
    1a46:	8f 5f       	subi	r24, 0xFF	; 255
    1a48:	80 93 d8 0e 	sts	0x0ED8, r24	; 0x800ed8 <uxPendedTicks>
    1a4c:	b1 2c       	mov	r11, r1
    1a4e:	80 91 d7 0e 	lds	r24, 0x0ED7	; 0x800ed7 <xYieldPending>
    1a52:	88 23       	and	r24, r24
    1a54:	11 f0       	breq	.+4      	; 0x1a5a <xTaskIncrementTick+0x196>
    1a56:	bb 24       	eor	r11, r11
    1a58:	b3 94       	inc	r11
    1a5a:	8b 2d       	mov	r24, r11
    1a5c:	df 91       	pop	r29
    1a5e:	cf 91       	pop	r28
    1a60:	1f 91       	pop	r17
    1a62:	0f 91       	pop	r16
    1a64:	ff 90       	pop	r15
    1a66:	ef 90       	pop	r14
    1a68:	df 90       	pop	r13
    1a6a:	cf 90       	pop	r12
    1a6c:	bf 90       	pop	r11
    1a6e:	af 90       	pop	r10
    1a70:	9f 90       	pop	r9
    1a72:	08 95       	ret

00001a74 <xTaskResumeAll>:
    1a74:	cf 92       	push	r12
    1a76:	df 92       	push	r13
    1a78:	ef 92       	push	r14
    1a7a:	ff 92       	push	r15
    1a7c:	0f 93       	push	r16
    1a7e:	1f 93       	push	r17
    1a80:	cf 93       	push	r28
    1a82:	df 93       	push	r29
    1a84:	0f b6       	in	r0, 0x3f	; 63
    1a86:	f8 94       	cli
    1a88:	0f 92       	push	r0
    1a8a:	80 91 d4 0e 	lds	r24, 0x0ED4	; 0x800ed4 <uxSchedulerSuspended>
    1a8e:	81 50       	subi	r24, 0x01	; 1
    1a90:	80 93 d4 0e 	sts	0x0ED4, r24	; 0x800ed4 <uxSchedulerSuspended>
    1a94:	80 91 d4 0e 	lds	r24, 0x0ED4	; 0x800ed4 <uxSchedulerSuspended>
    1a98:	81 11       	cpse	r24, r1
    1a9a:	5a c0       	rjmp	.+180    	; 0x1b50 <xTaskResumeAll+0xdc>
    1a9c:	80 91 df 0e 	lds	r24, 0x0EDF	; 0x800edf <uxCurrentNumberOfTasks>
    1aa0:	81 11       	cpse	r24, r1
    1aa2:	29 c0       	rjmp	.+82     	; 0x1af6 <xTaskResumeAll+0x82>
    1aa4:	58 c0       	rjmp	.+176    	; 0x1b56 <xTaskResumeAll+0xe2>
    1aa6:	d7 01       	movw	r26, r14
    1aa8:	17 96       	adiw	r26, 0x07	; 7
    1aaa:	ed 91       	ld	r30, X+
    1aac:	fc 91       	ld	r31, X
    1aae:	18 97       	sbiw	r26, 0x08	; 8
    1ab0:	c0 85       	ldd	r28, Z+8	; 0x08
    1ab2:	d1 85       	ldd	r29, Z+9	; 0x09
    1ab4:	ce 01       	movw	r24, r28
    1ab6:	0e 96       	adiw	r24, 0x0e	; 14
    1ab8:	5e d9       	rcall	.-3396   	; 0xd76 <uxListRemove>
    1aba:	8e 01       	movw	r16, r28
    1abc:	0e 5f       	subi	r16, 0xFE	; 254
    1abe:	1f 4f       	sbci	r17, 0xFF	; 255
    1ac0:	c8 01       	movw	r24, r16
    1ac2:	59 d9       	rcall	.-3406   	; 0xd76 <uxListRemove>
    1ac4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ac6:	90 91 da 0e 	lds	r25, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1aca:	98 17       	cp	r25, r24
    1acc:	10 f4       	brcc	.+4      	; 0x1ad2 <xTaskResumeAll+0x5e>
    1ace:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    1ad2:	d8 9e       	mul	r13, r24
    1ad4:	c0 01       	movw	r24, r0
    1ad6:	11 24       	eor	r1, r1
    1ad8:	b8 01       	movw	r22, r16
    1ada:	8f 5e       	subi	r24, 0xEF	; 239
    1adc:	90 4f       	sbci	r25, 0xF0	; 240
    1ade:	ed d8       	rcall	.-3622   	; 0xcba <vListInsertEnd>
    1ae0:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    1ae4:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1ae8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1aea:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aec:	98 17       	cp	r25, r24
    1aee:	78 f0       	brcs	.+30     	; 0x1b0e <xTaskResumeAll+0x9a>
    1af0:	c0 92 d7 0e 	sts	0x0ED7, r12	; 0x800ed7 <xYieldPending>
    1af4:	0c c0       	rjmp	.+24     	; 0x1b0e <xTaskResumeAll+0x9a>
    1af6:	0f 2e       	mov	r0, r31
    1af8:	fc ee       	ldi	r31, 0xEC	; 236
    1afa:	ef 2e       	mov	r14, r31
    1afc:	fe e0       	ldi	r31, 0x0E	; 14
    1afe:	ff 2e       	mov	r15, r31
    1b00:	f0 2d       	mov	r31, r0
    1b02:	0f 2e       	mov	r0, r31
    1b04:	fb e0       	ldi	r31, 0x0B	; 11
    1b06:	df 2e       	mov	r13, r31
    1b08:	f0 2d       	mov	r31, r0
    1b0a:	cc 24       	eor	r12, r12
    1b0c:	c3 94       	inc	r12
    1b0e:	f7 01       	movw	r30, r14
    1b10:	80 81       	ld	r24, Z
    1b12:	81 11       	cpse	r24, r1
    1b14:	c8 cf       	rjmp	.-112    	; 0x1aa6 <xTaskResumeAll+0x32>
    1b16:	80 91 d8 0e 	lds	r24, 0x0ED8	; 0x800ed8 <uxPendedTicks>
    1b1a:	88 23       	and	r24, r24
    1b1c:	91 f0       	breq	.+36     	; 0x1b42 <xTaskResumeAll+0xce>
    1b1e:	80 91 d8 0e 	lds	r24, 0x0ED8	; 0x800ed8 <uxPendedTicks>
    1b22:	88 23       	and	r24, r24
    1b24:	71 f0       	breq	.+28     	; 0x1b42 <xTaskResumeAll+0xce>
    1b26:	c1 e0       	ldi	r28, 0x01	; 1
    1b28:	cd de       	rcall	.-614    	; 0x18c4 <xTaskIncrementTick>
    1b2a:	81 11       	cpse	r24, r1
    1b2c:	c0 93 d7 0e 	sts	0x0ED7, r28	; 0x800ed7 <xYieldPending>
    1b30:	80 91 d8 0e 	lds	r24, 0x0ED8	; 0x800ed8 <uxPendedTicks>
    1b34:	81 50       	subi	r24, 0x01	; 1
    1b36:	80 93 d8 0e 	sts	0x0ED8, r24	; 0x800ed8 <uxPendedTicks>
    1b3a:	80 91 d8 0e 	lds	r24, 0x0ED8	; 0x800ed8 <uxPendedTicks>
    1b3e:	81 11       	cpse	r24, r1
    1b40:	f3 cf       	rjmp	.-26     	; 0x1b28 <xTaskResumeAll+0xb4>
    1b42:	80 91 d7 0e 	lds	r24, 0x0ED7	; 0x800ed7 <xYieldPending>
    1b46:	81 30       	cpi	r24, 0x01	; 1
    1b48:	29 f4       	brne	.+10     	; 0x1b54 <xTaskResumeAll+0xe0>
    1b4a:	dc d9       	rcall	.-3144   	; 0xf04 <vPortYield>
    1b4c:	81 e0       	ldi	r24, 0x01	; 1
    1b4e:	03 c0       	rjmp	.+6      	; 0x1b56 <xTaskResumeAll+0xe2>
    1b50:	80 e0       	ldi	r24, 0x00	; 0
    1b52:	01 c0       	rjmp	.+2      	; 0x1b56 <xTaskResumeAll+0xe2>
    1b54:	80 e0       	ldi	r24, 0x00	; 0
    1b56:	0f 90       	pop	r0
    1b58:	0f be       	out	0x3f, r0	; 63
    1b5a:	df 91       	pop	r29
    1b5c:	cf 91       	pop	r28
    1b5e:	1f 91       	pop	r17
    1b60:	0f 91       	pop	r16
    1b62:	ff 90       	pop	r15
    1b64:	ef 90       	pop	r14
    1b66:	df 90       	pop	r13
    1b68:	cf 90       	pop	r12
    1b6a:	08 95       	ret

00001b6c <vTaskDelay>:
    1b6c:	cf 92       	push	r12
    1b6e:	df 92       	push	r13
    1b70:	ef 92       	push	r14
    1b72:	ff 92       	push	r15
    1b74:	6b 01       	movw	r12, r22
    1b76:	7c 01       	movw	r14, r24
    1b78:	67 2b       	or	r22, r23
    1b7a:	68 2b       	or	r22, r24
    1b7c:	69 2b       	or	r22, r25
    1b7e:	c9 f0       	breq	.+50     	; 0x1bb2 <vTaskDelay+0x46>
    1b80:	9b de       	rcall	.-714    	; 0x18b8 <vTaskSuspendAll>
    1b82:	80 91 db 0e 	lds	r24, 0x0EDB	; 0x800edb <xTickCount>
    1b86:	90 91 dc 0e 	lds	r25, 0x0EDC	; 0x800edc <xTickCount+0x1>
    1b8a:	a0 91 dd 0e 	lds	r26, 0x0EDD	; 0x800edd <xTickCount+0x2>
    1b8e:	b0 91 de 0e 	lds	r27, 0x0EDE	; 0x800ede <xTickCount+0x3>
    1b92:	c8 0e       	add	r12, r24
    1b94:	d9 1e       	adc	r13, r25
    1b96:	ea 1e       	adc	r14, r26
    1b98:	fb 1e       	adc	r15, r27
    1b9a:	80 91 ed 0f 	lds	r24, 0x0FED	; 0x800fed <pxCurrentTCB>
    1b9e:	90 91 ee 0f 	lds	r25, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1ba2:	02 96       	adiw	r24, 0x02	; 2
    1ba4:	e8 d8       	rcall	.-3632   	; 0xd76 <uxListRemove>
    1ba6:	c7 01       	movw	r24, r14
    1ba8:	b6 01       	movw	r22, r12
    1baa:	06 dd       	rcall	.-1524   	; 0x15b8 <prvAddCurrentTaskToDelayedList>
    1bac:	63 df       	rcall	.-314    	; 0x1a74 <xTaskResumeAll>
    1bae:	81 11       	cpse	r24, r1
    1bb0:	01 c0       	rjmp	.+2      	; 0x1bb4 <vTaskDelay+0x48>
    1bb2:	a8 d9       	rcall	.-3248   	; 0xf04 <vPortYield>
    1bb4:	ff 90       	pop	r15
    1bb6:	ef 90       	pop	r14
    1bb8:	df 90       	pop	r13
    1bba:	cf 90       	pop	r12
    1bbc:	08 95       	ret

00001bbe <prvIdleTask>:
    1bbe:	01 ee       	ldi	r16, 0xE1	; 225
    1bc0:	1e e0       	ldi	r17, 0x0E	; 14
    1bc2:	0f 2e       	mov	r0, r31
    1bc4:	f1 e1       	ldi	r31, 0x11	; 17
    1bc6:	ef 2e       	mov	r14, r31
    1bc8:	ff e0       	ldi	r31, 0x0F	; 15
    1bca:	ff 2e       	mov	r15, r31
    1bcc:	f0 2d       	mov	r31, r0
    1bce:	24 c0       	rjmp	.+72     	; 0x1c18 <prvIdleTask+0x5a>
    1bd0:	73 de       	rcall	.-794    	; 0x18b8 <vTaskSuspendAll>
    1bd2:	d8 01       	movw	r26, r16
    1bd4:	cc 91       	ld	r28, X
    1bd6:	4e df       	rcall	.-356    	; 0x1a74 <xTaskResumeAll>
    1bd8:	cc 23       	and	r28, r28
    1bda:	f1 f0       	breq	.+60     	; 0x1c18 <prvIdleTask+0x5a>
    1bdc:	0f b6       	in	r0, 0x3f	; 63
    1bde:	f8 94       	cli
    1be0:	0f 92       	push	r0
    1be2:	d8 01       	movw	r26, r16
    1be4:	17 96       	adiw	r26, 0x07	; 7
    1be6:	ed 91       	ld	r30, X+
    1be8:	fc 91       	ld	r31, X
    1bea:	18 97       	sbiw	r26, 0x08	; 8
    1bec:	c0 85       	ldd	r28, Z+8	; 0x08
    1bee:	d1 85       	ldd	r29, Z+9	; 0x09
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	02 96       	adiw	r24, 0x02	; 2
    1bf4:	c0 d8       	rcall	.-3712   	; 0xd76 <uxListRemove>
    1bf6:	80 91 df 0e 	lds	r24, 0x0EDF	; 0x800edf <uxCurrentNumberOfTasks>
    1bfa:	81 50       	subi	r24, 0x01	; 1
    1bfc:	80 93 df 0e 	sts	0x0EDF, r24	; 0x800edf <uxCurrentNumberOfTasks>
    1c00:	80 91 e0 0e 	lds	r24, 0x0EE0	; 0x800ee0 <uxTasksDeleted>
    1c04:	81 50       	subi	r24, 0x01	; 1
    1c06:	80 93 e0 0e 	sts	0x0EE0, r24	; 0x800ee0 <uxTasksDeleted>
    1c0a:	0f 90       	pop	r0
    1c0c:	0f be       	out	0x3f, r0	; 63
    1c0e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c10:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1c12:	3d d8       	rcall	.-3974   	; 0xc8e <vPortFree>
    1c14:	ce 01       	movw	r24, r28
    1c16:	3b d8       	rcall	.-3978   	; 0xc8e <vPortFree>
    1c18:	80 91 e0 0e 	lds	r24, 0x0EE0	; 0x800ee0 <uxTasksDeleted>
    1c1c:	81 11       	cpse	r24, r1
    1c1e:	d8 cf       	rjmp	.-80     	; 0x1bd0 <prvIdleTask+0x12>
    1c20:	f7 01       	movw	r30, r14
    1c22:	80 81       	ld	r24, Z
    1c24:	82 30       	cpi	r24, 0x02	; 2
    1c26:	c0 f3       	brcs	.-16     	; 0x1c18 <prvIdleTask+0x5a>
    1c28:	6d d9       	rcall	.-3366   	; 0xf04 <vPortYield>
    1c2a:	f6 cf       	rjmp	.-20     	; 0x1c18 <prvIdleTask+0x5a>

00001c2c <vTaskSwitchContext>:
    1c2c:	80 91 d4 0e 	lds	r24, 0x0ED4	; 0x800ed4 <uxSchedulerSuspended>
    1c30:	88 23       	and	r24, r24
    1c32:	21 f0       	breq	.+8      	; 0x1c3c <vTaskSwitchContext+0x10>
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	80 93 d7 0e 	sts	0x0ED7, r24	; 0x800ed7 <xYieldPending>
    1c3a:	08 95       	ret
    1c3c:	10 92 d7 0e 	sts	0x0ED7, r1	; 0x800ed7 <xYieldPending>
    1c40:	e0 91 da 0e 	lds	r30, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1c44:	4b e0       	ldi	r20, 0x0B	; 11
    1c46:	e4 9f       	mul	r30, r20
    1c48:	f0 01       	movw	r30, r0
    1c4a:	11 24       	eor	r1, r1
    1c4c:	ef 5e       	subi	r30, 0xEF	; 239
    1c4e:	f0 4f       	sbci	r31, 0xF0	; 240
    1c50:	80 81       	ld	r24, Z
    1c52:	81 11       	cpse	r24, r1
    1c54:	10 c0       	rjmp	.+32     	; 0x1c76 <vTaskSwitchContext+0x4a>
    1c56:	9b e0       	ldi	r25, 0x0B	; 11
    1c58:	80 91 da 0e 	lds	r24, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1c5c:	81 50       	subi	r24, 0x01	; 1
    1c5e:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    1c62:	e0 91 da 0e 	lds	r30, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1c66:	9e 9f       	mul	r25, r30
    1c68:	f0 01       	movw	r30, r0
    1c6a:	11 24       	eor	r1, r1
    1c6c:	ef 5e       	subi	r30, 0xEF	; 239
    1c6e:	f0 4f       	sbci	r31, 0xF0	; 240
    1c70:	80 81       	ld	r24, Z
    1c72:	88 23       	and	r24, r24
    1c74:	89 f3       	breq	.-30     	; 0x1c58 <vTaskSwitchContext+0x2c>
    1c76:	80 91 da 0e 	lds	r24, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1c7a:	28 2f       	mov	r18, r24
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	4b e0       	ldi	r20, 0x0B	; 11
    1c80:	84 9f       	mul	r24, r20
    1c82:	c0 01       	movw	r24, r0
    1c84:	11 24       	eor	r1, r1
    1c86:	dc 01       	movw	r26, r24
    1c88:	af 5e       	subi	r26, 0xEF	; 239
    1c8a:	b0 4f       	sbci	r27, 0xF0	; 240
    1c8c:	11 96       	adiw	r26, 0x01	; 1
    1c8e:	ed 91       	ld	r30, X+
    1c90:	fc 91       	ld	r31, X
    1c92:	12 97       	sbiw	r26, 0x02	; 2
    1c94:	04 80       	ldd	r0, Z+4	; 0x04
    1c96:	f5 81       	ldd	r31, Z+5	; 0x05
    1c98:	e0 2d       	mov	r30, r0
    1c9a:	12 96       	adiw	r26, 0x02	; 2
    1c9c:	fc 93       	st	X, r31
    1c9e:	ee 93       	st	-X, r30
    1ca0:	11 97       	sbiw	r26, 0x01	; 1
    1ca2:	8c 5e       	subi	r24, 0xEC	; 236
    1ca4:	90 4f       	sbci	r25, 0xF0	; 240
    1ca6:	e8 17       	cp	r30, r24
    1ca8:	f9 07       	cpc	r31, r25
    1caa:	61 f4       	brne	.+24     	; 0x1cc4 <vTaskSwitchContext+0x98>
    1cac:	84 81       	ldd	r24, Z+4	; 0x04
    1cae:	95 81       	ldd	r25, Z+5	; 0x05
    1cb0:	4b e0       	ldi	r20, 0x0B	; 11
    1cb2:	42 9f       	mul	r20, r18
    1cb4:	f0 01       	movw	r30, r0
    1cb6:	43 9f       	mul	r20, r19
    1cb8:	f0 0d       	add	r31, r0
    1cba:	11 24       	eor	r1, r1
    1cbc:	ef 5e       	subi	r30, 0xEF	; 239
    1cbe:	f0 4f       	sbci	r31, 0xF0	; 240
    1cc0:	92 83       	std	Z+2, r25	; 0x02
    1cc2:	81 83       	std	Z+1, r24	; 0x01
    1cc4:	8b e0       	ldi	r24, 0x0B	; 11
    1cc6:	82 9f       	mul	r24, r18
    1cc8:	f0 01       	movw	r30, r0
    1cca:	83 9f       	mul	r24, r19
    1ccc:	f0 0d       	add	r31, r0
    1cce:	11 24       	eor	r1, r1
    1cd0:	ef 5e       	subi	r30, 0xEF	; 239
    1cd2:	f0 4f       	sbci	r31, 0xF0	; 240
    1cd4:	01 80       	ldd	r0, Z+1	; 0x01
    1cd6:	f2 81       	ldd	r31, Z+2	; 0x02
    1cd8:	e0 2d       	mov	r30, r0
    1cda:	80 85       	ldd	r24, Z+8	; 0x08
    1cdc:	91 85       	ldd	r25, Z+9	; 0x09
    1cde:	90 93 ee 0f 	sts	0x0FEE, r25	; 0x800fee <pxCurrentTCB+0x1>
    1ce2:	80 93 ed 0f 	sts	0x0FED, r24	; 0x800fed <pxCurrentTCB>
    1ce6:	08 95       	ret

00001ce8 <vTaskPlaceOnEventList>:
    1ce8:	cf 92       	push	r12
    1cea:	df 92       	push	r13
    1cec:	ef 92       	push	r14
    1cee:	ff 92       	push	r15
    1cf0:	6a 01       	movw	r12, r20
    1cf2:	7b 01       	movw	r14, r22
    1cf4:	60 91 ed 0f 	lds	r22, 0x0FED	; 0x800fed <pxCurrentTCB>
    1cf8:	70 91 ee 0f 	lds	r23, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1cfc:	62 5f       	subi	r22, 0xF2	; 242
    1cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1d00:	0e 94 7e 06 	call	0xcfc	; 0xcfc <vListInsert>
    1d04:	80 91 ed 0f 	lds	r24, 0x0FED	; 0x800fed <pxCurrentTCB>
    1d08:	90 91 ee 0f 	lds	r25, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1d0c:	02 96       	adiw	r24, 0x02	; 2
    1d0e:	33 d8       	rcall	.-3994   	; 0xd76 <uxListRemove>
    1d10:	80 91 db 0e 	lds	r24, 0x0EDB	; 0x800edb <xTickCount>
    1d14:	90 91 dc 0e 	lds	r25, 0x0EDC	; 0x800edc <xTickCount+0x1>
    1d18:	a0 91 dd 0e 	lds	r26, 0x0EDD	; 0x800edd <xTickCount+0x2>
    1d1c:	b0 91 de 0e 	lds	r27, 0x0EDE	; 0x800ede <xTickCount+0x3>
    1d20:	bc 01       	movw	r22, r24
    1d22:	cd 01       	movw	r24, r26
    1d24:	6c 0d       	add	r22, r12
    1d26:	7d 1d       	adc	r23, r13
    1d28:	8e 1d       	adc	r24, r14
    1d2a:	9f 1d       	adc	r25, r15
    1d2c:	45 dc       	rcall	.-1910   	; 0x15b8 <prvAddCurrentTaskToDelayedList>
    1d2e:	ff 90       	pop	r15
    1d30:	ef 90       	pop	r14
    1d32:	df 90       	pop	r13
    1d34:	cf 90       	pop	r12
    1d36:	08 95       	ret

00001d38 <vTaskPlaceOnUnorderedEventList>:
    1d38:	cf 92       	push	r12
    1d3a:	df 92       	push	r13
    1d3c:	ef 92       	push	r14
    1d3e:	ff 92       	push	r15
    1d40:	0f 93       	push	r16
    1d42:	1f 93       	push	r17
    1d44:	68 01       	movw	r12, r16
    1d46:	79 01       	movw	r14, r18
    1d48:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    1d4c:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1d50:	70 68       	ori	r23, 0x80	; 128
    1d52:	46 87       	std	Z+14, r20	; 0x0e
    1d54:	57 87       	std	Z+15, r21	; 0x0f
    1d56:	60 8b       	std	Z+16, r22	; 0x10
    1d58:	71 8b       	std	Z+17, r23	; 0x11
    1d5a:	60 91 ed 0f 	lds	r22, 0x0FED	; 0x800fed <pxCurrentTCB>
    1d5e:	70 91 ee 0f 	lds	r23, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1d62:	62 5f       	subi	r22, 0xF2	; 242
    1d64:	7f 4f       	sbci	r23, 0xFF	; 255
    1d66:	0e 94 5d 06 	call	0xcba	; 0xcba <vListInsertEnd>
    1d6a:	80 91 ed 0f 	lds	r24, 0x0FED	; 0x800fed <pxCurrentTCB>
    1d6e:	90 91 ee 0f 	lds	r25, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1d72:	02 96       	adiw	r24, 0x02	; 2
    1d74:	00 d8       	rcall	.-4096   	; 0xd76 <uxListRemove>
    1d76:	80 91 db 0e 	lds	r24, 0x0EDB	; 0x800edb <xTickCount>
    1d7a:	90 91 dc 0e 	lds	r25, 0x0EDC	; 0x800edc <xTickCount+0x1>
    1d7e:	a0 91 dd 0e 	lds	r26, 0x0EDD	; 0x800edd <xTickCount+0x2>
    1d82:	b0 91 de 0e 	lds	r27, 0x0EDE	; 0x800ede <xTickCount+0x3>
    1d86:	bc 01       	movw	r22, r24
    1d88:	cd 01       	movw	r24, r26
    1d8a:	6c 0d       	add	r22, r12
    1d8c:	7d 1d       	adc	r23, r13
    1d8e:	8e 1d       	adc	r24, r14
    1d90:	9f 1d       	adc	r25, r15
    1d92:	12 dc       	rcall	.-2012   	; 0x15b8 <prvAddCurrentTaskToDelayedList>
    1d94:	1f 91       	pop	r17
    1d96:	0f 91       	pop	r16
    1d98:	ff 90       	pop	r15
    1d9a:	ef 90       	pop	r14
    1d9c:	df 90       	pop	r13
    1d9e:	cf 90       	pop	r12
    1da0:	08 95       	ret

00001da2 <xTaskRemoveFromEventList>:
    1da2:	0f 93       	push	r16
    1da4:	1f 93       	push	r17
    1da6:	cf 93       	push	r28
    1da8:	df 93       	push	r29
    1daa:	dc 01       	movw	r26, r24
    1dac:	17 96       	adiw	r26, 0x07	; 7
    1dae:	ed 91       	ld	r30, X+
    1db0:	fc 91       	ld	r31, X
    1db2:	18 97       	sbiw	r26, 0x08	; 8
    1db4:	c0 85       	ldd	r28, Z+8	; 0x08
    1db6:	d1 85       	ldd	r29, Z+9	; 0x09
    1db8:	8e 01       	movw	r16, r28
    1dba:	02 5f       	subi	r16, 0xF2	; 242
    1dbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1dbe:	c8 01       	movw	r24, r16
    1dc0:	0e 94 bb 06 	call	0xd76	; 0xd76 <uxListRemove>
    1dc4:	80 91 d4 0e 	lds	r24, 0x0ED4	; 0x800ed4 <uxSchedulerSuspended>
    1dc8:	81 11       	cpse	r24, r1
    1dca:	16 c0       	rjmp	.+44     	; 0x1df8 <xTaskRemoveFromEventList+0x56>
    1dcc:	0c 50       	subi	r16, 0x0C	; 12
    1dce:	11 09       	sbc	r17, r1
    1dd0:	c8 01       	movw	r24, r16
    1dd2:	0e 94 bb 06 	call	0xd76	; 0xd76 <uxListRemove>
    1dd6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dd8:	90 91 da 0e 	lds	r25, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1ddc:	98 17       	cp	r25, r24
    1dde:	10 f4       	brcc	.+4      	; 0x1de4 <xTaskRemoveFromEventList+0x42>
    1de0:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    1de4:	bb e0       	ldi	r27, 0x0B	; 11
    1de6:	8b 9f       	mul	r24, r27
    1de8:	c0 01       	movw	r24, r0
    1dea:	11 24       	eor	r1, r1
    1dec:	b8 01       	movw	r22, r16
    1dee:	8f 5e       	subi	r24, 0xEF	; 239
    1df0:	90 4f       	sbci	r25, 0xF0	; 240
    1df2:	0e 94 5d 06 	call	0xcba	; 0xcba <vListInsertEnd>
    1df6:	05 c0       	rjmp	.+10     	; 0x1e02 <xTaskRemoveFromEventList+0x60>
    1df8:	b8 01       	movw	r22, r16
    1dfa:	8c ee       	ldi	r24, 0xEC	; 236
    1dfc:	9e e0       	ldi	r25, 0x0E	; 14
    1dfe:	0e 94 5d 06 	call	0xcba	; 0xcba <vListInsertEnd>
    1e02:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    1e06:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1e0a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e0e:	89 17       	cp	r24, r25
    1e10:	20 f4       	brcc	.+8      	; 0x1e1a <xTaskRemoveFromEventList+0x78>
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	80 93 d7 0e 	sts	0x0ED7, r24	; 0x800ed7 <xYieldPending>
    1e18:	01 c0       	rjmp	.+2      	; 0x1e1c <xTaskRemoveFromEventList+0x7a>
    1e1a:	80 e0       	ldi	r24, 0x00	; 0
    1e1c:	df 91       	pop	r29
    1e1e:	cf 91       	pop	r28
    1e20:	1f 91       	pop	r17
    1e22:	0f 91       	pop	r16
    1e24:	08 95       	ret

00001e26 <xTaskRemoveFromUnorderedEventList>:
    1e26:	0f 93       	push	r16
    1e28:	1f 93       	push	r17
    1e2a:	cf 93       	push	r28
    1e2c:	df 93       	push	r29
    1e2e:	70 68       	ori	r23, 0x80	; 128
    1e30:	fc 01       	movw	r30, r24
    1e32:	40 83       	st	Z, r20
    1e34:	51 83       	std	Z+1, r21	; 0x01
    1e36:	62 83       	std	Z+2, r22	; 0x02
    1e38:	73 83       	std	Z+3, r23	; 0x03
    1e3a:	c0 85       	ldd	r28, Z+8	; 0x08
    1e3c:	d1 85       	ldd	r29, Z+9	; 0x09
    1e3e:	0e 94 bb 06 	call	0xd76	; 0xd76 <uxListRemove>
    1e42:	8e 01       	movw	r16, r28
    1e44:	0e 5f       	subi	r16, 0xFE	; 254
    1e46:	1f 4f       	sbci	r17, 0xFF	; 255
    1e48:	c8 01       	movw	r24, r16
    1e4a:	0e 94 bb 06 	call	0xd76	; 0xd76 <uxListRemove>
    1e4e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e50:	90 91 da 0e 	lds	r25, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1e54:	98 17       	cp	r25, r24
    1e56:	10 f4       	brcc	.+4      	; 0x1e5c <xTaskRemoveFromUnorderedEventList+0x36>
    1e58:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    1e5c:	fb e0       	ldi	r31, 0x0B	; 11
    1e5e:	8f 9f       	mul	r24, r31
    1e60:	c0 01       	movw	r24, r0
    1e62:	11 24       	eor	r1, r1
    1e64:	b8 01       	movw	r22, r16
    1e66:	8f 5e       	subi	r24, 0xEF	; 239
    1e68:	90 4f       	sbci	r25, 0xF0	; 240
    1e6a:	0e 94 5d 06 	call	0xcba	; 0xcba <vListInsertEnd>
    1e6e:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    1e72:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1e76:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e78:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e7a:	89 17       	cp	r24, r25
    1e7c:	20 f4       	brcc	.+8      	; 0x1e86 <xTaskRemoveFromUnorderedEventList+0x60>
    1e7e:	81 e0       	ldi	r24, 0x01	; 1
    1e80:	80 93 d7 0e 	sts	0x0ED7, r24	; 0x800ed7 <xYieldPending>
    1e84:	01 c0       	rjmp	.+2      	; 0x1e88 <xTaskRemoveFromUnorderedEventList+0x62>
    1e86:	80 e0       	ldi	r24, 0x00	; 0
    1e88:	df 91       	pop	r29
    1e8a:	cf 91       	pop	r28
    1e8c:	1f 91       	pop	r17
    1e8e:	0f 91       	pop	r16
    1e90:	08 95       	ret

00001e92 <vTaskSetTimeOutState>:
    1e92:	20 91 d6 0e 	lds	r18, 0x0ED6	; 0x800ed6 <xNumOfOverflows>
    1e96:	fc 01       	movw	r30, r24
    1e98:	20 83       	st	Z, r18
    1e9a:	40 91 db 0e 	lds	r20, 0x0EDB	; 0x800edb <xTickCount>
    1e9e:	50 91 dc 0e 	lds	r21, 0x0EDC	; 0x800edc <xTickCount+0x1>
    1ea2:	60 91 dd 0e 	lds	r22, 0x0EDD	; 0x800edd <xTickCount+0x2>
    1ea6:	70 91 de 0e 	lds	r23, 0x0EDE	; 0x800ede <xTickCount+0x3>
    1eaa:	41 83       	std	Z+1, r20	; 0x01
    1eac:	52 83       	std	Z+2, r21	; 0x02
    1eae:	63 83       	std	Z+3, r22	; 0x03
    1eb0:	74 83       	std	Z+4, r23	; 0x04
    1eb2:	08 95       	ret

00001eb4 <xTaskCheckForTimeOut>:
    1eb4:	8f 92       	push	r8
    1eb6:	9f 92       	push	r9
    1eb8:	af 92       	push	r10
    1eba:	bf 92       	push	r11
    1ebc:	cf 92       	push	r12
    1ebe:	df 92       	push	r13
    1ec0:	ef 92       	push	r14
    1ec2:	ff 92       	push	r15
    1ec4:	0f 93       	push	r16
    1ec6:	1f 93       	push	r17
    1ec8:	fc 01       	movw	r30, r24
    1eca:	db 01       	movw	r26, r22
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	0f 92       	push	r0
    1ed2:	40 91 db 0e 	lds	r20, 0x0EDB	; 0x800edb <xTickCount>
    1ed6:	50 91 dc 0e 	lds	r21, 0x0EDC	; 0x800edc <xTickCount+0x1>
    1eda:	60 91 dd 0e 	lds	r22, 0x0EDD	; 0x800edd <xTickCount+0x2>
    1ede:	70 91 de 0e 	lds	r23, 0x0EDE	; 0x800ede <xTickCount+0x3>
    1ee2:	80 91 d6 0e 	lds	r24, 0x0ED6	; 0x800ed6 <xNumOfOverflows>
    1ee6:	90 81       	ld	r25, Z
    1ee8:	98 17       	cp	r25, r24
    1eea:	49 f0       	breq	.+18     	; 0x1efe <xTaskCheckForTimeOut+0x4a>
    1eec:	01 81       	ldd	r16, Z+1	; 0x01
    1eee:	12 81       	ldd	r17, Z+2	; 0x02
    1ef0:	23 81       	ldd	r18, Z+3	; 0x03
    1ef2:	34 81       	ldd	r19, Z+4	; 0x04
    1ef4:	40 17       	cp	r20, r16
    1ef6:	51 07       	cpc	r21, r17
    1ef8:	62 07       	cpc	r22, r18
    1efa:	73 07       	cpc	r23, r19
    1efc:	28 f5       	brcc	.+74     	; 0x1f48 <xTaskCheckForTimeOut+0x94>
    1efe:	c1 80       	ldd	r12, Z+1	; 0x01
    1f00:	d2 80       	ldd	r13, Z+2	; 0x02
    1f02:	e3 80       	ldd	r14, Z+3	; 0x03
    1f04:	f4 80       	ldd	r15, Z+4	; 0x04
    1f06:	0d 91       	ld	r16, X+
    1f08:	1d 91       	ld	r17, X+
    1f0a:	2d 91       	ld	r18, X+
    1f0c:	3c 91       	ld	r19, X
    1f0e:	13 97       	sbiw	r26, 0x03	; 3
    1f10:	4a 01       	movw	r8, r20
    1f12:	5b 01       	movw	r10, r22
    1f14:	8c 18       	sub	r8, r12
    1f16:	9d 08       	sbc	r9, r13
    1f18:	ae 08       	sbc	r10, r14
    1f1a:	bf 08       	sbc	r11, r15
    1f1c:	80 16       	cp	r8, r16
    1f1e:	91 06       	cpc	r9, r17
    1f20:	a2 06       	cpc	r10, r18
    1f22:	b3 06       	cpc	r11, r19
    1f24:	98 f4       	brcc	.+38     	; 0x1f4c <xTaskCheckForTimeOut+0x98>
    1f26:	cf 01       	movw	r24, r30
    1f28:	c4 1a       	sub	r12, r20
    1f2a:	d5 0a       	sbc	r13, r21
    1f2c:	e6 0a       	sbc	r14, r22
    1f2e:	f7 0a       	sbc	r15, r23
    1f30:	0c 0d       	add	r16, r12
    1f32:	1d 1d       	adc	r17, r13
    1f34:	2e 1d       	adc	r18, r14
    1f36:	3f 1d       	adc	r19, r15
    1f38:	0d 93       	st	X+, r16
    1f3a:	1d 93       	st	X+, r17
    1f3c:	2d 93       	st	X+, r18
    1f3e:	3c 93       	st	X, r19
    1f40:	13 97       	sbiw	r26, 0x03	; 3
    1f42:	a7 df       	rcall	.-178    	; 0x1e92 <vTaskSetTimeOutState>
    1f44:	80 e0       	ldi	r24, 0x00	; 0
    1f46:	03 c0       	rjmp	.+6      	; 0x1f4e <xTaskCheckForTimeOut+0x9a>
    1f48:	81 e0       	ldi	r24, 0x01	; 1
    1f4a:	01 c0       	rjmp	.+2      	; 0x1f4e <xTaskCheckForTimeOut+0x9a>
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	0f 90       	pop	r0
    1f50:	0f be       	out	0x3f, r0	; 63
    1f52:	1f 91       	pop	r17
    1f54:	0f 91       	pop	r16
    1f56:	ff 90       	pop	r15
    1f58:	ef 90       	pop	r14
    1f5a:	df 90       	pop	r13
    1f5c:	cf 90       	pop	r12
    1f5e:	bf 90       	pop	r11
    1f60:	af 90       	pop	r10
    1f62:	9f 90       	pop	r9
    1f64:	8f 90       	pop	r8
    1f66:	08 95       	ret

00001f68 <vTaskMissedYield>:
    1f68:	81 e0       	ldi	r24, 0x01	; 1
    1f6a:	80 93 d7 0e 	sts	0x0ED7, r24	; 0x800ed7 <xYieldPending>
    1f6e:	08 95       	ret

00001f70 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1f70:	0f 93       	push	r16
    1f72:	1f 93       	push	r17
    1f74:	cf 93       	push	r28
    1f76:	df 93       	push	r29
    1f78:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1f7a:	89 2b       	or	r24, r25
    1f7c:	09 f4       	brne	.+2      	; 0x1f80 <vTaskPriorityInherit+0x10>
    1f7e:	51 c0       	rjmp	.+162    	; 0x2022 <vTaskPriorityInherit+0xb2>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1f80:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f82:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
    1f86:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1f8a:	5a 96       	adiw	r26, 0x1a	; 26
    1f8c:	9c 91       	ld	r25, X
    1f8e:	89 17       	cp	r24, r25
    1f90:	08 f0       	brcs	.+2      	; 0x1f94 <vTaskPriorityInherit+0x24>
    1f92:	47 c0       	rjmp	.+142    	; 0x2022 <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1f94:	46 85       	ldd	r20, Z+14	; 0x0e
    1f96:	57 85       	ldd	r21, Z+15	; 0x0f
    1f98:	60 89       	ldd	r22, Z+16	; 0x10
    1f9a:	71 89       	ldd	r23, Z+17	; 0x11
    1f9c:	77 23       	and	r23, r23
    1f9e:	94 f0       	brlt	.+36     	; 0x1fc4 <vTaskPriorityInherit+0x54>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1fa0:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
    1fa4:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1fa8:	5a 96       	adiw	r26, 0x1a	; 26
    1faa:	9c 91       	ld	r25, X
    1fac:	44 e1       	ldi	r20, 0x14	; 20
    1fae:	50 e0       	ldi	r21, 0x00	; 0
    1fb0:	60 e0       	ldi	r22, 0x00	; 0
    1fb2:	70 e0       	ldi	r23, 0x00	; 0
    1fb4:	49 1b       	sub	r20, r25
    1fb6:	51 09       	sbc	r21, r1
    1fb8:	61 09       	sbc	r22, r1
    1fba:	71 09       	sbc	r23, r1
    1fbc:	46 87       	std	Z+14, r20	; 0x0e
    1fbe:	57 87       	std	Z+15, r21	; 0x0f
    1fc0:	60 8b       	std	Z+16, r22	; 0x10
    1fc2:	71 8b       	std	Z+17, r23	; 0x11
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1fc4:	2b e0       	ldi	r18, 0x0B	; 11
    1fc6:	82 9f       	mul	r24, r18
    1fc8:	c0 01       	movw	r24, r0
    1fca:	11 24       	eor	r1, r1
    1fcc:	8f 5e       	subi	r24, 0xEF	; 239
    1fce:	90 4f       	sbci	r25, 0xF0	; 240
    1fd0:	24 85       	ldd	r18, Z+12	; 0x0c
    1fd2:	35 85       	ldd	r19, Z+13	; 0x0d
    1fd4:	28 17       	cp	r18, r24
    1fd6:	39 07       	cpc	r19, r25
    1fd8:	e9 f4       	brne	.+58     	; 0x2014 <vTaskPriorityInherit+0xa4>
    1fda:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1fdc:	ef 01       	movw	r28, r30
    1fde:	22 96       	adiw	r28, 0x02	; 2
    1fe0:	ce 01       	movw	r24, r28
    1fe2:	0e 94 bb 06 	call	0xd76	; 0xd76 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1fe6:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    1fea:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    1fee:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ff0:	f8 01       	movw	r30, r16
    1ff2:	82 8f       	std	Z+26, r24	; 0x1a
					prvAddTaskToReadyList( pxTCB );
    1ff4:	90 91 da 0e 	lds	r25, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    1ff8:	98 17       	cp	r25, r24
    1ffa:	10 f4       	brcc	.+4      	; 0x2000 <vTaskPriorityInherit+0x90>
    1ffc:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    2000:	fb e0       	ldi	r31, 0x0B	; 11
    2002:	8f 9f       	mul	r24, r31
    2004:	c0 01       	movw	r24, r0
    2006:	11 24       	eor	r1, r1
    2008:	be 01       	movw	r22, r28
    200a:	8f 5e       	subi	r24, 0xEF	; 239
    200c:	90 4f       	sbci	r25, 0xF0	; 240
    200e:	0e 94 5d 06 	call	0xcba	; 0xcba <vListInsertEnd>
    2012:	07 c0       	rjmp	.+14     	; 0x2022 <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2014:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
    2018:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    201c:	5a 96       	adiw	r26, 0x1a	; 26
    201e:	8c 91       	ld	r24, X
    2020:	82 8f       	std	Z+26, r24	; 0x1a
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2022:	df 91       	pop	r29
    2024:	cf 91       	pop	r28
    2026:	1f 91       	pop	r17
    2028:	0f 91       	pop	r16
    202a:	08 95       	ret

0000202c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    202c:	0f 93       	push	r16
    202e:	1f 93       	push	r17
    2030:	cf 93       	push	r28
    2032:	df 93       	push	r29
    2034:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    2036:	89 2b       	or	r24, r25
    2038:	79 f1       	breq	.+94     	; 0x2098 <xTaskPriorityDisinherit+0x6c>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    203a:	82 a9       	ldd	r24, Z+50	; 0x32
    203c:	81 50       	subi	r24, 0x01	; 1
    203e:	82 ab       	std	Z+50, r24	; 0x32

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2040:	22 8d       	ldd	r18, Z+26	; 0x1a
    2042:	91 a9       	ldd	r25, Z+49	; 0x31
    2044:	29 17       	cp	r18, r25
    2046:	51 f1       	breq	.+84     	; 0x209c <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2048:	81 11       	cpse	r24, r1
    204a:	2a c0       	rjmp	.+84     	; 0x20a0 <xTaskPriorityDisinherit+0x74>
    204c:	ef 01       	movw	r28, r30
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    204e:	8f 01       	movw	r16, r30
    2050:	0e 5f       	subi	r16, 0xFE	; 254
    2052:	1f 4f       	sbci	r17, 0xFF	; 255
    2054:	c8 01       	movw	r24, r16
    2056:	0e 94 bb 06 	call	0xd76	; 0xd76 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    205a:	89 a9       	ldd	r24, Y+49	; 0x31
    205c:	8a 8f       	std	Y+26, r24	; 0x1a

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    205e:	44 e1       	ldi	r20, 0x14	; 20
    2060:	50 e0       	ldi	r21, 0x00	; 0
    2062:	60 e0       	ldi	r22, 0x00	; 0
    2064:	70 e0       	ldi	r23, 0x00	; 0
    2066:	48 1b       	sub	r20, r24
    2068:	51 09       	sbc	r21, r1
    206a:	61 09       	sbc	r22, r1
    206c:	71 09       	sbc	r23, r1
    206e:	4e 87       	std	Y+14, r20	; 0x0e
    2070:	5f 87       	std	Y+15, r21	; 0x0f
    2072:	68 8b       	std	Y+16, r22	; 0x10
    2074:	79 8b       	std	Y+17, r23	; 0x11
					prvAddTaskToReadyList( pxTCB );
    2076:	90 91 da 0e 	lds	r25, 0x0EDA	; 0x800eda <uxTopReadyPriority>
    207a:	98 17       	cp	r25, r24
    207c:	10 f4       	brcc	.+4      	; 0x2082 <xTaskPriorityDisinherit+0x56>
    207e:	80 93 da 0e 	sts	0x0EDA, r24	; 0x800eda <uxTopReadyPriority>
    2082:	2b e0       	ldi	r18, 0x0B	; 11
    2084:	82 9f       	mul	r24, r18
    2086:	c0 01       	movw	r24, r0
    2088:	11 24       	eor	r1, r1
    208a:	b8 01       	movw	r22, r16
    208c:	8f 5e       	subi	r24, 0xEF	; 239
    208e:	90 4f       	sbci	r25, 0xF0	; 240
    2090:	0e 94 5d 06 	call	0xcba	; 0xcba <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    2094:	81 e0       	ldi	r24, 0x01	; 1
    2096:	05 c0       	rjmp	.+10     	; 0x20a2 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2098:	80 e0       	ldi	r24, 0x00	; 0
    209a:	03 c0       	rjmp	.+6      	; 0x20a2 <xTaskPriorityDisinherit+0x76>
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	01 c0       	rjmp	.+2      	; 0x20a2 <xTaskPriorityDisinherit+0x76>
    20a0:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    20a2:	df 91       	pop	r29
    20a4:	cf 91       	pop	r28
    20a6:	1f 91       	pop	r17
    20a8:	0f 91       	pop	r16
    20aa:	08 95       	ret

000020ac <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    20ac:	cf 92       	push	r12
    20ae:	df 92       	push	r13
    20b0:	ef 92       	push	r14
    20b2:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    20b4:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    20b8:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    20bc:	66 85       	ldd	r22, Z+14	; 0x0e
    20be:	77 85       	ldd	r23, Z+15	; 0x0f
    20c0:	80 89       	ldd	r24, Z+16	; 0x10
    20c2:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20c4:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    20c8:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    20cc:	a0 91 ed 0f 	lds	r26, 0x0FED	; 0x800fed <pxCurrentTCB>
    20d0:	b0 91 ee 0f 	lds	r27, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    20d4:	5a 96       	adiw	r26, 0x1a	; 26
    20d6:	2c 91       	ld	r18, X
    20d8:	0f 2e       	mov	r0, r31
    20da:	f4 e1       	ldi	r31, 0x14	; 20
    20dc:	cf 2e       	mov	r12, r31
    20de:	d1 2c       	mov	r13, r1
    20e0:	e1 2c       	mov	r14, r1
    20e2:	f1 2c       	mov	r15, r1
    20e4:	f0 2d       	mov	r31, r0
    20e6:	c2 1a       	sub	r12, r18
    20e8:	d1 08       	sbc	r13, r1
    20ea:	e1 08       	sbc	r14, r1
    20ec:	f1 08       	sbc	r15, r1
    20ee:	c6 86       	std	Z+14, r12	; 0x0e
    20f0:	d7 86       	std	Z+15, r13	; 0x0f
    20f2:	e0 8a       	std	Z+16, r14	; 0x10
    20f4:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    20f6:	ff 90       	pop	r15
    20f8:	ef 90       	pop	r14
    20fa:	df 90       	pop	r13
    20fc:	cf 90       	pop	r12
    20fe:	08 95       	ret

00002100 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2100:	80 91 ed 0f 	lds	r24, 0x0FED	; 0x800fed <pxCurrentTCB>
    2104:	90 91 ee 0f 	lds	r25, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    2108:	89 2b       	or	r24, r25
    210a:	39 f0       	breq	.+14     	; 0x211a <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    210c:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <pxCurrentTCB>
    2110:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
    2114:	82 a9       	ldd	r24, Z+50	; 0x32
    2116:	8f 5f       	subi	r24, 0xFF	; 255
    2118:	82 ab       	std	Z+50, r24	; 0x32
		}

		return pxCurrentTCB;
    211a:	80 91 ed 0f 	lds	r24, 0x0FED	; 0x800fed <pxCurrentTCB>
    211e:	90 91 ee 0f 	lds	r25, 0x0FEE	; 0x800fee <pxCurrentTCB+0x1>
	}
    2122:	08 95       	ret

00002124 <sendUTFStr>:
    2124:	cf 93       	push	r28
    2126:	df 93       	push	r29
    2128:	ec 01       	movw	r28, r24
    212a:	60 e0       	ldi	r22, 0x00	; 0
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    2132:	fe 01       	movw	r30, r28
    2134:	01 90       	ld	r0, Z+
    2136:	00 20       	and	r0, r0
    2138:	e9 f7       	brne	.-6      	; 0x2134 <sendUTFStr+0x10>
    213a:	31 97       	sbiw	r30, 0x01	; 1
    213c:	bf 01       	movw	r22, r30
    213e:	6c 1b       	sub	r22, r28
    2140:	7d 0b       	sbc	r23, r29
    2142:	80 e0       	ldi	r24, 0x00	; 0
    2144:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    2148:	be 01       	movw	r22, r28
    214a:	80 e0       	ldi	r24, 0x00	; 0
    214c:	0e 94 9a 04 	call	0x934	; 0x934 <Uart_SendStr>
    2150:	df 91       	pop	r29
    2152:	cf 91       	pop	r28
    2154:	08 95       	ret

00002156 <MQTT_Connect>:
    2156:	ef 92       	push	r14
    2158:	ff 92       	push	r15
    215a:	0f 93       	push	r16
    215c:	1f 93       	push	r17
    215e:	cf 93       	push	r28
    2160:	df 93       	push	r29
    2162:	8c 01       	movw	r16, r24
    2164:	c0 e1       	ldi	r28, 0x10	; 16
    2166:	d1 e0       	ldi	r29, 0x01	; 1
    2168:	09 90       	ld	r0, Y+
    216a:	00 20       	and	r0, r0
    216c:	e9 f7       	brne	.-6      	; 0x2168 <MQTT_Connect+0x12>
    216e:	21 97       	sbiw	r28, 0x01	; 1
    2170:	ce 01       	movw	r24, r28
    2172:	80 51       	subi	r24, 0x10	; 16
    2174:	91 40       	sbci	r25, 0x01	; 1
    2176:	7c 01       	movw	r14, r24
    2178:	f8 01       	movw	r30, r16
    217a:	01 90       	ld	r0, Z+
    217c:	00 20       	and	r0, r0
    217e:	e9 f7       	brne	.-6      	; 0x217a <MQTT_Connect+0x24>
    2180:	31 97       	sbiw	r30, 0x01	; 1
    2182:	ef 01       	movw	r28, r30
    2184:	c0 1b       	sub	r28, r16
    2186:	d1 0b       	sbc	r29, r17
    2188:	60 e1       	ldi	r22, 0x10	; 16
    218a:	80 e0       	ldi	r24, 0x00	; 0
    218c:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    2190:	6c 2f       	mov	r22, r28
    2192:	6e 0d       	add	r22, r14
    2194:	68 5f       	subi	r22, 0xF8	; 248
    2196:	80 e0       	ldi	r24, 0x00	; 0
    2198:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    219c:	80 e1       	ldi	r24, 0x10	; 16
    219e:	91 e0       	ldi	r25, 0x01	; 1
    21a0:	c1 df       	rcall	.-126    	; 0x2124 <sendUTFStr>
    21a2:	64 e0       	ldi	r22, 0x04	; 4
    21a4:	80 e0       	ldi	r24, 0x00	; 0
    21a6:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    21aa:	62 e0       	ldi	r22, 0x02	; 2
    21ac:	80 e0       	ldi	r24, 0x00	; 0
    21ae:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    21b2:	6f ef       	ldi	r22, 0xFF	; 255
    21b4:	80 e0       	ldi	r24, 0x00	; 0
    21b6:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    21ba:	6f ef       	ldi	r22, 0xFF	; 255
    21bc:	80 e0       	ldi	r24, 0x00	; 0
    21be:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    21c2:	c8 01       	movw	r24, r16
    21c4:	af df       	rcall	.-162    	; 0x2124 <sendUTFStr>
    21c6:	df 91       	pop	r29
    21c8:	cf 91       	pop	r28
    21ca:	1f 91       	pop	r17
    21cc:	0f 91       	pop	r16
    21ce:	ff 90       	pop	r15
    21d0:	ef 90       	pop	r14
    21d2:	08 95       	ret

000021d4 <MQTT_Publish>:
    21d4:	cf 92       	push	r12
    21d6:	df 92       	push	r13
    21d8:	ef 92       	push	r14
    21da:	ff 92       	push	r15
    21dc:	0f 93       	push	r16
    21de:	1f 93       	push	r17
    21e0:	cf 93       	push	r28
    21e2:	df 93       	push	r29
    21e4:	6c 01       	movw	r12, r24
    21e6:	7b 01       	movw	r14, r22
    21e8:	14 2f       	mov	r17, r20
    21ea:	fc 01       	movw	r30, r24
    21ec:	01 90       	ld	r0, Z+
    21ee:	00 20       	and	r0, r0
    21f0:	e9 f7       	brne	.-6      	; 0x21ec <MQTT_Publish+0x18>
    21f2:	31 97       	sbiw	r30, 0x01	; 1
    21f4:	e8 1b       	sub	r30, r24
    21f6:	f9 0b       	sbc	r31, r25
    21f8:	c2 e0       	ldi	r28, 0x02	; 2
    21fa:	c4 0f       	add	r28, r20
    21fc:	ce 0f       	add	r28, r30
    21fe:	60 e3       	ldi	r22, 0x30	; 48
    2200:	80 e0       	ldi	r24, 0x00	; 0
    2202:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    2206:	6c 2f       	mov	r22, r28
    2208:	80 e0       	ldi	r24, 0x00	; 0
    220a:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    220e:	c6 01       	movw	r24, r12
    2210:	89 df       	rcall	.-238    	; 0x2124 <sendUTFStr>
    2212:	11 23       	and	r17, r17
    2214:	79 f0       	breq	.+30     	; 0x2234 <MQTT_Publish+0x60>
    2216:	e7 01       	movw	r28, r14
    2218:	11 50       	subi	r17, 0x01	; 1
    221a:	01 2f       	mov	r16, r17
    221c:	10 e0       	ldi	r17, 0x00	; 0
    221e:	0f 5f       	subi	r16, 0xFF	; 255
    2220:	1f 4f       	sbci	r17, 0xFF	; 255
    2222:	0e 0d       	add	r16, r14
    2224:	1f 1d       	adc	r17, r15
    2226:	69 91       	ld	r22, Y+
    2228:	80 e0       	ldi	r24, 0x00	; 0
    222a:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    222e:	c0 17       	cp	r28, r16
    2230:	d1 07       	cpc	r29, r17
    2232:	c9 f7       	brne	.-14     	; 0x2226 <MQTT_Publish+0x52>
    2234:	df 91       	pop	r29
    2236:	cf 91       	pop	r28
    2238:	1f 91       	pop	r17
    223a:	0f 91       	pop	r16
    223c:	ff 90       	pop	r15
    223e:	ef 90       	pop	r14
    2240:	df 90       	pop	r13
    2242:	cf 90       	pop	r12
    2244:	08 95       	ret

00002246 <MQTT_Subscribe>:
    2246:	0f 93       	push	r16
    2248:	1f 93       	push	r17
    224a:	cf 93       	push	r28
    224c:	df 93       	push	r29
    224e:	8c 01       	movw	r16, r24
    2250:	fc 01       	movw	r30, r24
    2252:	01 90       	ld	r0, Z+
    2254:	00 20       	and	r0, r0
    2256:	e9 f7       	brne	.-6      	; 0x2252 <MQTT_Subscribe+0xc>
    2258:	31 97       	sbiw	r30, 0x01	; 1
    225a:	ef 01       	movw	r28, r30
    225c:	c8 1b       	sub	r28, r24
    225e:	d9 0b       	sbc	r29, r25
    2260:	62 e8       	ldi	r22, 0x82	; 130
    2262:	80 e0       	ldi	r24, 0x00	; 0
    2264:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    2268:	6c 2f       	mov	r22, r28
    226a:	6b 5f       	subi	r22, 0xFB	; 251
    226c:	80 e0       	ldi	r24, 0x00	; 0
    226e:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    2272:	60 91 16 01 	lds	r22, 0x0116	; 0x800116 <PID+0x1>
    2276:	80 e0       	ldi	r24, 0x00	; 0
    2278:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    227c:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <PID>
    2280:	80 e0       	ldi	r24, 0x00	; 0
    2282:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    2286:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <PID>
    228a:	90 91 16 01 	lds	r25, 0x0116	; 0x800116 <PID+0x1>
    228e:	01 96       	adiw	r24, 0x01	; 1
    2290:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <PID+0x1>
    2294:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <PID>
    2298:	c8 01       	movw	r24, r16
    229a:	44 df       	rcall	.-376    	; 0x2124 <sendUTFStr>
    229c:	60 e0       	ldi	r22, 0x00	; 0
    229e:	80 e0       	ldi	r24, 0x00	; 0
    22a0:	0e 94 89 04 	call	0x912	; 0x912 <Uart_SendByte>
    22a4:	df 91       	pop	r29
    22a6:	cf 91       	pop	r28
    22a8:	1f 91       	pop	r17
    22aa:	0f 91       	pop	r16
    22ac:	08 95       	ret

000022ae <T_DisplayData>:

/**************** LCD Display Task ****************/


void	T_DisplayData		(void *pvinitData)
{
    22ae:	cf 93       	push	r28
    22b0:	df 93       	push	r29
    22b2:	cd b7       	in	r28, 0x3d	; 61
    22b4:	de b7       	in	r29, 0x3e	; 62
    22b6:	28 97       	sbiw	r28, 0x08	; 8
    22b8:	0f b6       	in	r0, 0x3f	; 63
    22ba:	f8 94       	cli
    22bc:	de bf       	out	0x3e, r29	; 62
    22be:	0f be       	out	0x3f, r0	; 63
    22c0:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		state=xEventGroupWaitBits(egEvents,(E_FireAlarmDisp|E_GetPassDisp|E_TempConfigDisp|E_MainDisp|E_CTempUpdate|E_CMoistUpdate|E_CHUMUpdate|E_CLightUpdate|E_UIDisp|E_SITDisp),1,0,150);
		if((state&E_MainDisp)==E_MainDisp)
		{
			if (SensorReading.LCDState==MAIN_STATE)
    22c2:	0f 2e       	mov	r0, r31
    22c4:	fc e1       	ldi	r31, 0x1C	; 28
    22c6:	af 2e       	mov	r10, r31
    22c8:	f1 e0       	ldi	r31, 0x01	; 1
    22ca:	bf 2e       	mov	r11, r31
    22cc:	f0 2d       	mov	r31, r0
		
		if((state&E_CMoistUpdate)==E_CMoistUpdate)
		{
			disp_strXY(1,12,(u8*)"   ");
			disp_intXY(1,12,SensorReading.C_MOIST);
			itoa(SensorReading.C_MOIST,moistPublish,10);
    22ce:	ce 01       	movw	r24, r28
    22d0:	01 96       	adiw	r24, 0x01	; 1
    22d2:	3c 01       	movw	r6, r24
		}
		if((state&E_CLightUpdate)==E_CLightUpdate)
		{
			disp_strXY(2,7,(u8*)"   ");
			disp_intXY(2,7,SensorReading.C_LDR);
			itoa(SensorReading.C_LDR,lightPublish,10);
    22d4:	4e 01       	movw	r8, r28
    22d6:	95 e0       	ldi	r25, 0x05	; 5
    22d8:	89 0e       	add	r8, r25
    22da:	91 1c       	adc	r9, r1
	u8 lightPublish[4];


	while(1)
	{
		state=xEventGroupWaitBits(egEvents,(E_FireAlarmDisp|E_GetPassDisp|E_TempConfigDisp|E_MainDisp|E_CTempUpdate|E_CMoistUpdate|E_CHUMUpdate|E_CLightUpdate|E_UIDisp|E_SITDisp),1,0,150);
    22dc:	0f 2e       	mov	r0, r31
    22de:	f6 e9       	ldi	r31, 0x96	; 150
    22e0:	cf 2e       	mov	r12, r31
    22e2:	d1 2c       	mov	r13, r1
    22e4:	e1 2c       	mov	r14, r1
    22e6:	f1 2c       	mov	r15, r1
    22e8:	f0 2d       	mov	r31, r0
    22ea:	00 e0       	ldi	r16, 0x00	; 0
    22ec:	21 e0       	ldi	r18, 0x01	; 1
    22ee:	4d ed       	ldi	r20, 0xDD	; 221
    22f0:	53 e6       	ldi	r21, 0x63	; 99
    22f2:	60 e0       	ldi	r22, 0x00	; 0
    22f4:	70 e0       	ldi	r23, 0x00	; 0
    22f6:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    22fa:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    22fe:	0e 94 bf 04 	call	0x97e	; 0x97e <xEventGroupWaitBits>
    2302:	6b 01       	movw	r12, r22
    2304:	7c 01       	movw	r14, r24
		if((state&E_MainDisp)==E_MainDisp)
    2306:	71 ff       	sbrs	r23, 1
    2308:	3a c0       	rjmp	.+116    	; 0x237e <T_DisplayData+0xd0>
		{
			if (SensorReading.LCDState==MAIN_STATE)
    230a:	f5 01       	movw	r30, r10
    230c:	81 a9       	ldd	r24, Z+49	; 0x31
    230e:	81 11       	cpse	r24, r1
    2310:	d4 c0       	rjmp	.+424    	; 0x24ba <T_DisplayData+0x20c>
			{
				disp_strXY(1,1,MAIN_L1);
    2312:	46 e5       	ldi	r20, 0x56	; 86
    2314:	51 e0       	ldi	r21, 0x01	; 1
    2316:	61 e0       	ldi	r22, 0x01	; 1
    2318:	81 e0       	ldi	r24, 0x01	; 1
    231a:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
				disp_intXY(1,12,SensorReading.C_MOIST);
    231e:	f5 01       	movw	r30, r10
    2320:	25 a5       	ldd	r18, Z+45	; 0x2d
    2322:	30 e0       	ldi	r19, 0x00	; 0
    2324:	40 e0       	ldi	r20, 0x00	; 0
    2326:	50 e0       	ldi	r21, 0x00	; 0
    2328:	6c e0       	ldi	r22, 0x0C	; 12
    232a:	81 e0       	ldi	r24, 0x01	; 1
    232c:	0e 94 bb 02 	call	0x576	; 0x576 <disp_intXY>
				disp_strXY(2,1,MAIN_L2);
    2330:	47 e6       	ldi	r20, 0x67	; 103
    2332:	51 e0       	ldi	r21, 0x01	; 1
    2334:	61 e0       	ldi	r22, 0x01	; 1
    2336:	82 e0       	ldi	r24, 0x02	; 2
    2338:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
				disp_intXY(2,7,SensorReading.C_LDR);
    233c:	f5 01       	movw	r30, r10
    233e:	27 a5       	ldd	r18, Z+47	; 0x2f
    2340:	30 e0       	ldi	r19, 0x00	; 0
    2342:	40 e0       	ldi	r20, 0x00	; 0
    2344:	50 e0       	ldi	r21, 0x00	; 0
    2346:	67 e0       	ldi	r22, 0x07	; 7
    2348:	82 e0       	ldi	r24, 0x02	; 2
    234a:	0e 94 bb 02 	call	0x576	; 0x576 <disp_intXY>
				disp_strXY(3,1,MAIN_L3);
    234e:	48 e7       	ldi	r20, 0x78	; 120
    2350:	51 e0       	ldi	r21, 0x01	; 1
    2352:	61 e0       	ldi	r22, 0x01	; 1
    2354:	83 e0       	ldi	r24, 0x03	; 3
    2356:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
				disp_strXY(3,7,SensorReading.C_HUM);
    235a:	4a e3       	ldi	r20, 0x3A	; 58
    235c:	51 e0       	ldi	r21, 0x01	; 1
    235e:	67 e0       	ldi	r22, 0x07	; 7
    2360:	83 e0       	ldi	r24, 0x03	; 3
    2362:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
				disp_strXY(4,1,MAIN_L4);
    2366:	49 e8       	ldi	r20, 0x89	; 137
    2368:	51 e0       	ldi	r21, 0x01	; 1
    236a:	61 e0       	ldi	r22, 0x01	; 1
    236c:	84 e0       	ldi	r24, 0x04	; 4
    236e:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
				disp_strXY(4,6,SensorReading.C_TEMP);
    2372:	a5 01       	movw	r20, r10
    2374:	66 e0       	ldi	r22, 0x06	; 6
    2376:	84 e0       	ldi	r24, 0x04	; 4
    2378:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
    237c:	9e c0       	rjmp	.+316    	; 0x24ba <T_DisplayData+0x20c>
			}
		}
		else if((state&E_UIDisp)==E_UIDisp)
    237e:	75 ff       	sbrs	r23, 5
    2380:	19 c0       	rjmp	.+50     	; 0x23b4 <T_DisplayData+0x106>
		{
			disp_strXY(1,1,UI_L1);
    2382:	4a e9       	ldi	r20, 0x9A	; 154
    2384:	51 e0       	ldi	r21, 0x01	; 1
    2386:	61 e0       	ldi	r22, 0x01	; 1
    2388:	81 e0       	ldi	r24, 0x01	; 1
    238a:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,1,UI_L2);
    238e:	4b ea       	ldi	r20, 0xAB	; 171
    2390:	51 e0       	ldi	r21, 0x01	; 1
    2392:	61 e0       	ldi	r22, 0x01	; 1
    2394:	82 e0       	ldi	r24, 0x02	; 2
    2396:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(3,1,UI_L3);
    239a:	4c eb       	ldi	r20, 0xBC	; 188
    239c:	51 e0       	ldi	r21, 0x01	; 1
    239e:	61 e0       	ldi	r22, 0x01	; 1
    23a0:	83 e0       	ldi	r24, 0x03	; 3
    23a2:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,1,UI_L4);
    23a6:	4d ec       	ldi	r20, 0xCD	; 205
    23a8:	51 e0       	ldi	r21, 0x01	; 1
    23aa:	61 e0       	ldi	r22, 0x01	; 1
    23ac:	84 e0       	ldi	r24, 0x04	; 4
    23ae:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
    23b2:	83 c0       	rjmp	.+262    	; 0x24ba <T_DisplayData+0x20c>
		}
		else if((state&E_SITDisp)==E_SITDisp)
    23b4:	76 ff       	sbrs	r23, 6
    23b6:	19 c0       	rjmp	.+50     	; 0x23ea <T_DisplayData+0x13c>
		{
			disp_strXY(1,1,SETTING_L1);
    23b8:	4e ed       	ldi	r20, 0xDE	; 222
    23ba:	51 e0       	ldi	r21, 0x01	; 1
    23bc:	61 e0       	ldi	r22, 0x01	; 1
    23be:	81 e0       	ldi	r24, 0x01	; 1
    23c0:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,1,SETTING_L2);
    23c4:	4f ee       	ldi	r20, 0xEF	; 239
    23c6:	51 e0       	ldi	r21, 0x01	; 1
    23c8:	61 e0       	ldi	r22, 0x01	; 1
    23ca:	82 e0       	ldi	r24, 0x02	; 2
    23cc:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(3,1,SETTING_L3);
    23d0:	40 e0       	ldi	r20, 0x00	; 0
    23d2:	52 e0       	ldi	r21, 0x02	; 2
    23d4:	61 e0       	ldi	r22, 0x01	; 1
    23d6:	83 e0       	ldi	r24, 0x03	; 3
    23d8:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,1,SETTING_L4);
    23dc:	4d ec       	ldi	r20, 0xCD	; 205
    23de:	51 e0       	ldi	r21, 0x01	; 1
    23e0:	61 e0       	ldi	r22, 0x01	; 1
    23e2:	84 e0       	ldi	r24, 0x04	; 4
    23e4:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
    23e8:	68 c0       	rjmp	.+208    	; 0x24ba <T_DisplayData+0x20c>
		}
		else if((state&E_TempConfigDisp)==E_TempConfigDisp)
    23ea:	70 ff       	sbrs	r23, 0
    23ec:	25 c0       	rjmp	.+74     	; 0x2438 <T_DisplayData+0x18a>
		{
			disp_strXY(1,1,GetTemp_L1);
    23ee:	41 e1       	ldi	r20, 0x11	; 17
    23f0:	52 e0       	ldi	r21, 0x02	; 2
    23f2:	61 e0       	ldi	r22, 0x01	; 1
    23f4:	81 e0       	ldi	r24, 0x01	; 1
    23f6:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,1,GetTemp_L2);
    23fa:	4c eb       	ldi	r20, 0xBC	; 188
    23fc:	51 e0       	ldi	r21, 0x01	; 1
    23fe:	61 e0       	ldi	r22, 0x01	; 1
    2400:	82 e0       	ldi	r24, 0x02	; 2
    2402:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,9,(u8*)"old=");
    2406:	42 e2       	ldi	r20, 0x22	; 34
    2408:	52 e0       	ldi	r21, 0x02	; 2
    240a:	69 e0       	ldi	r22, 0x09	; 9
    240c:	82 e0       	ldi	r24, 0x02	; 2
    240e:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,13,SensorReading.T_TEMP);
    2412:	4b e2       	ldi	r20, 0x2B	; 43
    2414:	51 e0       	ldi	r21, 0x01	; 1
    2416:	6d e0       	ldi	r22, 0x0D	; 13
    2418:	82 e0       	ldi	r24, 0x02	; 2
    241a:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(3,1,GetTemp_L3);
    241e:	47 e2       	ldi	r20, 0x27	; 39
    2420:	52 e0       	ldi	r21, 0x02	; 2
    2422:	61 e0       	ldi	r22, 0x01	; 1
    2424:	83 e0       	ldi	r24, 0x03	; 3
    2426:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,1,GetTemp_L4);
    242a:	4d ec       	ldi	r20, 0xCD	; 205
    242c:	51 e0       	ldi	r21, 0x01	; 1
    242e:	61 e0       	ldi	r22, 0x01	; 1
    2430:	84 e0       	ldi	r24, 0x04	; 4
    2432:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
    2436:	41 c0       	rjmp	.+130    	; 0x24ba <T_DisplayData+0x20c>
		}
		else if((state&E_GetPassDisp)==E_GetPassDisp)
    2438:	67 ff       	sbrs	r22, 7
    243a:	19 c0       	rjmp	.+50     	; 0x246e <T_DisplayData+0x1c0>
		{
			disp_strXY(1,1,Getpass_L1);
    243c:	48 e3       	ldi	r20, 0x38	; 56
    243e:	52 e0       	ldi	r21, 0x02	; 2
    2440:	61 e0       	ldi	r22, 0x01	; 1
    2442:	81 e0       	ldi	r24, 0x01	; 1
    2444:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,1,Getpass_L2);
    2448:	4c eb       	ldi	r20, 0xBC	; 188
    244a:	51 e0       	ldi	r21, 0x01	; 1
    244c:	61 e0       	ldi	r22, 0x01	; 1
    244e:	82 e0       	ldi	r24, 0x02	; 2
    2450:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(3,1,Getpass_L3);
    2454:	47 e2       	ldi	r20, 0x27	; 39
    2456:	52 e0       	ldi	r21, 0x02	; 2
    2458:	61 e0       	ldi	r22, 0x01	; 1
    245a:	83 e0       	ldi	r24, 0x03	; 3
    245c:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,1,Getpass_L4);
    2460:	4d ec       	ldi	r20, 0xCD	; 205
    2462:	51 e0       	ldi	r21, 0x01	; 1
    2464:	61 e0       	ldi	r22, 0x01	; 1
    2466:	84 e0       	ldi	r24, 0x04	; 4
    2468:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
    246c:	26 c0       	rjmp	.+76     	; 0x24ba <T_DisplayData+0x20c>
		}
		else if((state&E_FireAlarmDisp)==E_FireAlarmDisp)
    246e:	66 ff       	sbrs	r22, 6
    2470:	24 c0       	rjmp	.+72     	; 0x24ba <T_DisplayData+0x20c>
		{
			disp_strXY(1,1,ALARM_L1);
    2472:	49 e4       	ldi	r20, 0x49	; 73
    2474:	52 e0       	ldi	r21, 0x02	; 2
    2476:	61 e0       	ldi	r22, 0x01	; 1
    2478:	81 e0       	ldi	r24, 0x01	; 1
    247a:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,1,ALARM_L2);
    247e:	4a e5       	ldi	r20, 0x5A	; 90
    2480:	52 e0       	ldi	r21, 0x02	; 2
    2482:	61 e0       	ldi	r22, 0x01	; 1
    2484:	82 e0       	ldi	r24, 0x02	; 2
    2486:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(3,1,ALARM_L3);
    248a:	4b e6       	ldi	r20, 0x6B	; 107
    248c:	52 e0       	ldi	r21, 0x02	; 2
    248e:	61 e0       	ldi	r22, 0x01	; 1
    2490:	83 e0       	ldi	r24, 0x03	; 3
    2492:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,1,ALARM_L4);
    2496:	49 e4       	ldi	r20, 0x49	; 73
    2498:	52 e0       	ldi	r21, 0x02	; 2
    249a:	61 e0       	ldi	r22, 0x01	; 1
    249c:	84 e0       	ldi	r24, 0x04	; 4
    249e:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			vTaskDelay(700);
    24a2:	6c eb       	ldi	r22, 0xBC	; 188
    24a4:	72 e0       	ldi	r23, 0x02	; 2
    24a6:	80 e0       	ldi	r24, 0x00	; 0
    24a8:	90 e0       	ldi	r25, 0x00	; 0
    24aa:	60 db       	rcall	.-2368   	; 0x1b6c <vTaskDelay>
			LCD_CLEAR();
    24ac:	0e 94 13 02 	call	0x426	; 0x426 <LCD_CLEAR>
			vTaskDelay(300);
    24b0:	6c e2       	ldi	r22, 0x2C	; 44
    24b2:	71 e0       	ldi	r23, 0x01	; 1
    24b4:	80 e0       	ldi	r24, 0x00	; 0
    24b6:	90 e0       	ldi	r25, 0x00	; 0
    24b8:	59 db       	rcall	.-2382   	; 0x1b6c <vTaskDelay>
		{}
		
		
		
		
		if((state&E_CMoistUpdate)==E_CMoistUpdate)
    24ba:	c2 fe       	sbrs	r12, 2
    24bc:	23 c0       	rjmp	.+70     	; 0x2504 <T_DisplayData+0x256>
		{
			disp_strXY(1,12,(u8*)"   ");
    24be:	49 ec       	ldi	r20, 0xC9	; 201
    24c0:	51 e0       	ldi	r21, 0x01	; 1
    24c2:	6c e0       	ldi	r22, 0x0C	; 12
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_intXY(1,12,SensorReading.C_MOIST);
    24ca:	f5 01       	movw	r30, r10
    24cc:	25 a5       	ldd	r18, Z+45	; 0x2d
    24ce:	30 e0       	ldi	r19, 0x00	; 0
    24d0:	40 e0       	ldi	r20, 0x00	; 0
    24d2:	50 e0       	ldi	r21, 0x00	; 0
    24d4:	6c e0       	ldi	r22, 0x0C	; 12
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	0e 94 bb 02 	call	0x576	; 0x576 <disp_intXY>
			itoa(SensorReading.C_MOIST,moistPublish,10);
    24dc:	f5 01       	movw	r30, r10
    24de:	85 a5       	ldd	r24, Z+45	; 0x2d
    24e0:	4a e0       	ldi	r20, 0x0A	; 10
    24e2:	50 e0       	ldi	r21, 0x00	; 0
    24e4:	b3 01       	movw	r22, r6
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	0e 94 be 1b 	call	0x377c	; 0x377c <itoa>
			MQTT_Publish((u8*)"G/soil",moistPublish,strlen((char*)moistPublish));
    24ec:	f3 01       	movw	r30, r6
    24ee:	01 90       	ld	r0, Z+
    24f0:	00 20       	and	r0, r0
    24f2:	e9 f7       	brne	.-6      	; 0x24ee <T_DisplayData+0x240>
    24f4:	31 97       	sbiw	r30, 0x01	; 1
    24f6:	af 01       	movw	r20, r30
    24f8:	46 19       	sub	r20, r6
    24fa:	57 09       	sbc	r21, r7
    24fc:	b3 01       	movw	r22, r6
    24fe:	8c e7       	ldi	r24, 0x7C	; 124
    2500:	92 e0       	ldi	r25, 0x02	; 2
    2502:	68 de       	rcall	.-816    	; 0x21d4 <MQTT_Publish>

		}
		if((state&E_CLightUpdate)==E_CLightUpdate)
    2504:	c4 fe       	sbrs	r12, 4
    2506:	23 c0       	rjmp	.+70     	; 0x254e <T_DisplayData+0x2a0>
		{
			disp_strXY(2,7,(u8*)"   ");
    2508:	49 ec       	ldi	r20, 0xC9	; 201
    250a:	51 e0       	ldi	r21, 0x01	; 1
    250c:	67 e0       	ldi	r22, 0x07	; 7
    250e:	82 e0       	ldi	r24, 0x02	; 2
    2510:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_intXY(2,7,SensorReading.C_LDR);
    2514:	f5 01       	movw	r30, r10
    2516:	27 a5       	ldd	r18, Z+47	; 0x2f
    2518:	30 e0       	ldi	r19, 0x00	; 0
    251a:	40 e0       	ldi	r20, 0x00	; 0
    251c:	50 e0       	ldi	r21, 0x00	; 0
    251e:	67 e0       	ldi	r22, 0x07	; 7
    2520:	82 e0       	ldi	r24, 0x02	; 2
    2522:	0e 94 bb 02 	call	0x576	; 0x576 <disp_intXY>
			itoa(SensorReading.C_LDR,lightPublish,10);
    2526:	f5 01       	movw	r30, r10
    2528:	87 a5       	ldd	r24, Z+47	; 0x2f
    252a:	4a e0       	ldi	r20, 0x0A	; 10
    252c:	50 e0       	ldi	r21, 0x00	; 0
    252e:	b4 01       	movw	r22, r8
    2530:	90 e0       	ldi	r25, 0x00	; 0
    2532:	0e 94 be 1b 	call	0x377c	; 0x377c <itoa>
			MQTT_Publish((u8*)"G/light",lightPublish,strlen((char*)lightPublish));
    2536:	f4 01       	movw	r30, r8
    2538:	01 90       	ld	r0, Z+
    253a:	00 20       	and	r0, r0
    253c:	e9 f7       	brne	.-6      	; 0x2538 <T_DisplayData+0x28a>
    253e:	31 97       	sbiw	r30, 0x01	; 1
    2540:	af 01       	movw	r20, r30
    2542:	48 19       	sub	r20, r8
    2544:	59 09       	sbc	r21, r9
    2546:	b4 01       	movw	r22, r8
    2548:	83 e8       	ldi	r24, 0x83	; 131
    254a:	92 e0       	ldi	r25, 0x02	; 2
    254c:	43 de       	rcall	.-890    	; 0x21d4 <MQTT_Publish>
		}
		if((state&E_CHUMUpdate)==E_CHUMUpdate)
    254e:	c3 fe       	sbrs	r12, 3
    2550:	19 c0       	rjmp	.+50     	; 0x2584 <T_DisplayData+0x2d6>
		{
			disp_strXY(3,7,(u8*)"   ");
    2552:	49 ec       	ldi	r20, 0xC9	; 201
    2554:	51 e0       	ldi	r21, 0x01	; 1
    2556:	67 e0       	ldi	r22, 0x07	; 7
    2558:	83 e0       	ldi	r24, 0x03	; 3
    255a:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(3,7,SensorReading.C_HUM);
    255e:	4a e3       	ldi	r20, 0x3A	; 58
    2560:	51 e0       	ldi	r21, 0x01	; 1
    2562:	67 e0       	ldi	r22, 0x07	; 7
    2564:	83 e0       	ldi	r24, 0x03	; 3
    2566:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			MQTT_Publish((u8*)"G/hum",SensorReading.C_HUM,strlen((char*)SensorReading.C_HUM));
    256a:	ea e3       	ldi	r30, 0x3A	; 58
    256c:	f1 e0       	ldi	r31, 0x01	; 1
    256e:	01 90       	ld	r0, Z+
    2570:	00 20       	and	r0, r0
    2572:	e9 f7       	brne	.-6      	; 0x256e <T_DisplayData+0x2c0>
    2574:	af 01       	movw	r20, r30
    2576:	4b 53       	subi	r20, 0x3B	; 59
    2578:	51 40       	sbci	r21, 0x01	; 1
    257a:	6a e3       	ldi	r22, 0x3A	; 58
    257c:	71 e0       	ldi	r23, 0x01	; 1
    257e:	8b e8       	ldi	r24, 0x8B	; 139
    2580:	92 e0       	ldi	r25, 0x02	; 2
    2582:	28 de       	rcall	.-944    	; 0x21d4 <MQTT_Publish>

		}
		if((state&E_CTempUpdate)==E_CTempUpdate)
    2584:	c0 fe       	sbrs	r12, 0
    2586:	17 c0       	rjmp	.+46     	; 0x25b6 <T_DisplayData+0x308>
		{
			disp_strXY(4,6,(u8*)"      ");
    2588:	46 ec       	ldi	r20, 0xC6	; 198
    258a:	51 e0       	ldi	r21, 0x01	; 1
    258c:	66 e0       	ldi	r22, 0x06	; 6
    258e:	84 e0       	ldi	r24, 0x04	; 4
    2590:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,6,SensorReading.C_TEMP);
    2594:	a5 01       	movw	r20, r10
    2596:	66 e0       	ldi	r22, 0x06	; 6
    2598:	84 e0       	ldi	r24, 0x04	; 4
    259a:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			MQTT_Publish((u8*)"G/temp",SensorReading.C_TEMP,strlen((char*)SensorReading.C_TEMP));
    259e:	f5 01       	movw	r30, r10
    25a0:	01 90       	ld	r0, Z+
    25a2:	00 20       	and	r0, r0
    25a4:	e9 f7       	brne	.-6      	; 0x25a0 <T_DisplayData+0x2f2>
    25a6:	31 97       	sbiw	r30, 0x01	; 1
    25a8:	af 01       	movw	r20, r30
    25aa:	4c 51       	subi	r20, 0x1C	; 28
    25ac:	51 40       	sbci	r21, 0x01	; 1
    25ae:	b5 01       	movw	r22, r10
    25b0:	81 e9       	ldi	r24, 0x91	; 145
    25b2:	92 e0       	ldi	r25, 0x02	; 2
    25b4:	0f de       	rcall	.-994    	; 0x21d4 <MQTT_Publish>
		}
		state=xEventGroupWaitBits(egEvents1,(E_MoistConigDisp|E_lightConigDisp),1,0,150);
    25b6:	0f 2e       	mov	r0, r31
    25b8:	f6 e9       	ldi	r31, 0x96	; 150
    25ba:	cf 2e       	mov	r12, r31
    25bc:	d1 2c       	mov	r13, r1
    25be:	e1 2c       	mov	r14, r1
    25c0:	f1 2c       	mov	r15, r1
    25c2:	f0 2d       	mov	r31, r0
    25c4:	00 e0       	ldi	r16, 0x00	; 0
    25c6:	21 e0       	ldi	r18, 0x01	; 1
    25c8:	43 e0       	ldi	r20, 0x03	; 3
    25ca:	50 e0       	ldi	r21, 0x00	; 0
    25cc:	60 e0       	ldi	r22, 0x00	; 0
    25ce:	70 e0       	ldi	r23, 0x00	; 0
    25d0:	80 91 f5 0f 	lds	r24, 0x0FF5	; 0x800ff5 <egEvents1>
    25d4:	90 91 f6 0f 	lds	r25, 0x0FF6	; 0x800ff6 <egEvents1+0x1>
    25d8:	0e 94 bf 04 	call	0x97e	; 0x97e <xEventGroupWaitBits>
		if((state&E_MoistConigDisp)==E_MoistConigDisp)
    25dc:	60 ff       	sbrs	r22, 0
    25de:	28 c0       	rjmp	.+80     	; 0x2630 <T_DisplayData+0x382>
		{
			disp_strXY(1,1,GetMoist_L1);
    25e0:	48 e9       	ldi	r20, 0x98	; 152
    25e2:	52 e0       	ldi	r21, 0x02	; 2
    25e4:	61 e0       	ldi	r22, 0x01	; 1
    25e6:	81 e0       	ldi	r24, 0x01	; 1
    25e8:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,1,GetMoist_L2);
    25ec:	4c eb       	ldi	r20, 0xBC	; 188
    25ee:	51 e0       	ldi	r21, 0x01	; 1
    25f0:	61 e0       	ldi	r22, 0x01	; 1
    25f2:	82 e0       	ldi	r24, 0x02	; 2
    25f4:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,9,(u8*)"old=");
    25f8:	42 e2       	ldi	r20, 0x22	; 34
    25fa:	52 e0       	ldi	r21, 0x02	; 2
    25fc:	69 e0       	ldi	r22, 0x09	; 9
    25fe:	82 e0       	ldi	r24, 0x02	; 2
    2600:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_intXY(2,13,SensorReading.T_MOIST);
    2604:	f5 01       	movw	r30, r10
    2606:	26 a5       	ldd	r18, Z+46	; 0x2e
    2608:	30 e0       	ldi	r19, 0x00	; 0
    260a:	40 e0       	ldi	r20, 0x00	; 0
    260c:	50 e0       	ldi	r21, 0x00	; 0
    260e:	6d e0       	ldi	r22, 0x0D	; 13
    2610:	82 e0       	ldi	r24, 0x02	; 2
    2612:	0e 94 bb 02 	call	0x576	; 0x576 <disp_intXY>
			disp_strXY(3,1,GetMoist_L3);
    2616:	47 e2       	ldi	r20, 0x27	; 39
    2618:	52 e0       	ldi	r21, 0x02	; 2
    261a:	61 e0       	ldi	r22, 0x01	; 1
    261c:	83 e0       	ldi	r24, 0x03	; 3
    261e:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,1,GetMoist_L4);
    2622:	4d ec       	ldi	r20, 0xCD	; 205
    2624:	51 e0       	ldi	r21, 0x01	; 1
    2626:	61 e0       	ldi	r22, 0x01	; 1
    2628:	84 e0       	ldi	r24, 0x04	; 4
    262a:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
    262e:	29 c0       	rjmp	.+82     	; 0x2682 <T_DisplayData+0x3d4>
		}
		else if((state&E_lightConigDisp)==E_lightConigDisp)
    2630:	61 ff       	sbrs	r22, 1
    2632:	27 c0       	rjmp	.+78     	; 0x2682 <T_DisplayData+0x3d4>
		{
			disp_strXY(1,1,GetLight_L1);
    2634:	49 ea       	ldi	r20, 0xA9	; 169
    2636:	52 e0       	ldi	r21, 0x02	; 2
    2638:	61 e0       	ldi	r22, 0x01	; 1
    263a:	81 e0       	ldi	r24, 0x01	; 1
    263c:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,1,GetLight_L2);
    2640:	4c eb       	ldi	r20, 0xBC	; 188
    2642:	51 e0       	ldi	r21, 0x01	; 1
    2644:	61 e0       	ldi	r22, 0x01	; 1
    2646:	82 e0       	ldi	r24, 0x02	; 2
    2648:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(2,9,(u8*)"old=");
    264c:	42 e2       	ldi	r20, 0x22	; 34
    264e:	52 e0       	ldi	r21, 0x02	; 2
    2650:	69 e0       	ldi	r22, 0x09	; 9
    2652:	82 e0       	ldi	r24, 0x02	; 2
    2654:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_intXY(2,13,SensorReading.T_LDR);
    2658:	f5 01       	movw	r30, r10
    265a:	20 a9       	ldd	r18, Z+48	; 0x30
    265c:	30 e0       	ldi	r19, 0x00	; 0
    265e:	40 e0       	ldi	r20, 0x00	; 0
    2660:	50 e0       	ldi	r21, 0x00	; 0
    2662:	6d e0       	ldi	r22, 0x0D	; 13
    2664:	82 e0       	ldi	r24, 0x02	; 2
    2666:	0e 94 bb 02 	call	0x576	; 0x576 <disp_intXY>
			disp_strXY(3,1,GetLight_L3);
    266a:	47 e2       	ldi	r20, 0x27	; 39
    266c:	52 e0       	ldi	r21, 0x02	; 2
    266e:	61 e0       	ldi	r22, 0x01	; 1
    2670:	83 e0       	ldi	r24, 0x03	; 3
    2672:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
			disp_strXY(4,1,GetLight_L4);
    2676:	4d ec       	ldi	r20, 0xCD	; 205
    2678:	51 e0       	ldi	r21, 0x01	; 1
    267a:	61 e0       	ldi	r22, 0x01	; 1
    267c:	84 e0       	ldi	r24, 0x04	; 4
    267e:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
		}
		vTaskDelay(100);
    2682:	64 e6       	ldi	r22, 0x64	; 100
    2684:	70 e0       	ldi	r23, 0x00	; 0
    2686:	80 e0       	ldi	r24, 0x00	; 0
    2688:	90 e0       	ldi	r25, 0x00	; 0
    268a:	70 da       	rcall	.-2848   	; 0x1b6c <vTaskDelay>
		
	}
    268c:	27 ce       	rjmp	.-946    	; 0x22dc <T_DisplayData+0x2e>

0000268e <T_FireDetect>:
/******************************************************************************* fire alarm tasks **************************************************************************************************/
void T_FireDetect(void *pvinitData)
{
	while (1)
	{
		if (readPin(FLAME_SENSOR))
    268e:	8a e1       	ldi	r24, 0x1A	; 26
    2690:	0e 94 f5 03 	call	0x7ea	; 0x7ea <readPin>
    2694:	88 23       	and	r24, r24
    2696:	51 f0       	breq	.+20     	; 0x26ac <T_FireDetect+0x1e>
		{
			xEventGroupSetBits(egEvents,(E_FireDetect|E_FireAlarmDisp));
    2698:	40 e6       	ldi	r20, 0x60	; 96
    269a:	50 e0       	ldi	r21, 0x00	; 0
    269c:	60 e0       	ldi	r22, 0x00	; 0
    269e:	70 e0       	ldi	r23, 0x00	; 0
    26a0:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    26a4:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    26a8:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
		}
		vTaskDelay(500);
    26ac:	64 ef       	ldi	r22, 0xF4	; 244
    26ae:	71 e0       	ldi	r23, 0x01	; 1
    26b0:	80 e0       	ldi	r24, 0x00	; 0
    26b2:	90 e0       	ldi	r25, 0x00	; 0
    26b4:	5b da       	rcall	.-2890   	; 0x1b6c <vTaskDelay>
	}
    26b6:	eb cf       	rjmp	.-42     	; 0x268e <T_FireDetect>

000026b8 <T_FireAlarmAction>:
}
void T_FireAlarmAction(void *pvinitData)
{
    26b8:	cf 93       	push	r28
    26ba:	df 93       	push	r29
    26bc:	cd b7       	in	r28, 0x3d	; 61
    26be:	de b7       	in	r29, 0x3e	; 62
    26c0:	65 97       	sbiw	r28, 0x15	; 21
    26c2:	0f b6       	in	r0, 0x3f	; 63
    26c4:	f8 94       	cli
    26c6:	de bf       	out	0x3e, r29	; 62
    26c8:	0f be       	out	0x3f, r0	; 63
    26ca:	cd bf       	out	0x3d, r28	; 61
	u8 flag=0;
	u8 msg[]="home on fire";
    26cc:	8d e0       	ldi	r24, 0x0D	; 13
    26ce:	e1 ec       	ldi	r30, 0xC1	; 193
    26d0:	f2 e0       	ldi	r31, 0x02	; 2
    26d2:	de 01       	movw	r26, r28
    26d4:	11 96       	adiw	r26, 0x01	; 1
    26d6:	01 90       	ld	r0, Z+
    26d8:	0d 92       	st	X+, r0
    26da:	8a 95       	dec	r24
    26dc:	e1 f7       	brne	.-8      	; 0x26d6 <T_FireAlarmAction+0x1e>
	u8 msg2[]="No fire";
    26de:	88 e0       	ldi	r24, 0x08	; 8
    26e0:	ee ec       	ldi	r30, 0xCE	; 206
    26e2:	f2 e0       	ldi	r31, 0x02	; 2
    26e4:	de 01       	movw	r26, r28
    26e6:	1e 96       	adiw	r26, 0x0e	; 14
    26e8:	01 90       	ld	r0, Z+
    26ea:	0d 92       	st	X+, r0
    26ec:	8a 95       	dec	r24
    26ee:	e1 f7       	brne	.-8      	; 0x26e8 <T_FireAlarmAction+0x30>
		vTaskDelay(500);
	}
}
void T_FireAlarmAction(void *pvinitData)
{
	u8 flag=0;
    26f0:	10 e0       	ldi	r17, 0x00	; 0
		else
		{
			if(flag==1)
			{
				flag=0;
				MQTT_Publish((u8*)"G/fire",msg2,strlen((char*)msg2));
    26f2:	4e 01       	movw	r8, r28
    26f4:	8e e0       	ldi	r24, 0x0E	; 14
    26f6:	88 0e       	add	r8, r24
    26f8:	91 1c       	adc	r9, r1
				
				SensorReading.LCDState=MAIN_STATE;
    26fa:	0f 2e       	mov	r0, r31
    26fc:	fc e1       	ldi	r31, 0x1C	; 28
    26fe:	6f 2e       	mov	r6, r31
    2700:	f1 e0       	ldi	r31, 0x01	; 1
    2702:	7f 2e       	mov	r7, r31
    2704:	f0 2d       	mov	r31, r0
			writePin(FIREPUMP,HIGH);
			writePin(BUZZER,HIGH);
			vTaskDelay(600);
			writePin(BUZZER,LOW);
			vTaskDelay(150);
			MQTT_Publish((u8*)"G/fire",msg,strlen((char*)msg));
    2706:	fe 01       	movw	r30, r28
    2708:	31 96       	adiw	r30, 0x01	; 1
    270a:	5f 01       	movw	r10, r30
	u8 msg2[]="No fire";
	EventBits_t state=0;
	while (1)
	{
		
		state=xEventGroupWaitBits(egEvents,E_FireDetect,1,0,500);
    270c:	0f 2e       	mov	r0, r31
    270e:	f4 ef       	ldi	r31, 0xF4	; 244
    2710:	cf 2e       	mov	r12, r31
    2712:	dd 24       	eor	r13, r13
    2714:	d3 94       	inc	r13
    2716:	e1 2c       	mov	r14, r1
    2718:	f1 2c       	mov	r15, r1
    271a:	f0 2d       	mov	r31, r0
    271c:	00 e0       	ldi	r16, 0x00	; 0
    271e:	21 e0       	ldi	r18, 0x01	; 1
    2720:	40 e2       	ldi	r20, 0x20	; 32
    2722:	50 e0       	ldi	r21, 0x00	; 0
    2724:	60 e0       	ldi	r22, 0x00	; 0
    2726:	70 e0       	ldi	r23, 0x00	; 0
    2728:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    272c:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2730:	0e 94 bf 04 	call	0x97e	; 0x97e <xEventGroupWaitBits>
		if ((state&E_FireDetect)==E_FireDetect)
    2734:	65 ff       	sbrs	r22, 5
    2736:	24 c0       	rjmp	.+72     	; 0x2780 <T_FireAlarmAction+0xc8>
		{
			writePin(FIREPUMP,HIGH);
    2738:	61 e0       	ldi	r22, 0x01	; 1
    273a:	8b e1       	ldi	r24, 0x1B	; 27
    273c:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			writePin(BUZZER,HIGH);
    2740:	61 e0       	ldi	r22, 0x01	; 1
    2742:	8f e0       	ldi	r24, 0x0F	; 15
    2744:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			vTaskDelay(600);
    2748:	68 e5       	ldi	r22, 0x58	; 88
    274a:	72 e0       	ldi	r23, 0x02	; 2
    274c:	80 e0       	ldi	r24, 0x00	; 0
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	0d da       	rcall	.-3046   	; 0x1b6c <vTaskDelay>
			writePin(BUZZER,LOW);
    2752:	60 e0       	ldi	r22, 0x00	; 0
    2754:	8f e0       	ldi	r24, 0x0F	; 15
    2756:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			vTaskDelay(150);
    275a:	66 e9       	ldi	r22, 0x96	; 150
    275c:	70 e0       	ldi	r23, 0x00	; 0
    275e:	80 e0       	ldi	r24, 0x00	; 0
    2760:	90 e0       	ldi	r25, 0x00	; 0
    2762:	04 da       	rcall	.-3064   	; 0x1b6c <vTaskDelay>
			MQTT_Publish((u8*)"G/fire",msg,strlen((char*)msg));
    2764:	f5 01       	movw	r30, r10
    2766:	01 90       	ld	r0, Z+
    2768:	00 20       	and	r0, r0
    276a:	e9 f7       	brne	.-6      	; 0x2766 <T_FireAlarmAction+0xae>
    276c:	31 97       	sbiw	r30, 0x01	; 1
    276e:	af 01       	movw	r20, r30
    2770:	4a 19       	sub	r20, r10
    2772:	5b 09       	sbc	r21, r11
    2774:	b5 01       	movw	r22, r10
    2776:	8a eb       	ldi	r24, 0xBA	; 186
    2778:	92 e0       	ldi	r25, 0x02	; 2
    277a:	2c dd       	rcall	.-1448   	; 0x21d4 <MQTT_Publish>
			flag=1;
    277c:	11 e0       	ldi	r17, 0x01	; 1
    277e:	23 c0       	rjmp	.+70     	; 0x27c6 <T_FireAlarmAction+0x10e>
		}
		else
		{
			if(flag==1)
    2780:	11 30       	cpi	r17, 0x01	; 1
    2782:	c9 f4       	brne	.+50     	; 0x27b6 <T_FireAlarmAction+0xfe>
			{
				flag=0;
				MQTT_Publish((u8*)"G/fire",msg2,strlen((char*)msg2));
    2784:	f4 01       	movw	r30, r8
    2786:	01 90       	ld	r0, Z+
    2788:	00 20       	and	r0, r0
    278a:	e9 f7       	brne	.-6      	; 0x2786 <T_FireAlarmAction+0xce>
    278c:	31 97       	sbiw	r30, 0x01	; 1
    278e:	af 01       	movw	r20, r30
    2790:	48 19       	sub	r20, r8
    2792:	59 09       	sbc	r21, r9
    2794:	b4 01       	movw	r22, r8
    2796:	8a eb       	ldi	r24, 0xBA	; 186
    2798:	92 e0       	ldi	r25, 0x02	; 2
    279a:	1c dd       	rcall	.-1480   	; 0x21d4 <MQTT_Publish>
				
				SensorReading.LCDState=MAIN_STATE;
    279c:	f3 01       	movw	r30, r6
    279e:	11 aa       	std	Z+49, r1	; 0x31
				xEventGroupSetBits(egEvents,E_MainDisp);
    27a0:	40 e0       	ldi	r20, 0x00	; 0
    27a2:	52 e0       	ldi	r21, 0x02	; 2
    27a4:	60 e0       	ldi	r22, 0x00	; 0
    27a6:	70 e0       	ldi	r23, 0x00	; 0
    27a8:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    27ac:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    27b0:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
		}
		else
		{
			if(flag==1)
			{
				flag=0;
    27b4:	10 e0       	ldi	r17, 0x00	; 0
				MQTT_Publish((u8*)"G/fire",msg2,strlen((char*)msg2));
				
				SensorReading.LCDState=MAIN_STATE;
				xEventGroupSetBits(egEvents,E_MainDisp);
			}
			writePin(FIREPUMP,LOW);
    27b6:	60 e0       	ldi	r22, 0x00	; 0
    27b8:	8b e1       	ldi	r24, 0x1B	; 27
    27ba:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			writePin(BUZZER,LOW);
    27be:	60 e0       	ldi	r22, 0x00	; 0
    27c0:	8f e0       	ldi	r24, 0x0F	; 15
    27c2:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
		}
		vTaskDelay(400);
    27c6:	60 e9       	ldi	r22, 0x90	; 144
    27c8:	71 e0       	ldi	r23, 0x01	; 1
    27ca:	80 e0       	ldi	r24, 0x00	; 0
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	ce d9       	rcall	.-3172   	; 0x1b6c <vTaskDelay>
	}
    27d0:	9d cf       	rjmp	.-198    	; 0x270c <T_FireAlarmAction+0x54>

000027d2 <T_LIGHT_Action>:
		}
		vTaskDelay(1000); //sec for Testing to be updated
	}
}
void T_LIGHT_Action(void* pvInitData)
{
    27d2:	cf 93       	push	r28
    27d4:	df 93       	push	r29
    27d6:	cd b7       	in	r28, 0x3d	; 61
    27d8:	de b7       	in	r29, 0x3e	; 62
    27da:	6f 97       	sbiw	r28, 0x1f	; 31
    27dc:	0f b6       	in	r0, 0x3f	; 63
    27de:	f8 94       	cli
    27e0:	de bf       	out	0x3e, r29	; 62
    27e2:	0f be       	out	0x3f, r0	; 63
    27e4:	cd bf       	out	0x3d, r28	; 61
	
	u8 msg1[]="Outer light ON";
    27e6:	8f e0       	ldi	r24, 0x0F	; 15
    27e8:	e6 ed       	ldi	r30, 0xD6	; 214
    27ea:	f2 e0       	ldi	r31, 0x02	; 2
    27ec:	de 01       	movw	r26, r28
    27ee:	11 96       	adiw	r26, 0x01	; 1
    27f0:	01 90       	ld	r0, Z+
    27f2:	0d 92       	st	X+, r0
    27f4:	8a 95       	dec	r24
    27f6:	e1 f7       	brne	.-8      	; 0x27f0 <T_LIGHT_Action+0x1e>
	u8 msg2[]="Outer light OFF";
    27f8:	80 e1       	ldi	r24, 0x10	; 16
    27fa:	e5 ee       	ldi	r30, 0xE5	; 229
    27fc:	f2 e0       	ldi	r31, 0x02	; 2
    27fe:	de 01       	movw	r26, r28
    2800:	50 96       	adiw	r26, 0x10	; 16
    2802:	01 90       	ld	r0, Z+
    2804:	0d 92       	st	X+, r0
    2806:	8a 95       	dec	r24
    2808:	e1 f7       	brne	.-8      	; 0x2802 <T_LIGHT_Action+0x30>
	while (1)
	{
		state=xEventGroupWaitBits(egEvents,E_lightCheck,1,0,portMAX_DELAY);
		if((state&E_lightCheck)==E_lightCheck)
		{
			if(SensorReading.C_LDR<SensorReading.T_LDR)
    280a:	0f 2e       	mov	r0, r31
    280c:	fc e1       	ldi	r31, 0x1C	; 28
    280e:	af 2e       	mov	r10, r31
    2810:	f1 e0       	ldi	r31, 0x01	; 1
    2812:	bf 2e       	mov	r11, r31
    2814:	f0 2d       	mov	r31, r0
				MQTT_Publish((u8*)"G/light",msg1,strlen((char*)msg1));
				writePin(OUTERLIGHT,HIGH);
			}
			else
			{
				MQTT_Publish((u8*)"G/light",msg2,strlen((char*)msg2));
    2816:	3e 01       	movw	r6, r28
    2818:	80 e1       	ldi	r24, 0x10	; 16
    281a:	68 0e       	add	r6, r24
    281c:	71 1c       	adc	r7, r1
		state=xEventGroupWaitBits(egEvents,E_lightCheck,1,0,portMAX_DELAY);
		if((state&E_lightCheck)==E_lightCheck)
		{
			if(SensorReading.C_LDR<SensorReading.T_LDR)
			{
				MQTT_Publish((u8*)"G/light",msg1,strlen((char*)msg1));
    281e:	fe 01       	movw	r30, r28
    2820:	31 96       	adiw	r30, 0x01	; 1
    2822:	4f 01       	movw	r8, r30
	u8 msg1[]="Outer light ON";
	u8 msg2[]="Outer light OFF";
	EventBits_t state=0;
	while (1)
	{
		state=xEventGroupWaitBits(egEvents,E_lightCheck,1,0,portMAX_DELAY);
    2824:	cc 24       	eor	r12, r12
    2826:	ca 94       	dec	r12
    2828:	dc 2c       	mov	r13, r12
    282a:	76 01       	movw	r14, r12
    282c:	00 e0       	ldi	r16, 0x00	; 0
    282e:	21 e0       	ldi	r18, 0x01	; 1
    2830:	40 e0       	ldi	r20, 0x00	; 0
    2832:	50 e1       	ldi	r21, 0x10	; 16
    2834:	60 e0       	ldi	r22, 0x00	; 0
    2836:	70 e0       	ldi	r23, 0x00	; 0
    2838:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    283c:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2840:	0e 94 bf 04 	call	0x97e	; 0x97e <xEventGroupWaitBits>
		if((state&E_lightCheck)==E_lightCheck)
    2844:	74 ff       	sbrs	r23, 4
    2846:	ee cf       	rjmp	.-36     	; 0x2824 <T_LIGHT_Action+0x52>
		{
			if(SensorReading.C_LDR<SensorReading.T_LDR)
    2848:	f5 01       	movw	r30, r10
    284a:	97 a5       	ldd	r25, Z+47	; 0x2f
    284c:	80 a9       	ldd	r24, Z+48	; 0x30
    284e:	98 17       	cp	r25, r24
    2850:	88 f4       	brcc	.+34     	; 0x2874 <T_LIGHT_Action+0xa2>
			{
				MQTT_Publish((u8*)"G/light",msg1,strlen((char*)msg1));
    2852:	f4 01       	movw	r30, r8
    2854:	01 90       	ld	r0, Z+
    2856:	00 20       	and	r0, r0
    2858:	e9 f7       	brne	.-6      	; 0x2854 <T_LIGHT_Action+0x82>
    285a:	31 97       	sbiw	r30, 0x01	; 1
    285c:	af 01       	movw	r20, r30
    285e:	48 19       	sub	r20, r8
    2860:	59 09       	sbc	r21, r9
    2862:	b4 01       	movw	r22, r8
    2864:	83 e8       	ldi	r24, 0x83	; 131
    2866:	92 e0       	ldi	r25, 0x02	; 2
    2868:	b5 dc       	rcall	.-1686   	; 0x21d4 <MQTT_Publish>
				writePin(OUTERLIGHT,HIGH);
    286a:	61 e0       	ldi	r22, 0x01	; 1
    286c:	8d e1       	ldi	r24, 0x1D	; 29
    286e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
    2872:	10 c0       	rjmp	.+32     	; 0x2894 <T_LIGHT_Action+0xc2>
			}
			else
			{
				MQTT_Publish((u8*)"G/light",msg2,strlen((char*)msg2));
    2874:	f3 01       	movw	r30, r6
    2876:	01 90       	ld	r0, Z+
    2878:	00 20       	and	r0, r0
    287a:	e9 f7       	brne	.-6      	; 0x2876 <T_LIGHT_Action+0xa4>
    287c:	31 97       	sbiw	r30, 0x01	; 1
    287e:	af 01       	movw	r20, r30
    2880:	46 19       	sub	r20, r6
    2882:	57 09       	sbc	r21, r7
    2884:	b3 01       	movw	r22, r6
    2886:	83 e8       	ldi	r24, 0x83	; 131
    2888:	92 e0       	ldi	r25, 0x02	; 2
    288a:	a4 dc       	rcall	.-1720   	; 0x21d4 <MQTT_Publish>
				writePin(OUTERLIGHT,LOW);
    288c:	60 e0       	ldi	r22, 0x00	; 0
    288e:	8d e1       	ldi	r24, 0x1D	; 29
    2890:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			}
			vTaskDelay(5000);
    2894:	68 e8       	ldi	r22, 0x88	; 136
    2896:	73 e1       	ldi	r23, 0x13	; 19
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	90 e0       	ldi	r25, 0x00	; 0
    289c:	67 d9       	rcall	.-3378   	; 0x1b6c <vTaskDelay>
    289e:	c2 cf       	rjmp	.-124    	; 0x2824 <T_LIGHT_Action+0x52>

000028a0 <T_SOIL_Action>:
		}
		vTaskDelay(10000);
	}
}
void T_SOIL_Action(void* pvInitData)
{
    28a0:	cf 93       	push	r28
    28a2:	df 93       	push	r29
    28a4:	cd b7       	in	r28, 0x3d	; 61
    28a6:	de b7       	in	r29, 0x3e	; 62
    28a8:	6d 97       	sbiw	r28, 0x1d	; 29
    28aa:	0f b6       	in	r0, 0x3f	; 63
    28ac:	f8 94       	cli
    28ae:	de bf       	out	0x3e, r29	; 62
    28b0:	0f be       	out	0x3f, r0	; 63
    28b2:	cd bf       	out	0x3d, r28	; 61
	
	u8 msg1[]="Water Pump ON";
    28b4:	8e e0       	ldi	r24, 0x0E	; 14
    28b6:	e5 ef       	ldi	r30, 0xF5	; 245
    28b8:	f2 e0       	ldi	r31, 0x02	; 2
    28ba:	de 01       	movw	r26, r28
    28bc:	11 96       	adiw	r26, 0x01	; 1
    28be:	01 90       	ld	r0, Z+
    28c0:	0d 92       	st	X+, r0
    28c2:	8a 95       	dec	r24
    28c4:	e1 f7       	brne	.-8      	; 0x28be <T_SOIL_Action+0x1e>
	u8 msg2[]="Water Pump OFF";
    28c6:	8f e0       	ldi	r24, 0x0F	; 15
    28c8:	e3 e0       	ldi	r30, 0x03	; 3
    28ca:	f3 e0       	ldi	r31, 0x03	; 3
    28cc:	de 01       	movw	r26, r28
    28ce:	1f 96       	adiw	r26, 0x0f	; 15
    28d0:	01 90       	ld	r0, Z+
    28d2:	0d 92       	st	X+, r0
    28d4:	8a 95       	dec	r24
    28d6:	e1 f7       	brne	.-8      	; 0x28d0 <T_SOIL_Action+0x30>
	while (1)
	{
		state=xEventGroupWaitBits(egEvents,E_MoistCheck,1,0,portMAX_DELAY);
		if((state&E_MoistCheck)==E_MoistCheck)
		{
			if(SensorReading.C_MOIST<SensorReading.T_MOIST)
    28d8:	0f 2e       	mov	r0, r31
    28da:	fc e1       	ldi	r31, 0x1C	; 28
    28dc:	af 2e       	mov	r10, r31
    28de:	f1 e0       	ldi	r31, 0x01	; 1
    28e0:	bf 2e       	mov	r11, r31
    28e2:	f0 2d       	mov	r31, r0
				MQTT_Publish((u8*)"G/soil",msg1,strlen((char*)msg1));
				writePin(SOIL_PUMP,HIGH);
			}
			else
			{
				MQTT_Publish((u8*)"G/soil",msg2,strlen((char*)msg2));
    28e4:	3e 01       	movw	r6, r28
    28e6:	8f e0       	ldi	r24, 0x0F	; 15
    28e8:	68 0e       	add	r6, r24
    28ea:	71 1c       	adc	r7, r1
		state=xEventGroupWaitBits(egEvents,E_MoistCheck,1,0,portMAX_DELAY);
		if((state&E_MoistCheck)==E_MoistCheck)
		{
			if(SensorReading.C_MOIST<SensorReading.T_MOIST)
			{
				MQTT_Publish((u8*)"G/soil",msg1,strlen((char*)msg1));
    28ec:	fe 01       	movw	r30, r28
    28ee:	31 96       	adiw	r30, 0x01	; 1
    28f0:	4f 01       	movw	r8, r30
	u8 msg1[]="Water Pump ON";
	u8 msg2[]="Water Pump OFF";
	EventBits_t state=0;
	while (1)
	{
		state=xEventGroupWaitBits(egEvents,E_MoistCheck,1,0,portMAX_DELAY);
    28f2:	cc 24       	eor	r12, r12
    28f4:	ca 94       	dec	r12
    28f6:	dc 2c       	mov	r13, r12
    28f8:	76 01       	movw	r14, r12
    28fa:	00 e0       	ldi	r16, 0x00	; 0
    28fc:	21 e0       	ldi	r18, 0x01	; 1
    28fe:	40 e0       	ldi	r20, 0x00	; 0
    2900:	58 e0       	ldi	r21, 0x08	; 8
    2902:	60 e0       	ldi	r22, 0x00	; 0
    2904:	70 e0       	ldi	r23, 0x00	; 0
    2906:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    290a:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    290e:	0e 94 bf 04 	call	0x97e	; 0x97e <xEventGroupWaitBits>
		if((state&E_MoistCheck)==E_MoistCheck)
    2912:	73 ff       	sbrs	r23, 3
    2914:	ee cf       	rjmp	.-36     	; 0x28f2 <T_SOIL_Action+0x52>
		{
			if(SensorReading.C_MOIST<SensorReading.T_MOIST)
    2916:	f5 01       	movw	r30, r10
    2918:	95 a5       	ldd	r25, Z+45	; 0x2d
    291a:	86 a5       	ldd	r24, Z+46	; 0x2e
    291c:	98 17       	cp	r25, r24
    291e:	88 f4       	brcc	.+34     	; 0x2942 <T_SOIL_Action+0xa2>
			{
				MQTT_Publish((u8*)"G/soil",msg1,strlen((char*)msg1));
    2920:	f4 01       	movw	r30, r8
    2922:	01 90       	ld	r0, Z+
    2924:	00 20       	and	r0, r0
    2926:	e9 f7       	brne	.-6      	; 0x2922 <T_SOIL_Action+0x82>
    2928:	31 97       	sbiw	r30, 0x01	; 1
    292a:	af 01       	movw	r20, r30
    292c:	48 19       	sub	r20, r8
    292e:	59 09       	sbc	r21, r9
    2930:	b4 01       	movw	r22, r8
    2932:	8c e7       	ldi	r24, 0x7C	; 124
    2934:	92 e0       	ldi	r25, 0x02	; 2
    2936:	4e dc       	rcall	.-1892   	; 0x21d4 <MQTT_Publish>
				writePin(SOIL_PUMP,HIGH);
    2938:	61 e0       	ldi	r22, 0x01	; 1
    293a:	8c e1       	ldi	r24, 0x1C	; 28
    293c:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
    2940:	10 c0       	rjmp	.+32     	; 0x2962 <T_SOIL_Action+0xc2>
			}
			else
			{
				MQTT_Publish((u8*)"G/soil",msg2,strlen((char*)msg2));
    2942:	f3 01       	movw	r30, r6
    2944:	01 90       	ld	r0, Z+
    2946:	00 20       	and	r0, r0
    2948:	e9 f7       	brne	.-6      	; 0x2944 <T_SOIL_Action+0xa4>
    294a:	31 97       	sbiw	r30, 0x01	; 1
    294c:	af 01       	movw	r20, r30
    294e:	46 19       	sub	r20, r6
    2950:	57 09       	sbc	r21, r7
    2952:	b3 01       	movw	r22, r6
    2954:	8c e7       	ldi	r24, 0x7C	; 124
    2956:	92 e0       	ldi	r25, 0x02	; 2
    2958:	3d dc       	rcall	.-1926   	; 0x21d4 <MQTT_Publish>
				writePin(SOIL_PUMP,LOW);
    295a:	60 e0       	ldi	r22, 0x00	; 0
    295c:	8c e1       	ldi	r24, 0x1C	; 28
    295e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			}
			vTaskDelay(500);
    2962:	64 ef       	ldi	r22, 0xF4	; 244
    2964:	71 e0       	ldi	r23, 0x01	; 1
    2966:	80 e0       	ldi	r24, 0x00	; 0
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	00 d9       	rcall	.-3584   	; 0x1b6c <vTaskDelay>
    296c:	c2 cf       	rjmp	.-124    	; 0x28f2 <T_SOIL_Action+0x52>

0000296e <IOTcharinput>:
extern u8 data;
void IOTcharinput(void *pvinitData)
{
	while(1)
	{
		switch(data)
    296e:	e0 91 f9 0f 	lds	r30, 0x0FF9	; 0x800ff9 <data>
    2972:	8e 2f       	mov	r24, r30
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	fc 01       	movw	r30, r24
    2978:	f0 97       	sbiw	r30, 0x30	; 48
    297a:	e8 30       	cpi	r30, 0x08	; 8
    297c:	f1 05       	cpc	r31, r1
    297e:	50 f5       	brcc	.+84     	; 0x29d4 <IOTcharinput+0x66>
    2980:	ea 5b       	subi	r30, 0xBA	; 186
    2982:	ff 4f       	sbci	r31, 0xFF	; 255
    2984:	a2 c6       	rjmp	.+3396   	; 0x36ca <__tablejump2__>
		{
			case '0':
			writePin(TV_PIN,LOW);
    2986:	60 e0       	ldi	r22, 0x00	; 0
    2988:	8f e1       	ldi	r24, 0x1F	; 31
    298a:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
    298e:	22 c0       	rjmp	.+68     	; 0x29d4 <IOTcharinput+0x66>
			case '1':
			writePin(TV_PIN,HIGH);
    2990:	61 e0       	ldi	r22, 0x01	; 1
    2992:	8f e1       	ldi	r24, 0x1F	; 31
    2994:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
    2998:	1d c0       	rjmp	.+58     	; 0x29d4 <IOTcharinput+0x66>
			case '2':
			writePin(INNERLIGHT,HIGH);
    299a:	61 e0       	ldi	r22, 0x01	; 1
    299c:	8e e1       	ldi	r24, 0x1E	; 30
    299e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
    29a2:	18 c0       	rjmp	.+48     	; 0x29d4 <IOTcharinput+0x66>
			case '3':
			writePin(INNERLIGHT,LOW);
    29a4:	60 e0       	ldi	r22, 0x00	; 0
    29a6:	8e e1       	ldi	r24, 0x1E	; 30
    29a8:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
    29ac:	13 c0       	rjmp	.+38     	; 0x29d4 <IOTcharinput+0x66>
			case '4':
			writePin(FAN,HIGH);
    29ae:	61 e0       	ldi	r22, 0x01	; 1
    29b0:	83 e1       	ldi	r24, 0x13	; 19
    29b2:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
    29b6:	0e c0       	rjmp	.+28     	; 0x29d4 <IOTcharinput+0x66>
			case '5':
			writePin(FAN,LOW);
    29b8:	60 e0       	ldi	r22, 0x00	; 0
    29ba:	83 e1       	ldi	r24, 0x13	; 19
    29bc:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
    29c0:	09 c0       	rjmp	.+18     	; 0x29d4 <IOTcharinput+0x66>
			case '6':
			writePin(OUTERLIGHT,HIGH);
    29c2:	61 e0       	ldi	r22, 0x01	; 1
    29c4:	8d e1       	ldi	r24, 0x1D	; 29
    29c6:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
    29ca:	04 c0       	rjmp	.+8      	; 0x29d4 <IOTcharinput+0x66>
			case '7':
			writePin(OUTERLIGHT,LOW);
    29cc:	60 e0       	ldi	r22, 0x00	; 0
    29ce:	8d e1       	ldi	r24, 0x1D	; 29
    29d0:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
			break;
		}
		vTaskDelay(300);
    29d4:	6c e2       	ldi	r22, 0x2C	; 44
    29d6:	71 e0       	ldi	r23, 0x01	; 1
    29d8:	80 e0       	ldi	r24, 0x00	; 0
    29da:	90 e0       	ldi	r25, 0x00	; 0
    29dc:	c7 d8       	rcall	.-3698   	; 0x1b6c <vTaskDelay>
	}
    29de:	c7 cf       	rjmp	.-114    	; 0x296e <IOTcharinput>

000029e0 <T_TempAction>:
}


/************************************************************************************* temp control tasks ***************************************************************************************************/
void T_TempAction(void *pvinitData)
{
    29e0:	cf 93       	push	r28
    29e2:	df 93       	push	r29
    29e4:	cd b7       	in	r28, 0x3d	; 61
    29e6:	de b7       	in	r29, 0x3e	; 62
    29e8:	2f 97       	sbiw	r28, 0x0f	; 15
    29ea:	0f b6       	in	r0, 0x3f	; 63
    29ec:	f8 94       	cli
    29ee:	de bf       	out	0x3e, r29	; 62
    29f0:	0f be       	out	0x3f, r0	; 63
    29f2:	cd bf       	out	0x3d, r28	; 61
	u8 str0[]="Fan ON";
    29f4:	87 e0       	ldi	r24, 0x07	; 7
    29f6:	e2 e1       	ldi	r30, 0x12	; 18
    29f8:	f3 e0       	ldi	r31, 0x03	; 3
    29fa:	de 01       	movw	r26, r28
    29fc:	11 96       	adiw	r26, 0x01	; 1
    29fe:	01 90       	ld	r0, Z+
    2a00:	0d 92       	st	X+, r0
    2a02:	8a 95       	dec	r24
    2a04:	e1 f7       	brne	.-8      	; 0x29fe <T_TempAction+0x1e>
	u8 str1[]="Fan Off";
    2a06:	88 e0       	ldi	r24, 0x08	; 8
    2a08:	e9 e1       	ldi	r30, 0x19	; 25
    2a0a:	f3 e0       	ldi	r31, 0x03	; 3
    2a0c:	de 01       	movw	r26, r28
    2a0e:	18 96       	adiw	r26, 0x08	; 8
    2a10:	01 90       	ld	r0, Z+
    2a12:	0d 92       	st	X+, r0
    2a14:	8a 95       	dec	r24
    2a16:	e1 f7       	brne	.-8      	; 0x2a10 <T_TempAction+0x30>
	
	EventBits_t state=0;
	vTaskDelay(1000);
    2a18:	68 ee       	ldi	r22, 0xE8	; 232
    2a1a:	73 e0       	ldi	r23, 0x03	; 3
    2a1c:	80 e0       	ldi	r24, 0x00	; 0
    2a1e:	90 e0       	ldi	r25, 0x00	; 0
    2a20:	a5 d8       	rcall	.-3766   	; 0x1b6c <vTaskDelay>
				MQTT_Publish((u8*)"G/temp",str0,strlen((char*)str0));
			}
			else
			{
				writePin(FAN,LOW);
				MQTT_Publish((u8*)"G/temp",str1,strlen((char*)str1));
    2a22:	4e 01       	movw	r8, r28
    2a24:	88 e0       	ldi	r24, 0x08	; 8
    2a26:	88 0e       	add	r8, r24
    2a28:	91 1c       	adc	r9, r1
		if((state&E_TempCheck)==E_TempCheck)
		{
			if(atoi(SensorReading.C_TEMP)>atoi(SensorReading.T_TEMP))
			{
				writePin(FAN,HIGH);
				MQTT_Publish((u8*)"G/temp",str0,strlen((char*)str0));
    2a2a:	ce 01       	movw	r24, r28
    2a2c:	01 96       	adiw	r24, 0x01	; 1
    2a2e:	5c 01       	movw	r10, r24
	
	EventBits_t state=0;
	vTaskDelay(1000);
	while(1)
	{
		state=xEventGroupWaitBits(egEvents,E_TempCheck,1,0,portMAX_DELAY);
    2a30:	cc 24       	eor	r12, r12
    2a32:	ca 94       	dec	r12
    2a34:	dc 2c       	mov	r13, r12
    2a36:	76 01       	movw	r14, r12
    2a38:	00 e0       	ldi	r16, 0x00	; 0
    2a3a:	21 e0       	ldi	r18, 0x01	; 1
    2a3c:	40 e0       	ldi	r20, 0x00	; 0
    2a3e:	54 e0       	ldi	r21, 0x04	; 4
    2a40:	60 e0       	ldi	r22, 0x00	; 0
    2a42:	70 e0       	ldi	r23, 0x00	; 0
    2a44:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2a48:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2a4c:	0e 94 bf 04 	call	0x97e	; 0x97e <xEventGroupWaitBits>
		if((state&E_TempCheck)==E_TempCheck)
    2a50:	72 ff       	sbrs	r23, 2
    2a52:	2b c0       	rjmp	.+86     	; 0x2aaa <T_TempAction+0xca>
		{
			if(atoi(SensorReading.C_TEMP)>atoi(SensorReading.T_TEMP))
    2a54:	8c e1       	ldi	r24, 0x1C	; 28
    2a56:	91 e0       	ldi	r25, 0x01	; 1
    2a58:	50 d6       	rcall	.+3232   	; 0x36fa <atoi>
    2a5a:	8c 01       	movw	r16, r24
    2a5c:	8b e2       	ldi	r24, 0x2B	; 43
    2a5e:	91 e0       	ldi	r25, 0x01	; 1
    2a60:	4c d6       	rcall	.+3224   	; 0x36fa <atoi>
    2a62:	80 17       	cp	r24, r16
    2a64:	91 07       	cpc	r25, r17
    2a66:	8c f4       	brge	.+34     	; 0x2a8a <T_TempAction+0xaa>
			{
				writePin(FAN,HIGH);
    2a68:	61 e0       	ldi	r22, 0x01	; 1
    2a6a:	83 e1       	ldi	r24, 0x13	; 19
    2a6c:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
				MQTT_Publish((u8*)"G/temp",str0,strlen((char*)str0));
    2a70:	f5 01       	movw	r30, r10
    2a72:	01 90       	ld	r0, Z+
    2a74:	00 20       	and	r0, r0
    2a76:	e9 f7       	brne	.-6      	; 0x2a72 <T_TempAction+0x92>
    2a78:	31 97       	sbiw	r30, 0x01	; 1
    2a7a:	af 01       	movw	r20, r30
    2a7c:	4a 19       	sub	r20, r10
    2a7e:	5b 09       	sbc	r21, r11
    2a80:	b5 01       	movw	r22, r10
    2a82:	81 e9       	ldi	r24, 0x91	; 145
    2a84:	92 e0       	ldi	r25, 0x02	; 2
    2a86:	a6 db       	rcall	.-2228   	; 0x21d4 <MQTT_Publish>
    2a88:	10 c0       	rjmp	.+32     	; 0x2aaa <T_TempAction+0xca>
			}
			else
			{
				writePin(FAN,LOW);
    2a8a:	60 e0       	ldi	r22, 0x00	; 0
    2a8c:	83 e1       	ldi	r24, 0x13	; 19
    2a8e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
				MQTT_Publish((u8*)"G/temp",str1,strlen((char*)str1));
    2a92:	f4 01       	movw	r30, r8
    2a94:	01 90       	ld	r0, Z+
    2a96:	00 20       	and	r0, r0
    2a98:	e9 f7       	brne	.-6      	; 0x2a94 <T_TempAction+0xb4>
    2a9a:	31 97       	sbiw	r30, 0x01	; 1
    2a9c:	af 01       	movw	r20, r30
    2a9e:	48 19       	sub	r20, r8
    2aa0:	59 09       	sbc	r21, r9
    2aa2:	b4 01       	movw	r22, r8
    2aa4:	81 e9       	ldi	r24, 0x91	; 145
    2aa6:	92 e0       	ldi	r25, 0x02	; 2
    2aa8:	95 db       	rcall	.-2262   	; 0x21d4 <MQTT_Publish>
			}
		}
		vTaskDelay(1000);
    2aaa:	68 ee       	ldi	r22, 0xE8	; 232
    2aac:	73 e0       	ldi	r23, 0x03	; 3
    2aae:	80 e0       	ldi	r24, 0x00	; 0
    2ab0:	90 e0       	ldi	r25, 0x00	; 0
    2ab2:	5c d8       	rcall	.-3912   	; 0x1b6c <vTaskDelay>
    2ab4:	bd cf       	rjmp	.-134    	; 0x2a30 <T_TempAction+0x50>

00002ab6 <T_TempRead>:

	}
    2ab6:	cf 93       	push	r28
}
void T_TempRead	 (void *pvinitData)
{
    2ab8:	df 93       	push	r29
    2aba:	cd b7       	in	r28, 0x3d	; 61
    2abc:	de b7       	in	r29, 0x3e	; 62
    2abe:	6e 97       	sbiw	r28, 0x1e	; 30
    2ac0:	0f b6       	in	r0, 0x3f	; 63
    2ac2:	f8 94       	cli
    2ac4:	de bf       	out	0x3e, r29	; 62
    2ac6:	0f be       	out	0x3f, r0	; 63
    2ac8:	cd bf       	out	0x3d, r28	; 61
	u8 temp[15];
	u8 hum[15];
	while(1)
	{
		DHT_Represent(hum,temp);
    2aca:	be 01       	movw	r22, r28
    2acc:	6f 5f       	subi	r22, 0xFF	; 255
    2ace:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad0:	ce 01       	movw	r24, r28
    2ad2:	40 96       	adiw	r24, 0x10	; 16
    2ad4:	0e 94 70 01 	call	0x2e0	; 0x2e0 <DHT_Represent>
		if((strcmp((char*)temp,SensorReading.C_TEMP))!=0)
    2ad8:	6c e1       	ldi	r22, 0x1C	; 28
    2ada:	71 e0       	ldi	r23, 0x01	; 1
    2adc:	ce 01       	movw	r24, r28
    2ade:	01 96       	adiw	r24, 0x01	; 1
    2ae0:	3d d6       	rcall	.+3194   	; 0x375c <strcmp>
    2ae2:	89 2b       	or	r24, r25
    2ae4:	f1 f0       	breq	.+60     	; 0x2b22 <T_TempRead+0x6c>
		{
			strcpy(SensorReading.C_TEMP,(char*)temp);
    2ae6:	be 01       	movw	r22, r28
    2ae8:	6f 5f       	subi	r22, 0xFF	; 255
    2aea:	7f 4f       	sbci	r23, 0xFF	; 255
    2aec:	8c e1       	ldi	r24, 0x1C	; 28
    2aee:	91 e0       	ldi	r25, 0x01	; 1
    2af0:	3e d6       	rcall	.+3196   	; 0x376e <strcpy>
			if(SensorReading.LCDState==MAIN_STATE)
    2af2:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <SensorReading+0x31>
    2af6:	81 11       	cpse	r24, r1
    2af8:	0a c0       	rjmp	.+20     	; 0x2b0e <T_TempRead+0x58>
			{
				xEventGroupSetBits(egEvents,E_CTempUpdate);
    2afa:	41 e0       	ldi	r20, 0x01	; 1
    2afc:	50 e0       	ldi	r21, 0x00	; 0
    2afe:	60 e0       	ldi	r22, 0x00	; 0
    2b00:	70 e0       	ldi	r23, 0x00	; 0
    2b02:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2b06:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2b0a:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
			}
			xEventGroupSetBits(egEvents,E_TempCheck);
    2b0e:	40 e0       	ldi	r20, 0x00	; 0
    2b10:	54 e0       	ldi	r21, 0x04	; 4
    2b12:	60 e0       	ldi	r22, 0x00	; 0
    2b14:	70 e0       	ldi	r23, 0x00	; 0
    2b16:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2b1a:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2b1e:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
		}
		if ((strcmp((char*)hum,SensorReading.C_HUM))!=0)
    2b22:	6a e3       	ldi	r22, 0x3A	; 58
    2b24:	71 e0       	ldi	r23, 0x01	; 1
    2b26:	ce 01       	movw	r24, r28
    2b28:	40 96       	adiw	r24, 0x10	; 16
    2b2a:	18 d6       	rcall	.+3120   	; 0x375c <strcmp>
    2b2c:	89 2b       	or	r24, r25
    2b2e:	a1 f0       	breq	.+40     	; 0x2b58 <T_TempRead+0xa2>
		{
			strcpy(SensorReading.C_HUM,(char*)hum);
    2b30:	be 01       	movw	r22, r28
    2b32:	60 5f       	subi	r22, 0xF0	; 240
    2b34:	7f 4f       	sbci	r23, 0xFF	; 255
    2b36:	8a e3       	ldi	r24, 0x3A	; 58
    2b38:	91 e0       	ldi	r25, 0x01	; 1
    2b3a:	19 d6       	rcall	.+3122   	; 0x376e <strcpy>
			if(SensorReading.LCDState==MAIN_STATE)
    2b3c:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <SensorReading+0x31>
    2b40:	81 11       	cpse	r24, r1
    2b42:	0a c0       	rjmp	.+20     	; 0x2b58 <T_TempRead+0xa2>
			{
				xEventGroupSetBits(egEvents,E_CHUMUpdate);
    2b44:	48 e0       	ldi	r20, 0x08	; 8
    2b46:	50 e0       	ldi	r21, 0x00	; 0
    2b48:	60 e0       	ldi	r22, 0x00	; 0
    2b4a:	70 e0       	ldi	r23, 0x00	; 0
    2b4c:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2b50:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2b54:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
			}
		}
		else
		{
		}
		vTaskDelay(10000);
    2b58:	60 e1       	ldi	r22, 0x10	; 16
    2b5a:	77 e2       	ldi	r23, 0x27	; 39
    2b5c:	80 e0       	ldi	r24, 0x00	; 0
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	05 d8       	rcall	.-4086   	; 0x1b6c <vTaskDelay>
	}
    2b62:	b3 cf       	rjmp	.-154    	; 0x2aca <T_TempRead+0x14>

00002b64 <T_LIGHT_Input>:
void T_LIGHT_Input(void* pvInitData){
	u16 LDR=0;
	while (1)
	{
		LDR=read_analog(LDRSENSOR);
		LDR=((LDR*100UL)/407UL);
    2b64:	0f 2e       	mov	r0, r31
    2b66:	f7 e9       	ldi	r31, 0x97	; 151
    2b68:	cf 2e       	mov	r12, r31
    2b6a:	dd 24       	eor	r13, r13
    2b6c:	d3 94       	inc	r13
    2b6e:	e1 2c       	mov	r14, r1
    2b70:	f1 2c       	mov	r15, r1
    2b72:	f0 2d       	mov	r31, r0
		
		//controlling outer lights
		if(LDR != SensorReading.C_LDR )
    2b74:	cc e1       	ldi	r28, 0x1C	; 28
    2b76:	d1 e0       	ldi	r29, 0x01	; 1
/*************************************************************************************Outer light **************************************************************************************************************/
void T_LIGHT_Input(void* pvInitData){
	u16 LDR=0;
	while (1)
	{
		LDR=read_analog(LDRSENSOR);
    2b78:	81 e0       	ldi	r24, 0x01	; 1
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	0e 94 cf 02 	call	0x59e	; 0x59e <read_analog>
		LDR=((LDR*100UL)/407UL);
    2b80:	9c 01       	movw	r18, r24
    2b82:	a4 e6       	ldi	r26, 0x64	; 100
    2b84:	b0 e0       	ldi	r27, 0x00	; 0
    2b86:	aa d5       	rcall	.+2900   	; 0x36dc <__umulhisi3>
    2b88:	a7 01       	movw	r20, r14
    2b8a:	96 01       	movw	r18, r12
    2b8c:	7c d5       	rcall	.+2808   	; 0x3686 <__udivmodsi4>
		
		//controlling outer lights
		if(LDR != SensorReading.C_LDR )
    2b8e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2b90:	90 e0       	ldi	r25, 0x00	; 0
    2b92:	82 17       	cp	r24, r18
    2b94:	93 07       	cpc	r25, r19
    2b96:	c1 f0       	breq	.+48     	; 0x2bc8 <T_LIGHT_Input+0x64>
		{
			SensorReading.C_LDR = LDR;
    2b98:	2f a7       	std	Y+47, r18	; 0x2f
			if (SensorReading.LCDState == MAIN_STATE)
    2b9a:	89 a9       	ldd	r24, Y+49	; 0x31
    2b9c:	81 11       	cpse	r24, r1
    2b9e:	0a c0       	rjmp	.+20     	; 0x2bb4 <T_LIGHT_Input+0x50>
			{
				xEventGroupSetBits(egEvents,E_CLightUpdate);
    2ba0:	40 e1       	ldi	r20, 0x10	; 16
    2ba2:	50 e0       	ldi	r21, 0x00	; 0
    2ba4:	60 e0       	ldi	r22, 0x00	; 0
    2ba6:	70 e0       	ldi	r23, 0x00	; 0
    2ba8:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2bac:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2bb0:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
			}
			xEventGroupSetBits(egEvents,E_lightCheck);
    2bb4:	40 e0       	ldi	r20, 0x00	; 0
    2bb6:	50 e1       	ldi	r21, 0x10	; 16
    2bb8:	60 e0       	ldi	r22, 0x00	; 0
    2bba:	70 e0       	ldi	r23, 0x00	; 0
    2bbc:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2bc0:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2bc4:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
		}
		vTaskDelay(1000); //sec for Testing to be updated
    2bc8:	68 ee       	ldi	r22, 0xE8	; 232
    2bca:	73 e0       	ldi	r23, 0x03	; 3
    2bcc:	80 e0       	ldi	r24, 0x00	; 0
    2bce:	90 e0       	ldi	r25, 0x00	; 0
    2bd0:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
	}
    2bd4:	d1 cf       	rjmp	.-94     	; 0x2b78 <T_LIGHT_Input+0x14>

00002bd6 <T_SOIL_Input>:
{
	u16 Moist=0;
	while (1)
	{
		Moist=read_analog(SOILSENSOR);
		Moist=(100-(Moist*100UL)/1019UL);
    2bd6:	04 e6       	ldi	r16, 0x64	; 100
    2bd8:	10 e0       	ldi	r17, 0x00	; 0
    2bda:	0f 2e       	mov	r0, r31
    2bdc:	fb ef       	ldi	r31, 0xFB	; 251
    2bde:	cf 2e       	mov	r12, r31
    2be0:	f3 e0       	ldi	r31, 0x03	; 3
    2be2:	df 2e       	mov	r13, r31
    2be4:	e1 2c       	mov	r14, r1
    2be6:	f1 2c       	mov	r15, r1
    2be8:	f0 2d       	mov	r31, r0
		if(Moist != SensorReading.C_MOIST )
    2bea:	cc e1       	ldi	r28, 0x1C	; 28
    2bec:	d1 e0       	ldi	r29, 0x01	; 1
void T_SOIL_Input(void* pvInitData)
{
	u16 Moist=0;
	while (1)
	{
		Moist=read_analog(SOILSENSOR);
    2bee:	80 e0       	ldi	r24, 0x00	; 0
    2bf0:	90 e0       	ldi	r25, 0x00	; 0
    2bf2:	0e 94 cf 02 	call	0x59e	; 0x59e <read_analog>
		Moist=(100-(Moist*100UL)/1019UL);
    2bf6:	9c 01       	movw	r18, r24
    2bf8:	a4 e6       	ldi	r26, 0x64	; 100
    2bfa:	b0 e0       	ldi	r27, 0x00	; 0
    2bfc:	6f d5       	rcall	.+2782   	; 0x36dc <__umulhisi3>
    2bfe:	a7 01       	movw	r20, r14
    2c00:	96 01       	movw	r18, r12
    2c02:	41 d5       	rcall	.+2690   	; 0x3686 <__udivmodsi4>
    2c04:	c8 01       	movw	r24, r16
    2c06:	82 1b       	sub	r24, r18
    2c08:	93 0b       	sbc	r25, r19
    2c0a:	9c 01       	movw	r18, r24
		if(Moist != SensorReading.C_MOIST )
    2c0c:	8d a5       	ldd	r24, Y+45	; 0x2d
    2c0e:	90 e0       	ldi	r25, 0x00	; 0
    2c10:	28 17       	cp	r18, r24
    2c12:	39 07       	cpc	r19, r25
    2c14:	c1 f0       	breq	.+48     	; 0x2c46 <T_SOIL_Input+0x70>
		{
			SensorReading.C_MOIST = Moist;
    2c16:	2d a7       	std	Y+45, r18	; 0x2d
			if (SensorReading.LCDState == MAIN_STATE)
    2c18:	89 a9       	ldd	r24, Y+49	; 0x31
    2c1a:	81 11       	cpse	r24, r1
    2c1c:	0a c0       	rjmp	.+20     	; 0x2c32 <T_SOIL_Input+0x5c>
			{
				xEventGroupSetBits(egEvents,E_CMoistUpdate);
    2c1e:	44 e0       	ldi	r20, 0x04	; 4
    2c20:	50 e0       	ldi	r21, 0x00	; 0
    2c22:	60 e0       	ldi	r22, 0x00	; 0
    2c24:	70 e0       	ldi	r23, 0x00	; 0
    2c26:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2c2a:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2c2e:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
			}
			xEventGroupSetBits(egEvents,E_MoistCheck);
    2c32:	40 e0       	ldi	r20, 0x00	; 0
    2c34:	58 e0       	ldi	r21, 0x08	; 8
    2c36:	60 e0       	ldi	r22, 0x00	; 0
    2c38:	70 e0       	ldi	r23, 0x00	; 0
    2c3a:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2c3e:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2c42:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
		}
		vTaskDelay(10000);
    2c46:	60 e1       	ldi	r22, 0x10	; 16
    2c48:	77 e2       	ldi	r23, 0x27	; 39
    2c4a:	80 e0       	ldi	r24, 0x00	; 0
    2c4c:	90 e0       	ldi	r25, 0x00	; 0
    2c4e:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
	}
    2c52:	cd cf       	rjmp	.-102    	; 0x2bee <T_SOIL_Input+0x18>

00002c54 <T_PasswordCheck>:
		vTaskDelay(200);
	}
}

void T_PasswordCheck(void *pvinitData)
{
    2c54:	cf 93       	push	r28
    2c56:	df 93       	push	r29
    2c58:	00 d0       	rcall	.+0      	; 0x2c5a <T_PasswordCheck+0x6>
    2c5a:	00 d0       	rcall	.+0      	; 0x2c5c <T_PasswordCheck+0x8>
    2c5c:	1f 92       	push	r1
    2c5e:	cd b7       	in	r28, 0x3d	; 61
    2c60:	de b7       	in	r29, 0x3e	; 62
	u8 password[5]={0};
    2c62:	fe 01       	movw	r30, r28
    2c64:	31 96       	adiw	r30, 0x01	; 1
    2c66:	85 e0       	ldi	r24, 0x05	; 5
    2c68:	df 01       	movw	r26, r30
    2c6a:	1d 92       	st	X+, r1
    2c6c:	8a 95       	dec	r24
    2c6e:	e9 f7       	brne	.-6      	; 0x2c6a <T_PasswordCheck+0x16>
			{
				LCD_CLEAR();
				disp_strXY(2,1,(u8*)"Wrong Pass");
				vTaskDelay(1000);
			}
			SensorReading.LCDState=MAIN_STATE;
    2c70:	0f 2e       	mov	r0, r31
    2c72:	fc e1       	ldi	r31, 0x1C	; 28
    2c74:	ef 2e       	mov	r14, r31
    2c76:	f1 e0       	ldi	r31, 0x01	; 1
    2c78:	ff 2e       	mov	r15, r31
    2c7a:	f0 2d       	mov	r31, r0
	u8 password[5]={0};
	//EventBits_t state=0;
	while(1)
	{
		//state=xEventGroupWaitBits(egEvents,E_PassCheck,1,0,portMAX_DELAY);
		if (xSemaphoreTake(bsPassCheck,portMAX_DELAY))
    2c7c:	00 e0       	ldi	r16, 0x00	; 0
    2c7e:	2f ef       	ldi	r18, 0xFF	; 255
    2c80:	3f ef       	ldi	r19, 0xFF	; 255
    2c82:	a9 01       	movw	r20, r18
    2c84:	60 e0       	ldi	r22, 0x00	; 0
    2c86:	70 e0       	ldi	r23, 0x00	; 0
    2c88:	80 91 f1 0f 	lds	r24, 0x0FF1	; 0x800ff1 <bsPassCheck>
    2c8c:	90 91 f2 0f 	lds	r25, 0x0FF2	; 0x800ff2 <bsPassCheck+0x1>
    2c90:	0e 94 f6 09 	call	0x13ec	; 0x13ec <xQueueGenericReceive>
    2c94:	88 23       	and	r24, r24
    2c96:	91 f3       	breq	.-28     	; 0x2c7c <T_PasswordCheck+0x28>
		{
			xQueueReceive(mqPassword,password,100);
    2c98:	24 e6       	ldi	r18, 0x64	; 100
    2c9a:	30 e0       	ldi	r19, 0x00	; 0
    2c9c:	40 e0       	ldi	r20, 0x00	; 0
    2c9e:	50 e0       	ldi	r21, 0x00	; 0
    2ca0:	be 01       	movw	r22, r28
    2ca2:	6f 5f       	subi	r22, 0xFF	; 255
    2ca4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ca6:	80 91 ef 0f 	lds	r24, 0x0FEF	; 0x800fef <mqPassword>
    2caa:	90 91 f0 0f 	lds	r25, 0x0FF0	; 0x800ff0 <mqPassword+0x1>
    2cae:	0e 94 f6 09 	call	0x13ec	; 0x13ec <xQueueGenericReceive>
			if (strcmp((char*)oldpassword,(char*)password)==0)
    2cb2:	be 01       	movw	r22, r28
    2cb4:	6f 5f       	subi	r22, 0xFF	; 255
    2cb6:	7f 4f       	sbci	r23, 0xFF	; 255
    2cb8:	87 e1       	ldi	r24, 0x17	; 23
    2cba:	91 e0       	ldi	r25, 0x01	; 1
    2cbc:	4f d5       	rcall	.+2718   	; 0x375c <strcmp>
    2cbe:	89 2b       	or	r24, r25
    2cc0:	b9 f4       	brne	.+46     	; 0x2cf0 <T_PasswordCheck+0x9c>
			{
				LCD_CLEAR();
    2cc2:	0e 94 13 02 	call	0x426	; 0x426 <LCD_CLEAR>
				writePin(DOOR_LED,HIGH);//open door
    2cc6:	61 e0       	ldi	r22, 0x01	; 1
    2cc8:	84 e1       	ldi	r24, 0x14	; 20
    2cca:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
				disp_strXY(2,1,(u8*)"Pass accepted");
    2cce:	41 e2       	ldi	r20, 0x21	; 33
    2cd0:	53 e0       	ldi	r21, 0x03	; 3
    2cd2:	61 e0       	ldi	r22, 0x01	; 1
    2cd4:	82 e0       	ldi	r24, 0x02	; 2
    2cd6:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
				vTaskDelay(3000);
    2cda:	68 eb       	ldi	r22, 0xB8	; 184
    2cdc:	7b e0       	ldi	r23, 0x0B	; 11
    2cde:	80 e0       	ldi	r24, 0x00	; 0
    2ce0:	90 e0       	ldi	r25, 0x00	; 0
    2ce2:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
				writePin(DOOR_LED,LOW);//close door
    2ce6:	60 e0       	ldi	r22, 0x00	; 0
    2ce8:	84 e1       	ldi	r24, 0x14	; 20
    2cea:	0e 94 db 02 	call	0x5b6	; 0x5b6 <writePin>
    2cee:	0e c0       	rjmp	.+28     	; 0x2d0c <T_PasswordCheck+0xb8>
			}
			else
			{
				LCD_CLEAR();
    2cf0:	0e 94 13 02 	call	0x426	; 0x426 <LCD_CLEAR>
				disp_strXY(2,1,(u8*)"Wrong Pass");
    2cf4:	4f e2       	ldi	r20, 0x2F	; 47
    2cf6:	53 e0       	ldi	r21, 0x03	; 3
    2cf8:	61 e0       	ldi	r22, 0x01	; 1
    2cfa:	82 e0       	ldi	r24, 0x02	; 2
    2cfc:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
				vTaskDelay(1000);
    2d00:	68 ee       	ldi	r22, 0xE8	; 232
    2d02:	73 e0       	ldi	r23, 0x03	; 3
    2d04:	80 e0       	ldi	r24, 0x00	; 0
    2d06:	90 e0       	ldi	r25, 0x00	; 0
    2d08:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
			}
			SensorReading.LCDState=MAIN_STATE;
    2d0c:	f7 01       	movw	r30, r14
    2d0e:	11 aa       	std	Z+49, r1	; 0x31
			xEventGroupSetBits(egEvents,E_MainDisp);
    2d10:	40 e0       	ldi	r20, 0x00	; 0
    2d12:	52 e0       	ldi	r21, 0x02	; 2
    2d14:	60 e0       	ldi	r22, 0x00	; 0
    2d16:	70 e0       	ldi	r23, 0x00	; 0
    2d18:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2d1c:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2d20:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
			vTaskDelay(300);
    2d24:	6c e2       	ldi	r22, 0x2C	; 44
    2d26:	71 e0       	ldi	r23, 0x01	; 1
    2d28:	80 e0       	ldi	r24, 0x00	; 0
    2d2a:	90 e0       	ldi	r25, 0x00	; 0
    2d2c:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    2d30:	a5 cf       	rjmp	.-182    	; 0x2c7c <T_PasswordCheck+0x28>

00002d32 <T_SystemModify>:


/**********************************System Modifications************************************/

void T_SystemModify			(void *pvinitData)
{
    2d32:	cf 93       	push	r28
    2d34:	df 93       	push	r29
    2d36:	cd b7       	in	r28, 0x3d	; 61
    2d38:	de b7       	in	r29, 0x3e	; 62
    2d3a:	27 97       	sbiw	r28, 0x07	; 7
    2d3c:	0f b6       	in	r0, 0x3f	; 63
    2d3e:	f8 94       	cli
    2d40:	de bf       	out	0x3e, r29	; 62
    2d42:	0f be       	out	0x3f, r0	; 63
    2d44:	cd bf       	out	0x3d, r28	; 61
	u8 temp[7]={0};
    2d46:	fe 01       	movw	r30, r28
    2d48:	31 96       	adiw	r30, 0x01	; 1
    2d4a:	87 e0       	ldi	r24, 0x07	; 7
    2d4c:	df 01       	movw	r26, r30
    2d4e:	1d 92       	st	X+, r1
    2d50:	8a 95       	dec	r24
    2d52:	e9 f7       	brne	.-6      	; 0x2d4e <T_SystemModify+0x1c>
		/***********************************************************************************************************************************************************************************************************************************************************************/
		else if((state&E_GetTemp)==E_GetTemp)
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==TEMP_CONFIG_STATE)
    2d54:	0f 2e       	mov	r0, r31
    2d56:	fc e1       	ldi	r31, 0x1C	; 28
    2d58:	af 2e       	mov	r10, r31
    2d5a:	f1 e0       	ldi	r31, 0x01	; 1
    2d5c:	bf 2e       	mov	r11, r31
    2d5e:	f0 2d       	mov	r31, r0
	u8 index=0,keyPressed=0;

	EventBits_t state=0;
	while(1)
	{
		state = xEventGroupWaitBits(egEvents1,E_GetMoist|E_GetLight|E_GetTemp,1,0,250);
    2d60:	0f 2e       	mov	r0, r31
    2d62:	fa ef       	ldi	r31, 0xFA	; 250
    2d64:	cf 2e       	mov	r12, r31
    2d66:	d1 2c       	mov	r13, r1
    2d68:	e1 2c       	mov	r14, r1
    2d6a:	f1 2c       	mov	r15, r1
    2d6c:	f0 2d       	mov	r31, r0
    2d6e:	00 e0       	ldi	r16, 0x00	; 0
    2d70:	21 e0       	ldi	r18, 0x01	; 1
    2d72:	4c e1       	ldi	r20, 0x1C	; 28
    2d74:	50 e0       	ldi	r21, 0x00	; 0
    2d76:	60 e0       	ldi	r22, 0x00	; 0
    2d78:	70 e0       	ldi	r23, 0x00	; 0
    2d7a:	80 91 f5 0f 	lds	r24, 0x0FF5	; 0x800ff5 <egEvents1>
    2d7e:	90 91 f6 0f 	lds	r25, 0x0FF6	; 0x800ff6 <egEvents1+0x1>
    2d82:	0e 94 bf 04 	call	0x97e	; 0x97e <xEventGroupWaitBits>
		if((state&E_GetMoist)==E_GetMoist)
    2d86:	62 ff       	sbrs	r22, 2
    2d88:	74 c0       	rjmp	.+232    	; 0x2e72 <T_SystemModify+0x140>
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==MOIST_CONFIG_STATE)
    2d8a:	f5 01       	movw	r30, r10
    2d8c:	81 a9       	ldd	r24, Z+49	; 0x31
    2d8e:	87 30       	cpi	r24, 0x07	; 7
    2d90:	09 f0       	breq	.+2      	; 0x2d94 <T_SystemModify+0x62>
    2d92:	59 c1       	rjmp	.+690    	; 0x3046 <T_SystemModify+0x314>
    2d94:	10 e0       	ldi	r17, 0x00	; 0
			{
				keyPressed=GetKey();
    2d96:	0e 94 ab 01 	call	0x356	; 0x356 <GetKey>
				if(keyPressed != 0 && keyPressed !='#'&& keyPressed !='*')
    2d9a:	88 23       	and	r24, r24
    2d9c:	09 f4       	brne	.+2      	; 0x2da0 <T_SystemModify+0x6e>
    2d9e:	59 c0       	rjmp	.+178    	; 0x2e52 <T_SystemModify+0x120>
    2da0:	83 32       	cpi	r24, 0x23	; 35
    2da2:	09 f4       	brne	.+2      	; 0x2da6 <T_SystemModify+0x74>
    2da4:	40 c0       	rjmp	.+128    	; 0x2e26 <T_SystemModify+0xf4>
    2da6:	8a 32       	cpi	r24, 0x2A	; 42
    2da8:	b9 f0       	breq	.+46     	; 0x2dd8 <T_SystemModify+0xa6>
				{
					temp[index] = keyPressed;
    2daa:	e1 e0       	ldi	r30, 0x01	; 1
    2dac:	f0 e0       	ldi	r31, 0x00	; 0
    2dae:	ec 0f       	add	r30, r28
    2db0:	fd 1f       	adc	r31, r29
    2db2:	e1 0f       	add	r30, r17
    2db4:	f1 1d       	adc	r31, r1
    2db6:	80 83       	st	Z, r24
					disp_charXY(2,index+1,keyPressed);
    2db8:	1f 5f       	subi	r17, 0xFF	; 255
    2dba:	48 2f       	mov	r20, r24
    2dbc:	61 2f       	mov	r22, r17
    2dbe:	82 e0       	ldi	r24, 0x02	; 2
    2dc0:	0e 94 79 02 	call	0x4f2	; 0x4f2 <disp_charXY>
					index=0;

					SensorReading.LCDState = MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(100);
    2dc4:	64 e6       	ldi	r22, 0x64	; 100
    2dc6:	70 e0       	ldi	r23, 0x00	; 0
    2dc8:	80 e0       	ldi	r24, 0x00	; 0
    2dca:	90 e0       	ldi	r25, 0x00	; 0
    2dcc:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
		state = xEventGroupWaitBits(egEvents1,E_GetMoist|E_GetLight|E_GetTemp,1,0,250);
		if((state&E_GetMoist)==E_GetMoist)
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==MOIST_CONFIG_STATE)
    2dd0:	14 30       	cpi	r17, 0x04	; 4
    2dd2:	08 f4       	brcc	.+2      	; 0x2dd6 <T_SystemModify+0xa4>
    2dd4:	47 c0       	rjmp	.+142    	; 0x2e64 <T_SystemModify+0x132>
    2dd6:	37 c1       	rjmp	.+622    	; 0x3046 <T_SystemModify+0x314>
					index++;
					keyPressed=0;
				}
				else if(keyPressed =='*')
				{
					SensorReading.T_MOIST = atoi(temp);
    2dd8:	ce 01       	movw	r24, r28
    2dda:	01 96       	adiw	r24, 0x01	; 1
    2ddc:	8e d4       	rcall	.+2332   	; 0x36fa <atoi>
    2dde:	d5 01       	movw	r26, r10
    2de0:	9e 96       	adiw	r26, 0x2e	; 46
    2de2:	8c 93       	st	X, r24
    2de4:	9e 97       	sbiw	r26, 0x2e	; 46
					for(index=0;index<3;index++)
					{
						temp[index] = 0;
    2de6:	19 82       	std	Y+1, r1	; 0x01
    2de8:	1a 82       	std	Y+2, r1	; 0x02
    2dea:	1b 82       	std	Y+3, r1	; 0x03
					}
					index=0;

					SensorReading.LCDState = MAIN_STATE;
    2dec:	d1 96       	adiw	r26, 0x31	; 49
    2dee:	1c 92       	st	X, r1
					xEventGroupSetBits(egEvents,E_MainDisp);
    2df0:	40 e0       	ldi	r20, 0x00	; 0
    2df2:	52 e0       	ldi	r21, 0x02	; 2
    2df4:	60 e0       	ldi	r22, 0x00	; 0
    2df6:	70 e0       	ldi	r23, 0x00	; 0
    2df8:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2dfc:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2e00:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
					xEventGroupSetBits(egEvents,E_MoistCheck);
    2e04:	40 e0       	ldi	r20, 0x00	; 0
    2e06:	58 e0       	ldi	r21, 0x08	; 8
    2e08:	60 e0       	ldi	r22, 0x00	; 0
    2e0a:	70 e0       	ldi	r23, 0x00	; 0
    2e0c:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2e10:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2e14:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
					index=0;

					SensorReading.LCDState = MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(100);
    2e18:	64 e6       	ldi	r22, 0x64	; 100
    2e1a:	70 e0       	ldi	r23, 0x00	; 0
    2e1c:	80 e0       	ldi	r24, 0x00	; 0
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    2e24:	10 c1       	rjmp	.+544    	; 0x3046 <T_SystemModify+0x314>
				}
				else if(keyPressed == '#')
				{
					for(index=0;index<3;index++)
					{
						temp[index] = 0;
    2e26:	19 82       	std	Y+1, r1	; 0x01
    2e28:	1a 82       	std	Y+2, r1	; 0x02
    2e2a:	1b 82       	std	Y+3, r1	; 0x03
					}
					index=0;

					SensorReading.LCDState = MAIN_STATE;
    2e2c:	f5 01       	movw	r30, r10
    2e2e:	11 aa       	std	Z+49, r1	; 0x31
					xEventGroupSetBits(egEvents,E_MainDisp);
    2e30:	40 e0       	ldi	r20, 0x00	; 0
    2e32:	52 e0       	ldi	r21, 0x02	; 2
    2e34:	60 e0       	ldi	r22, 0x00	; 0
    2e36:	70 e0       	ldi	r23, 0x00	; 0
    2e38:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2e3c:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2e40:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				}
				vTaskDelay(100);
    2e44:	64 e6       	ldi	r22, 0x64	; 100
    2e46:	70 e0       	ldi	r23, 0x00	; 0
    2e48:	80 e0       	ldi	r24, 0x00	; 0
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    2e50:	fa c0       	rjmp	.+500    	; 0x3046 <T_SystemModify+0x314>
    2e52:	64 e6       	ldi	r22, 0x64	; 100
    2e54:	70 e0       	ldi	r23, 0x00	; 0
    2e56:	80 e0       	ldi	r24, 0x00	; 0
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
		state = xEventGroupWaitBits(egEvents1,E_GetMoist|E_GetLight|E_GetTemp,1,0,250);
		if((state&E_GetMoist)==E_GetMoist)
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==MOIST_CONFIG_STATE)
    2e5e:	14 30       	cpi	r17, 0x04	; 4
    2e60:	08 f0       	brcs	.+2      	; 0x2e64 <T_SystemModify+0x132>
    2e62:	f1 c0       	rjmp	.+482    	; 0x3046 <T_SystemModify+0x314>
    2e64:	d5 01       	movw	r26, r10
    2e66:	d1 96       	adiw	r26, 0x31	; 49
    2e68:	8c 91       	ld	r24, X
    2e6a:	87 30       	cpi	r24, 0x07	; 7
    2e6c:	09 f4       	brne	.+2      	; 0x2e70 <T_SystemModify+0x13e>
    2e6e:	93 cf       	rjmp	.-218    	; 0x2d96 <T_SystemModify+0x64>
    2e70:	ea c0       	rjmp	.+468    	; 0x3046 <T_SystemModify+0x314>
				}
				vTaskDelay(100);
			}
		}//end of MOIST
		/***********************************************************************************************************************************************************************************************************************************************************************/
		else if((state&E_GetLight)==E_GetLight)
    2e72:	63 ff       	sbrs	r22, 3
    2e74:	74 c0       	rjmp	.+232    	; 0x2f5e <T_SystemModify+0x22c>
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==LIGHT_CUTOFF_STATE)
    2e76:	f5 01       	movw	r30, r10
    2e78:	81 a9       	ldd	r24, Z+49	; 0x31
    2e7a:	86 30       	cpi	r24, 0x06	; 6
    2e7c:	09 f0       	breq	.+2      	; 0x2e80 <T_SystemModify+0x14e>
    2e7e:	e3 c0       	rjmp	.+454    	; 0x3046 <T_SystemModify+0x314>
    2e80:	10 e0       	ldi	r17, 0x00	; 0
			{
				keyPressed=GetKey();
    2e82:	0e 94 ab 01 	call	0x356	; 0x356 <GetKey>
				if(keyPressed != 0 && keyPressed !='#'&& keyPressed !='*')
    2e86:	88 23       	and	r24, r24
    2e88:	09 f4       	brne	.+2      	; 0x2e8c <T_SystemModify+0x15a>
    2e8a:	59 c0       	rjmp	.+178    	; 0x2f3e <T_SystemModify+0x20c>
    2e8c:	83 32       	cpi	r24, 0x23	; 35
    2e8e:	09 f4       	brne	.+2      	; 0x2e92 <T_SystemModify+0x160>
    2e90:	40 c0       	rjmp	.+128    	; 0x2f12 <T_SystemModify+0x1e0>
    2e92:	8a 32       	cpi	r24, 0x2A	; 42
    2e94:	b9 f0       	breq	.+46     	; 0x2ec4 <T_SystemModify+0x192>
				{
					temp[index] = keyPressed;
    2e96:	e1 e0       	ldi	r30, 0x01	; 1
    2e98:	f0 e0       	ldi	r31, 0x00	; 0
    2e9a:	ec 0f       	add	r30, r28
    2e9c:	fd 1f       	adc	r31, r29
    2e9e:	e1 0f       	add	r30, r17
    2ea0:	f1 1d       	adc	r31, r1
    2ea2:	80 83       	st	Z, r24
					disp_charXY(2,index+1,keyPressed);
    2ea4:	1f 5f       	subi	r17, 0xFF	; 255
    2ea6:	48 2f       	mov	r20, r24
    2ea8:	61 2f       	mov	r22, r17
    2eaa:	82 e0       	ldi	r24, 0x02	; 2
    2eac:	0e 94 79 02 	call	0x4f2	; 0x4f2 <disp_charXY>
					index=0;

					SensorReading.LCDState = MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(100);
    2eb0:	64 e6       	ldi	r22, 0x64	; 100
    2eb2:	70 e0       	ldi	r23, 0x00	; 0
    2eb4:	80 e0       	ldi	r24, 0x00	; 0
    2eb6:	90 e0       	ldi	r25, 0x00	; 0
    2eb8:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
		/***********************************************************************************************************************************************************************************************************************************************************************/
		else if((state&E_GetLight)==E_GetLight)
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==LIGHT_CUTOFF_STATE)
    2ebc:	14 30       	cpi	r17, 0x04	; 4
    2ebe:	08 f4       	brcc	.+2      	; 0x2ec2 <T_SystemModify+0x190>
    2ec0:	47 c0       	rjmp	.+142    	; 0x2f50 <T_SystemModify+0x21e>
    2ec2:	c1 c0       	rjmp	.+386    	; 0x3046 <T_SystemModify+0x314>
					index++;
					keyPressed=0;
				}
				else if(keyPressed =='*')
				{
					SensorReading.T_LDR = atoi(temp);
    2ec4:	ce 01       	movw	r24, r28
    2ec6:	01 96       	adiw	r24, 0x01	; 1
    2ec8:	18 d4       	rcall	.+2096   	; 0x36fa <atoi>
    2eca:	d5 01       	movw	r26, r10
    2ecc:	d0 96       	adiw	r26, 0x30	; 48
    2ece:	8c 93       	st	X, r24
    2ed0:	d0 97       	sbiw	r26, 0x30	; 48
					for(index=0;index<3;index++)
					{
						temp[index] = 0;
    2ed2:	19 82       	std	Y+1, r1	; 0x01
    2ed4:	1a 82       	std	Y+2, r1	; 0x02
    2ed6:	1b 82       	std	Y+3, r1	; 0x03
					}
					index=0;

					SensorReading.LCDState = MAIN_STATE;
    2ed8:	d1 96       	adiw	r26, 0x31	; 49
    2eda:	1c 92       	st	X, r1
					xEventGroupSetBits(egEvents,E_MainDisp);
    2edc:	40 e0       	ldi	r20, 0x00	; 0
    2ede:	52 e0       	ldi	r21, 0x02	; 2
    2ee0:	60 e0       	ldi	r22, 0x00	; 0
    2ee2:	70 e0       	ldi	r23, 0x00	; 0
    2ee4:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2ee8:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2eec:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
					xEventGroupSetBits(egEvents,E_lightCheck);
    2ef0:	40 e0       	ldi	r20, 0x00	; 0
    2ef2:	50 e1       	ldi	r21, 0x10	; 16
    2ef4:	60 e0       	ldi	r22, 0x00	; 0
    2ef6:	70 e0       	ldi	r23, 0x00	; 0
    2ef8:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2efc:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2f00:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
					index=0;

					SensorReading.LCDState = MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(100);
    2f04:	64 e6       	ldi	r22, 0x64	; 100
    2f06:	70 e0       	ldi	r23, 0x00	; 0
    2f08:	80 e0       	ldi	r24, 0x00	; 0
    2f0a:	90 e0       	ldi	r25, 0x00	; 0
    2f0c:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    2f10:	9a c0       	rjmp	.+308    	; 0x3046 <T_SystemModify+0x314>
				}
				else if(keyPressed == '#')
				{
					for(index=0;index<3;index++)
					{
						temp[index] = 0;
    2f12:	19 82       	std	Y+1, r1	; 0x01
    2f14:	1a 82       	std	Y+2, r1	; 0x02
    2f16:	1b 82       	std	Y+3, r1	; 0x03
					}
					index=0;

					SensorReading.LCDState = MAIN_STATE;
    2f18:	f5 01       	movw	r30, r10
    2f1a:	11 aa       	std	Z+49, r1	; 0x31
					xEventGroupSetBits(egEvents,E_MainDisp);
    2f1c:	40 e0       	ldi	r20, 0x00	; 0
    2f1e:	52 e0       	ldi	r21, 0x02	; 2
    2f20:	60 e0       	ldi	r22, 0x00	; 0
    2f22:	70 e0       	ldi	r23, 0x00	; 0
    2f24:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2f28:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2f2c:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				}
				vTaskDelay(100);
    2f30:	64 e6       	ldi	r22, 0x64	; 100
    2f32:	70 e0       	ldi	r23, 0x00	; 0
    2f34:	80 e0       	ldi	r24, 0x00	; 0
    2f36:	90 e0       	ldi	r25, 0x00	; 0
    2f38:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    2f3c:	84 c0       	rjmp	.+264    	; 0x3046 <T_SystemModify+0x314>
    2f3e:	64 e6       	ldi	r22, 0x64	; 100
    2f40:	70 e0       	ldi	r23, 0x00	; 0
    2f42:	80 e0       	ldi	r24, 0x00	; 0
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
		/***********************************************************************************************************************************************************************************************************************************************************************/
		else if((state&E_GetLight)==E_GetLight)
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==LIGHT_CUTOFF_STATE)
    2f4a:	14 30       	cpi	r17, 0x04	; 4
    2f4c:	08 f0       	brcs	.+2      	; 0x2f50 <T_SystemModify+0x21e>
    2f4e:	7b c0       	rjmp	.+246    	; 0x3046 <T_SystemModify+0x314>
    2f50:	d5 01       	movw	r26, r10
    2f52:	d1 96       	adiw	r26, 0x31	; 49
    2f54:	8c 91       	ld	r24, X
    2f56:	86 30       	cpi	r24, 0x06	; 6
    2f58:	09 f4       	brne	.+2      	; 0x2f5c <T_SystemModify+0x22a>
    2f5a:	93 cf       	rjmp	.-218    	; 0x2e82 <T_SystemModify+0x150>
    2f5c:	74 c0       	rjmp	.+232    	; 0x3046 <T_SystemModify+0x314>
				}
				vTaskDelay(100);
			}
		}
		/***********************************************************************************************************************************************************************************************************************************************************************/
		else if((state&E_GetTemp)==E_GetTemp)
    2f5e:	64 ff       	sbrs	r22, 4
    2f60:	72 c0       	rjmp	.+228    	; 0x3046 <T_SystemModify+0x314>
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==TEMP_CONFIG_STATE)
    2f62:	f5 01       	movw	r30, r10
    2f64:	81 a9       	ldd	r24, Z+49	; 0x31
    2f66:	85 30       	cpi	r24, 0x05	; 5
    2f68:	09 f0       	breq	.+2      	; 0x2f6c <T_SystemModify+0x23a>
    2f6a:	6d c0       	rjmp	.+218    	; 0x3046 <T_SystemModify+0x314>
    2f6c:	10 e0       	ldi	r17, 0x00	; 0
			{
				keyPressed=GetKey();
    2f6e:	0e 94 ab 01 	call	0x356	; 0x356 <GetKey>
				if(keyPressed != 0 && keyPressed !='#'&& keyPressed !='*')
    2f72:	88 23       	and	r24, r24
    2f74:	09 f4       	brne	.+2      	; 0x2f78 <T_SystemModify+0x246>
    2f76:	59 c0       	rjmp	.+178    	; 0x302a <T_SystemModify+0x2f8>
    2f78:	83 32       	cpi	r24, 0x23	; 35
    2f7a:	09 f4       	brne	.+2      	; 0x2f7e <T_SystemModify+0x24c>
    2f7c:	40 c0       	rjmp	.+128    	; 0x2ffe <T_SystemModify+0x2cc>
    2f7e:	8a 32       	cpi	r24, 0x2A	; 42
    2f80:	b9 f0       	breq	.+46     	; 0x2fb0 <T_SystemModify+0x27e>
				{
					temp[index] = keyPressed;
    2f82:	e1 e0       	ldi	r30, 0x01	; 1
    2f84:	f0 e0       	ldi	r31, 0x00	; 0
    2f86:	ec 0f       	add	r30, r28
    2f88:	fd 1f       	adc	r31, r29
    2f8a:	e1 0f       	add	r30, r17
    2f8c:	f1 1d       	adc	r31, r1
    2f8e:	80 83       	st	Z, r24
					disp_charXY(2,index+1,keyPressed);
    2f90:	1f 5f       	subi	r17, 0xFF	; 255
    2f92:	48 2f       	mov	r20, r24
    2f94:	61 2f       	mov	r22, r17
    2f96:	82 e0       	ldi	r24, 0x02	; 2
    2f98:	0e 94 79 02 	call	0x4f2	; 0x4f2 <disp_charXY>
					index=0;

					SensorReading.LCDState = MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(100);
    2f9c:	64 e6       	ldi	r22, 0x64	; 100
    2f9e:	70 e0       	ldi	r23, 0x00	; 0
    2fa0:	80 e0       	ldi	r24, 0x00	; 0
    2fa2:	90 e0       	ldi	r25, 0x00	; 0
    2fa4:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
		/***********************************************************************************************************************************************************************************************************************************************************************/
		else if((state&E_GetTemp)==E_GetTemp)
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==TEMP_CONFIG_STATE)
    2fa8:	14 30       	cpi	r17, 0x04	; 4
    2faa:	08 f4       	brcc	.+2      	; 0x2fae <T_SystemModify+0x27c>
    2fac:	46 c0       	rjmp	.+140    	; 0x303a <T_SystemModify+0x308>
    2fae:	4b c0       	rjmp	.+150    	; 0x3046 <T_SystemModify+0x314>
					index++;
					keyPressed=0;
				}
				else if(keyPressed =='*')
				{
					strcpy(SensorReading.T_TEMP,temp);
    2fb0:	be 01       	movw	r22, r28
    2fb2:	6f 5f       	subi	r22, 0xFF	; 255
    2fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb6:	8b e2       	ldi	r24, 0x2B	; 43
    2fb8:	91 e0       	ldi	r25, 0x01	; 1
    2fba:	d9 d3       	rcall	.+1970   	; 0x376e <strcpy>
					for(index=0;index<3;index++)
					{
						temp[index] = 0;
    2fbc:	19 82       	std	Y+1, r1	; 0x01
    2fbe:	1a 82       	std	Y+2, r1	; 0x02
    2fc0:	1b 82       	std	Y+3, r1	; 0x03
					}
					index=0;

					SensorReading.LCDState = MAIN_STATE;
    2fc2:	d5 01       	movw	r26, r10
    2fc4:	d1 96       	adiw	r26, 0x31	; 49
    2fc6:	1c 92       	st	X, r1
					xEventGroupSetBits(egEvents,E_MainDisp);
    2fc8:	40 e0       	ldi	r20, 0x00	; 0
    2fca:	52 e0       	ldi	r21, 0x02	; 2
    2fcc:	60 e0       	ldi	r22, 0x00	; 0
    2fce:	70 e0       	ldi	r23, 0x00	; 0
    2fd0:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2fd4:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2fd8:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
					xEventGroupSetBits(egEvents,E_TempCheck);
    2fdc:	40 e0       	ldi	r20, 0x00	; 0
    2fde:	54 e0       	ldi	r21, 0x04	; 4
    2fe0:	60 e0       	ldi	r22, 0x00	; 0
    2fe2:	70 e0       	ldi	r23, 0x00	; 0
    2fe4:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    2fe8:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    2fec:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
					index=0;

					SensorReading.LCDState = MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(100);
    2ff0:	64 e6       	ldi	r22, 0x64	; 100
    2ff2:	70 e0       	ldi	r23, 0x00	; 0
    2ff4:	80 e0       	ldi	r24, 0x00	; 0
    2ff6:	90 e0       	ldi	r25, 0x00	; 0
    2ff8:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    2ffc:	24 c0       	rjmp	.+72     	; 0x3046 <T_SystemModify+0x314>
				}
				else if(keyPressed == '#')
				{
					for(index=0;index<3;index++)
					{
						temp[index] = 0;
    2ffe:	19 82       	std	Y+1, r1	; 0x01
    3000:	1a 82       	std	Y+2, r1	; 0x02
    3002:	1b 82       	std	Y+3, r1	; 0x03
					}
					index=0;

					SensorReading.LCDState = MAIN_STATE;
    3004:	f5 01       	movw	r30, r10
    3006:	11 aa       	std	Z+49, r1	; 0x31
					xEventGroupSetBits(egEvents,E_MainDisp);
    3008:	40 e0       	ldi	r20, 0x00	; 0
    300a:	52 e0       	ldi	r21, 0x02	; 2
    300c:	60 e0       	ldi	r22, 0x00	; 0
    300e:	70 e0       	ldi	r23, 0x00	; 0
    3010:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    3014:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    3018:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				}
				vTaskDelay(100);
    301c:	64 e6       	ldi	r22, 0x64	; 100
    301e:	70 e0       	ldi	r23, 0x00	; 0
    3020:	80 e0       	ldi	r24, 0x00	; 0
    3022:	90 e0       	ldi	r25, 0x00	; 0
    3024:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    3028:	0e c0       	rjmp	.+28     	; 0x3046 <T_SystemModify+0x314>
    302a:	64 e6       	ldi	r22, 0x64	; 100
    302c:	70 e0       	ldi	r23, 0x00	; 0
    302e:	80 e0       	ldi	r24, 0x00	; 0
    3030:	90 e0       	ldi	r25, 0x00	; 0
    3032:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
		/***********************************************************************************************************************************************************************************************************************************************************************/
		else if((state&E_GetTemp)==E_GetTemp)
		{
			index=0;
			keyPressed=0;
			while(index<4 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==TEMP_CONFIG_STATE)
    3036:	14 30       	cpi	r17, 0x04	; 4
    3038:	30 f4       	brcc	.+12     	; 0x3046 <T_SystemModify+0x314>
    303a:	d5 01       	movw	r26, r10
    303c:	d1 96       	adiw	r26, 0x31	; 49
    303e:	8c 91       	ld	r24, X
    3040:	85 30       	cpi	r24, 0x05	; 5
    3042:	09 f4       	brne	.+2      	; 0x3046 <T_SystemModify+0x314>
    3044:	94 cf       	rjmp	.-216    	; 0x2f6e <T_SystemModify+0x23c>
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(100);
			}
		}
		vTaskDelay(200);
    3046:	68 ec       	ldi	r22, 0xC8	; 200
    3048:	70 e0       	ldi	r23, 0x00	; 0
    304a:	80 e0       	ldi	r24, 0x00	; 0
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
	}//while
    3052:	86 ce       	rjmp	.-756    	; 0x2d60 <T_SystemModify+0x2e>

00003054 <T_PasswordGet>:
			vTaskDelay(500);
		}
	}
}
/*************************************************************************************Door system control***************************************************************************************************/
void T_PasswordGet(void *pvinitData){
    3054:	cf 93       	push	r28
    3056:	df 93       	push	r29
    3058:	00 d0       	rcall	.+0      	; 0x305a <T_PasswordGet+0x6>
    305a:	00 d0       	rcall	.+0      	; 0x305c <T_PasswordGet+0x8>
    305c:	1f 92       	push	r1
    305e:	cd b7       	in	r28, 0x3d	; 61
    3060:	de b7       	in	r29, 0x3e	; 62
	u8 password[5]	=	{0};
    3062:	fe 01       	movw	r30, r28
    3064:	31 96       	adiw	r30, 0x01	; 1
    3066:	85 e0       	ldi	r24, 0x05	; 5
    3068:	df 01       	movw	r26, r30
    306a:	1d 92       	st	X+, r1
    306c:	8a 95       	dec	r24
    306e:	e9 f7       	brne	.-6      	; 0x306a <T_PasswordGet+0x16>
		//if ((state&E_UIDOOR)==E_UIDOOR)
		if(xSemaphoreTake(bsPassEntered,1000))
		{
			keyPressed=0;
			counter=0;
			while (counter<5 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==GET_PASS_STATE)
    3070:	0f 2e       	mov	r0, r31
    3072:	fc e1       	ldi	r31, 0x1C	; 28
    3074:	ef 2e       	mov	r14, r31
    3076:	f1 e0       	ldi	r31, 0x01	; 1
    3078:	ff 2e       	mov	r15, r31
    307a:	f0 2d       	mov	r31, r0
					password[counter]=keyPressed;
					disp_charXY(2,counter+1,keyPressed);
					keyPressed=0;
					counter++;
				}//end if
				else if(keyPressed=='*' || (counter==(strlen(oldpassword))))
    307c:	0f 2e       	mov	r0, r31
    307e:	f7 e1       	ldi	r31, 0x17	; 23
    3080:	cf 2e       	mov	r12, r31
    3082:	f1 e0       	ldi	r31, 0x01	; 1
    3084:	df 2e       	mov	r13, r31
    3086:	f0 2d       	mov	r31, r0
	//EventBits_t state=0;
	while(1)
	{
		//state=xEventGroupWaitBits(egEvents,E_UIDOOR,0,0,1000);
		//if ((state&E_UIDOOR)==E_UIDOOR)
		if(xSemaphoreTake(bsPassEntered,1000))
    3088:	00 e0       	ldi	r16, 0x00	; 0
    308a:	28 ee       	ldi	r18, 0xE8	; 232
    308c:	33 e0       	ldi	r19, 0x03	; 3
    308e:	40 e0       	ldi	r20, 0x00	; 0
    3090:	50 e0       	ldi	r21, 0x00	; 0
    3092:	60 e0       	ldi	r22, 0x00	; 0
    3094:	70 e0       	ldi	r23, 0x00	; 0
    3096:	80 91 f3 0f 	lds	r24, 0x0FF3	; 0x800ff3 <bsPassEntered>
    309a:	90 91 f4 0f 	lds	r25, 0x0FF4	; 0x800ff4 <bsPassEntered+0x1>
    309e:	0e 94 f6 09 	call	0x13ec	; 0x13ec <xQueueGenericReceive>
    30a2:	88 23       	and	r24, r24
    30a4:	c1 f1       	breq	.+112    	; 0x3116 <T_PasswordGet+0xc2>
		{
			keyPressed=0;
			counter=0;
			while (counter<5 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==GET_PASS_STATE)
    30a6:	f7 01       	movw	r30, r14
    30a8:	81 a9       	ldd	r24, Z+49	; 0x31
    30aa:	82 30       	cpi	r24, 0x02	; 2
    30ac:	a1 f5       	brne	.+104    	; 0x3116 <T_PasswordGet+0xc2>
    30ae:	10 e0       	ldi	r17, 0x00	; 0
			{
				
				keyPressed=GetKey();
    30b0:	0e 94 ab 01 	call	0x356	; 0x356 <GetKey>
				
				if (keyPressed!='#' && keyPressed!=0 && keyPressed!='*')
    30b4:	83 32       	cpi	r24, 0x23	; 35
    30b6:	09 f4       	brne	.+2      	; 0x30ba <T_PasswordGet+0x66>
    30b8:	94 c0       	rjmp	.+296    	; 0x31e2 <T_PasswordGet+0x18e>
    30ba:	88 23       	and	r24, r24
    30bc:	09 f4       	brne	.+2      	; 0x30c0 <T_PasswordGet+0x6c>
    30be:	60 c0       	rjmp	.+192    	; 0x3180 <T_PasswordGet+0x12c>
    30c0:	8a 32       	cpi	r24, 0x2A	; 42
    30c2:	09 f4       	brne	.+2      	; 0x30c6 <T_PasswordGet+0x72>
    30c4:	9c c0       	rjmp	.+312    	; 0x31fe <T_PasswordGet+0x1aa>
				{
					password[counter]=keyPressed;
    30c6:	e1 e0       	ldi	r30, 0x01	; 1
    30c8:	f0 e0       	ldi	r31, 0x00	; 0
    30ca:	ec 0f       	add	r30, r28
    30cc:	fd 1f       	adc	r31, r29
    30ce:	e1 0f       	add	r30, r17
    30d0:	f1 1d       	adc	r31, r1
    30d2:	80 83       	st	Z, r24
					disp_charXY(2,counter+1,keyPressed);
    30d4:	1f 5f       	subi	r17, 0xFF	; 255
    30d6:	48 2f       	mov	r20, r24
    30d8:	61 2f       	mov	r22, r17
    30da:	82 e0       	ldi	r24, 0x02	; 2
    30dc:	0e 94 79 02 	call	0x4f2	; 0x4f2 <disp_charXY>
					keyPressed=0;
					counter++;
    30e0:	21 c0       	rjmp	.+66     	; 0x3124 <T_PasswordGet+0xd0>
					password[1]=0;
					password[2]=0;
					password[3]=0;
					xSemaphoreGive(bsPassCheck);
				}
				else if(keyPressed=='#')
    30e2:	83 32       	cpi	r24, 0x23	; 35
    30e4:	f9 f4       	brne	.+62     	; 0x3124 <T_PasswordGet+0xd0>
				{
					SensorReading.LCDState=MAIN_STATE;
    30e6:	d7 01       	movw	r26, r14
    30e8:	d1 96       	adiw	r26, 0x31	; 49
    30ea:	1c 92       	st	X, r1
					xEventGroupSetBits(egEvents,E_MainDisp);
    30ec:	40 e0       	ldi	r20, 0x00	; 0
    30ee:	52 e0       	ldi	r21, 0x02	; 2
    30f0:	60 e0       	ldi	r22, 0x00	; 0
    30f2:	70 e0       	ldi	r23, 0x00	; 0
    30f4:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    30f8:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    30fc:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				}
				vTaskDelay(200);
    3100:	68 ec       	ldi	r22, 0xC8	; 200
    3102:	70 e0       	ldi	r23, 0x00	; 0
    3104:	80 e0       	ldi	r24, 0x00	; 0
    3106:	90 e0       	ldi	r25, 0x00	; 0
    3108:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    310c:	04 c0       	rjmp	.+8      	; 0x3116 <T_PasswordGet+0xc2>
		//if ((state&E_UIDOOR)==E_UIDOOR)
		if(xSemaphoreTake(bsPassEntered,1000))
		{
			keyPressed=0;
			counter=0;
			while (counter<5 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==GET_PASS_STATE)
    310e:	f7 01       	movw	r30, r14
    3110:	81 a9       	ldd	r24, Z+49	; 0x31
    3112:	82 30       	cpi	r24, 0x02	; 2
    3114:	69 f2       	breq	.-102    	; 0x30b0 <T_PasswordGet+0x5c>
				vTaskDelay(200);
			}
			
		}//if semaphor
		
		vTaskDelay(200);
    3116:	68 ec       	ldi	r22, 0xC8	; 200
    3118:	70 e0       	ldi	r23, 0x00	; 0
    311a:	80 e0       	ldi	r24, 0x00	; 0
    311c:	90 e0       	ldi	r25, 0x00	; 0
    311e:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
	}
    3122:	b2 cf       	rjmp	.-156    	; 0x3088 <T_PasswordGet+0x34>
				else if(keyPressed=='#')
				{
					SensorReading.LCDState=MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(200);
    3124:	68 ec       	ldi	r22, 0xC8	; 200
    3126:	70 e0       	ldi	r23, 0x00	; 0
    3128:	80 e0       	ldi	r24, 0x00	; 0
    312a:	90 e0       	ldi	r25, 0x00	; 0
    312c:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
		//if ((state&E_UIDOOR)==E_UIDOOR)
		if(xSemaphoreTake(bsPassEntered,1000))
		{
			keyPressed=0;
			counter=0;
			while (counter<5 && keyPressed !='#'&& keyPressed !='*' &&SensorReading.LCDState==GET_PASS_STATE)
    3130:	15 30       	cpi	r17, 0x05	; 5
    3132:	68 f3       	brcs	.-38     	; 0x310e <T_PasswordGet+0xba>
    3134:	f0 cf       	rjmp	.-32     	; 0x3116 <T_PasswordGet+0xc2>
					counter++;
				}//end if
				else if(keyPressed=='*' || (counter==(strlen(oldpassword))))
				{
					counter=0;
					xQueueSend(mqPassword,password,300);
    3136:	00 e0       	ldi	r16, 0x00	; 0
    3138:	2c e2       	ldi	r18, 0x2C	; 44
    313a:	31 e0       	ldi	r19, 0x01	; 1
    313c:	40 e0       	ldi	r20, 0x00	; 0
    313e:	50 e0       	ldi	r21, 0x00	; 0
    3140:	be 01       	movw	r22, r28
    3142:	6f 5f       	subi	r22, 0xFF	; 255
    3144:	7f 4f       	sbci	r23, 0xFF	; 255
    3146:	80 91 ef 0f 	lds	r24, 0x0FEF	; 0x800fef <mqPassword>
    314a:	90 91 f0 0f 	lds	r25, 0x0FF0	; 0x800ff0 <mqPassword+0x1>
    314e:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xQueueGenericSend>
					password[0]=0;
    3152:	19 82       	std	Y+1, r1	; 0x01
					password[1]=0;
    3154:	1a 82       	std	Y+2, r1	; 0x02
					password[2]=0;
    3156:	1b 82       	std	Y+3, r1	; 0x03
					password[3]=0;
    3158:	1c 82       	std	Y+4, r1	; 0x04
					xSemaphoreGive(bsPassCheck);
    315a:	20 e0       	ldi	r18, 0x00	; 0
    315c:	30 e0       	ldi	r19, 0x00	; 0
    315e:	a9 01       	movw	r20, r18
    3160:	60 e0       	ldi	r22, 0x00	; 0
    3162:	70 e0       	ldi	r23, 0x00	; 0
    3164:	80 91 f1 0f 	lds	r24, 0x0FF1	; 0x800ff1 <bsPassCheck>
    3168:	90 91 f2 0f 	lds	r25, 0x0FF2	; 0x800ff2 <bsPassCheck+0x1>
    316c:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xQueueGenericSend>
				else if(keyPressed=='#')
				{
					SensorReading.LCDState=MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(200);
    3170:	68 ec       	ldi	r22, 0xC8	; 200
    3172:	70 e0       	ldi	r23, 0x00	; 0
    3174:	80 e0       	ldi	r24, 0x00	; 0
    3176:	90 e0       	ldi	r25, 0x00	; 0
    3178:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
					keyPressed=0;
					counter++;
				}//end if
				else if(keyPressed=='*' || (counter==(strlen(oldpassword))))
				{
					counter=0;
    317c:	10 e0       	ldi	r17, 0x00	; 0
    317e:	c7 cf       	rjmp	.-114    	; 0x310e <T_PasswordGet+0xba>
					password[counter]=keyPressed;
					disp_charXY(2,counter+1,keyPressed);
					keyPressed=0;
					counter++;
				}//end if
				else if(keyPressed=='*' || (counter==(strlen(oldpassword))))
    3180:	f6 01       	movw	r30, r12
    3182:	01 90       	ld	r0, Z+
    3184:	00 20       	and	r0, r0
    3186:	e9 f7       	brne	.-6      	; 0x3182 <T_PasswordGet+0x12e>
    3188:	31 97       	sbiw	r30, 0x01	; 1
    318a:	e7 51       	subi	r30, 0x17	; 23
    318c:	f1 40       	sbci	r31, 0x01	; 1
    318e:	21 2f       	mov	r18, r17
    3190:	30 e0       	ldi	r19, 0x00	; 0
    3192:	2e 17       	cp	r18, r30
    3194:	3f 07       	cpc	r19, r31
    3196:	79 f2       	breq	.-98     	; 0x3136 <T_PasswordGet+0xe2>
    3198:	a4 cf       	rjmp	.-184    	; 0x30e2 <T_PasswordGet+0x8e>
				{
					counter=0;
					xQueueSend(mqPassword,password,300);
    319a:	00 e0       	ldi	r16, 0x00	; 0
    319c:	2c e2       	ldi	r18, 0x2C	; 44
    319e:	31 e0       	ldi	r19, 0x01	; 1
    31a0:	40 e0       	ldi	r20, 0x00	; 0
    31a2:	50 e0       	ldi	r21, 0x00	; 0
    31a4:	be 01       	movw	r22, r28
    31a6:	6f 5f       	subi	r22, 0xFF	; 255
    31a8:	7f 4f       	sbci	r23, 0xFF	; 255
    31aa:	80 91 ef 0f 	lds	r24, 0x0FEF	; 0x800fef <mqPassword>
    31ae:	90 91 f0 0f 	lds	r25, 0x0FF0	; 0x800ff0 <mqPassword+0x1>
    31b2:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xQueueGenericSend>
					password[0]=0;
    31b6:	19 82       	std	Y+1, r1	; 0x01
					password[1]=0;
    31b8:	1a 82       	std	Y+2, r1	; 0x02
					password[2]=0;
    31ba:	1b 82       	std	Y+3, r1	; 0x03
					password[3]=0;
    31bc:	1c 82       	std	Y+4, r1	; 0x04
					xSemaphoreGive(bsPassCheck);
    31be:	20 e0       	ldi	r18, 0x00	; 0
    31c0:	30 e0       	ldi	r19, 0x00	; 0
    31c2:	a9 01       	movw	r20, r18
    31c4:	60 e0       	ldi	r22, 0x00	; 0
    31c6:	70 e0       	ldi	r23, 0x00	; 0
    31c8:	80 91 f1 0f 	lds	r24, 0x0FF1	; 0x800ff1 <bsPassCheck>
    31cc:	90 91 f2 0f 	lds	r25, 0x0FF2	; 0x800ff2 <bsPassCheck+0x1>
    31d0:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xQueueGenericSend>
				else if(keyPressed=='#')
				{
					SensorReading.LCDState=MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(200);
    31d4:	68 ec       	ldi	r22, 0xC8	; 200
    31d6:	70 e0       	ldi	r23, 0x00	; 0
    31d8:	80 e0       	ldi	r24, 0x00	; 0
    31da:	90 e0       	ldi	r25, 0x00	; 0
    31dc:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    31e0:	9a cf       	rjmp	.-204    	; 0x3116 <T_PasswordGet+0xc2>
					password[counter]=keyPressed;
					disp_charXY(2,counter+1,keyPressed);
					keyPressed=0;
					counter++;
				}//end if
				else if(keyPressed=='*' || (counter==(strlen(oldpassword))))
    31e2:	f6 01       	movw	r30, r12
    31e4:	01 90       	ld	r0, Z+
    31e6:	00 20       	and	r0, r0
    31e8:	e9 f7       	brne	.-6      	; 0x31e4 <T_PasswordGet+0x190>
    31ea:	31 97       	sbiw	r30, 0x01	; 1
    31ec:	e7 51       	subi	r30, 0x17	; 23
    31ee:	f1 40       	sbci	r31, 0x01	; 1
    31f0:	21 2f       	mov	r18, r17
    31f2:	30 e0       	ldi	r19, 0x00	; 0
    31f4:	2e 17       	cp	r18, r30
    31f6:	3f 07       	cpc	r19, r31
    31f8:	09 f0       	breq	.+2      	; 0x31fc <T_PasswordGet+0x1a8>
    31fa:	73 cf       	rjmp	.-282    	; 0x30e2 <T_PasswordGet+0x8e>
    31fc:	ce cf       	rjmp	.-100    	; 0x319a <T_PasswordGet+0x146>
				{
					counter=0;
					xQueueSend(mqPassword,password,300);
    31fe:	00 e0       	ldi	r16, 0x00	; 0
    3200:	2c e2       	ldi	r18, 0x2C	; 44
    3202:	31 e0       	ldi	r19, 0x01	; 1
    3204:	40 e0       	ldi	r20, 0x00	; 0
    3206:	50 e0       	ldi	r21, 0x00	; 0
    3208:	be 01       	movw	r22, r28
    320a:	6f 5f       	subi	r22, 0xFF	; 255
    320c:	7f 4f       	sbci	r23, 0xFF	; 255
    320e:	80 91 ef 0f 	lds	r24, 0x0FEF	; 0x800fef <mqPassword>
    3212:	90 91 f0 0f 	lds	r25, 0x0FF0	; 0x800ff0 <mqPassword+0x1>
    3216:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xQueueGenericSend>
					password[0]=0;
    321a:	19 82       	std	Y+1, r1	; 0x01
					password[1]=0;
    321c:	1a 82       	std	Y+2, r1	; 0x02
					password[2]=0;
    321e:	1b 82       	std	Y+3, r1	; 0x03
					password[3]=0;
    3220:	1c 82       	std	Y+4, r1	; 0x04
					xSemaphoreGive(bsPassCheck);
    3222:	20 e0       	ldi	r18, 0x00	; 0
    3224:	30 e0       	ldi	r19, 0x00	; 0
    3226:	a9 01       	movw	r20, r18
    3228:	60 e0       	ldi	r22, 0x00	; 0
    322a:	70 e0       	ldi	r23, 0x00	; 0
    322c:	80 91 f1 0f 	lds	r24, 0x0FF1	; 0x800ff1 <bsPassCheck>
    3230:	90 91 f2 0f 	lds	r25, 0x0FF2	; 0x800ff2 <bsPassCheck+0x1>
    3234:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xQueueGenericSend>
				else if(keyPressed=='#')
				{
					SensorReading.LCDState=MAIN_STATE;
					xEventGroupSetBits(egEvents,E_MainDisp);
				}
				vTaskDelay(200);
    3238:	68 ec       	ldi	r22, 0xC8	; 200
    323a:	70 e0       	ldi	r23, 0x00	; 0
    323c:	80 e0       	ldi	r24, 0x00	; 0
    323e:	90 e0       	ldi	r25, 0x00	; 0
    3240:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
    3244:	68 cf       	rjmp	.-304    	; 0x3116 <T_PasswordGet+0xc2>

00003246 <T_UserInput>:
void T_UserInput(void *pvinitData)
{
	u8 keyPressed=0;
	while (1)
	{
		if (SensorReading.LCDState==MAIN_STATE)
    3246:	cc e1       	ldi	r28, 0x1C	; 28
    3248:	d1 e0       	ldi	r29, 0x01	; 1
			vTaskDelay(100);
			keyPressed=GetKey();
			switch(keyPressed)
			{
				case'1':
				SensorReading.LCDState=TEMP_CONFIG_STATE;
    324a:	0f 2e       	mov	r0, r31
    324c:	f5 e0       	ldi	r31, 0x05	; 5
    324e:	bf 2e       	mov	r11, r31
    3250:	f0 2d       	mov	r31, r0
				xEventGroupSetBits(egEvents,E_TempConfigDisp);
				xEventGroupSetBits(egEvents1,E_GetTemp);
				vTaskDelay(200);
				break;
				case'2':
				SensorReading.LCDState=LIGHT_CUTOFF_STATE;
    3252:	0f 2e       	mov	r0, r31
    3254:	f6 e0       	ldi	r31, 0x06	; 6
    3256:	cf 2e       	mov	r12, r31
    3258:	f0 2d       	mov	r31, r0
				xEventGroupSetBits(egEvents1,E_lightConigDisp);
				xEventGroupSetBits(egEvents1,E_GetLight);
				break;
				case'3':
				SensorReading.LCDState = MOIST_CONFIG_STATE;
    325a:	0f 2e       	mov	r0, r31
    325c:	f7 e0       	ldi	r31, 0x07	; 7
    325e:	df 2e       	mov	r13, r31
    3260:	f0 2d       	mov	r31, r0
			vTaskDelay(100);
			keyPressed=GetKey();
			switch(keyPressed)
			{
				case'1':
				SensorReading.LCDState=GET_PASS_STATE;
    3262:	68 94       	set
    3264:	ee 24       	eor	r14, r14
    3266:	e1 f8       	bld	r14, 1
				vTaskDelay(200);
				//xEventGroupSetBits(egEvents,E_UIDOOR);
				xSemaphoreGive(bsPassEntered);
				break;
				case'2':
				SensorReading.LCDState=CONFIG_STATE;
    3268:	ff 24       	eor	r15, r15
    326a:	f3 94       	inc	r15
		{
			keyPressed=GetKey();
			if (keyPressed!=0)
			{
				keyPressed=0;
				SensorReading.LCDState=UI_STATE;
    326c:	14 e0       	ldi	r17, 0x04	; 4
void T_UserInput(void *pvinitData)
{
	u8 keyPressed=0;
	while (1)
	{
		if (SensorReading.LCDState==MAIN_STATE)
    326e:	89 a9       	ldd	r24, Y+49	; 0x31
    3270:	81 11       	cpse	r24, r1
    3272:	11 c0       	rjmp	.+34     	; 0x3296 <T_UserInput+0x50>
		{
			keyPressed=GetKey();
    3274:	0e 94 ab 01 	call	0x356	; 0x356 <GetKey>
			if (keyPressed!=0)
    3278:	88 23       	and	r24, r24
    327a:	09 f4       	brne	.+2      	; 0x327e <T_UserInput+0x38>
    327c:	bf c0       	rjmp	.+382    	; 0x33fc <T_UserInput+0x1b6>
			{
				keyPressed=0;
				SensorReading.LCDState=UI_STATE;
    327e:	19 ab       	std	Y+49, r17	; 0x31
				xEventGroupSetBits(egEvents,E_UIDisp);
    3280:	40 e0       	ldi	r20, 0x00	; 0
    3282:	50 e2       	ldi	r21, 0x20	; 32
    3284:	60 e0       	ldi	r22, 0x00	; 0
    3286:	70 e0       	ldi	r23, 0x00	; 0
    3288:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    328c:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    3290:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
    3294:	b3 c0       	rjmp	.+358    	; 0x33fc <T_UserInput+0x1b6>
			}
		}
		else if (SensorReading.LCDState==UI_STATE)
    3296:	84 30       	cpi	r24, 0x04	; 4
    3298:	09 f0       	breq	.+2      	; 0x329c <T_UserInput+0x56>
    329a:	46 c0       	rjmp	.+140    	; 0x3328 <T_UserInput+0xe2>
		{
			vTaskDelay(100);
    329c:	64 e6       	ldi	r22, 0x64	; 100
    329e:	70 e0       	ldi	r23, 0x00	; 0
    32a0:	80 e0       	ldi	r24, 0x00	; 0
    32a2:	90 e0       	ldi	r25, 0x00	; 0
    32a4:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
			keyPressed=GetKey();
    32a8:	0e 94 ab 01 	call	0x356	; 0x356 <GetKey>
			switch(keyPressed)
    32ac:	81 33       	cpi	r24, 0x31	; 49
    32ae:	31 f0       	breq	.+12     	; 0x32bc <T_UserInput+0x76>
    32b0:	82 33       	cpi	r24, 0x32	; 50
    32b2:	11 f1       	breq	.+68     	; 0x32f8 <T_UserInput+0xb2>
    32b4:	83 32       	cpi	r24, 0x23	; 35
    32b6:	09 f0       	breq	.+2      	; 0x32ba <T_UserInput+0x74>
    32b8:	a1 c0       	rjmp	.+322    	; 0x33fc <T_UserInput+0x1b6>
    32ba:	2a c0       	rjmp	.+84     	; 0x3310 <T_UserInput+0xca>
			{
				case'1':
				SensorReading.LCDState=GET_PASS_STATE;
    32bc:	e9 aa       	std	Y+49, r14	; 0x31
				xEventGroupSetBits(egEvents,E_GetPassDisp);
    32be:	40 e8       	ldi	r20, 0x80	; 128
    32c0:	50 e0       	ldi	r21, 0x00	; 0
    32c2:	60 e0       	ldi	r22, 0x00	; 0
    32c4:	70 e0       	ldi	r23, 0x00	; 0
    32c6:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    32ca:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    32ce:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				vTaskDelay(200);
    32d2:	68 ec       	ldi	r22, 0xC8	; 200
    32d4:	70 e0       	ldi	r23, 0x00	; 0
    32d6:	80 e0       	ldi	r24, 0x00	; 0
    32d8:	90 e0       	ldi	r25, 0x00	; 0
    32da:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
				//xEventGroupSetBits(egEvents,E_UIDOOR);
				xSemaphoreGive(bsPassEntered);
    32de:	00 e0       	ldi	r16, 0x00	; 0
    32e0:	20 e0       	ldi	r18, 0x00	; 0
    32e2:	30 e0       	ldi	r19, 0x00	; 0
    32e4:	a9 01       	movw	r20, r18
    32e6:	60 e0       	ldi	r22, 0x00	; 0
    32e8:	70 e0       	ldi	r23, 0x00	; 0
    32ea:	80 91 f3 0f 	lds	r24, 0x0FF3	; 0x800ff3 <bsPassEntered>
    32ee:	90 91 f4 0f 	lds	r25, 0x0FF4	; 0x800ff4 <bsPassEntered+0x1>
    32f2:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <xQueueGenericSend>
				break;
    32f6:	82 c0       	rjmp	.+260    	; 0x33fc <T_UserInput+0x1b6>
				case'2':
				SensorReading.LCDState=CONFIG_STATE;
    32f8:	f9 aa       	std	Y+49, r15	; 0x31
				xEventGroupSetBits(egEvents,E_SITDisp);
    32fa:	40 e0       	ldi	r20, 0x00	; 0
    32fc:	50 e4       	ldi	r21, 0x40	; 64
    32fe:	60 e0       	ldi	r22, 0x00	; 0
    3300:	70 e0       	ldi	r23, 0x00	; 0
    3302:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    3306:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    330a:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				break;
    330e:	76 c0       	rjmp	.+236    	; 0x33fc <T_UserInput+0x1b6>
				case'#':
				SensorReading.LCDState=MAIN_STATE;
    3310:	19 aa       	std	Y+49, r1	; 0x31
				xEventGroupSetBits(egEvents,E_MainDisp);
    3312:	40 e0       	ldi	r20, 0x00	; 0
    3314:	52 e0       	ldi	r21, 0x02	; 2
    3316:	60 e0       	ldi	r22, 0x00	; 0
    3318:	70 e0       	ldi	r23, 0x00	; 0
    331a:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    331e:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    3322:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				break;
    3326:	6a c0       	rjmp	.+212    	; 0x33fc <T_UserInput+0x1b6>
				
			}
			
		}
		else if (SensorReading.LCDState==CONFIG_STATE)
    3328:	81 30       	cpi	r24, 0x01	; 1
    332a:	09 f0       	breq	.+2      	; 0x332e <T_UserInput+0xe8>
    332c:	67 c0       	rjmp	.+206    	; 0x33fc <T_UserInput+0x1b6>
		{
			vTaskDelay(100);
    332e:	64 e6       	ldi	r22, 0x64	; 100
    3330:	70 e0       	ldi	r23, 0x00	; 0
    3332:	80 e0       	ldi	r24, 0x00	; 0
    3334:	90 e0       	ldi	r25, 0x00	; 0
    3336:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
			keyPressed=GetKey();
    333a:	0e 94 ab 01 	call	0x356	; 0x356 <GetKey>
			switch(keyPressed)
    333e:	81 33       	cpi	r24, 0x31	; 49
    3340:	51 f0       	breq	.+20     	; 0x3356 <T_UserInput+0x110>
    3342:	20 f4       	brcc	.+8      	; 0x334c <T_UserInput+0x106>
    3344:	83 32       	cpi	r24, 0x23	; 35
    3346:	09 f4       	brne	.+2      	; 0x334a <T_UserInput+0x104>
    3348:	4e c0       	rjmp	.+156    	; 0x33e6 <T_UserInput+0x1a0>
    334a:	58 c0       	rjmp	.+176    	; 0x33fc <T_UserInput+0x1b6>
    334c:	82 33       	cpi	r24, 0x32	; 50
    334e:	f9 f0       	breq	.+62     	; 0x338e <T_UserInput+0x148>
    3350:	83 33       	cpi	r24, 0x33	; 51
    3352:	99 f1       	breq	.+102    	; 0x33ba <T_UserInput+0x174>
    3354:	53 c0       	rjmp	.+166    	; 0x33fc <T_UserInput+0x1b6>
			{
				case'1':
				SensorReading.LCDState=TEMP_CONFIG_STATE;
    3356:	b9 aa       	std	Y+49, r11	; 0x31
				xEventGroupSetBits(egEvents,E_TempConfigDisp);
    3358:	40 e0       	ldi	r20, 0x00	; 0
    335a:	51 e0       	ldi	r21, 0x01	; 1
    335c:	60 e0       	ldi	r22, 0x00	; 0
    335e:	70 e0       	ldi	r23, 0x00	; 0
    3360:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    3364:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    3368:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				xEventGroupSetBits(egEvents1,E_GetTemp);
    336c:	40 e1       	ldi	r20, 0x10	; 16
    336e:	50 e0       	ldi	r21, 0x00	; 0
    3370:	60 e0       	ldi	r22, 0x00	; 0
    3372:	70 e0       	ldi	r23, 0x00	; 0
    3374:	80 91 f5 0f 	lds	r24, 0x0FF5	; 0x800ff5 <egEvents1>
    3378:	90 91 f6 0f 	lds	r25, 0x0FF6	; 0x800ff6 <egEvents1+0x1>
    337c:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				vTaskDelay(200);
    3380:	68 ec       	ldi	r22, 0xC8	; 200
    3382:	70 e0       	ldi	r23, 0x00	; 0
    3384:	80 e0       	ldi	r24, 0x00	; 0
    3386:	90 e0       	ldi	r25, 0x00	; 0
    3388:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
				break;
    338c:	37 c0       	rjmp	.+110    	; 0x33fc <T_UserInput+0x1b6>
				case'2':
				SensorReading.LCDState=LIGHT_CUTOFF_STATE;
    338e:	c9 aa       	std	Y+49, r12	; 0x31
				xEventGroupSetBits(egEvents1,E_lightConigDisp);
    3390:	42 e0       	ldi	r20, 0x02	; 2
    3392:	50 e0       	ldi	r21, 0x00	; 0
    3394:	60 e0       	ldi	r22, 0x00	; 0
    3396:	70 e0       	ldi	r23, 0x00	; 0
    3398:	80 91 f5 0f 	lds	r24, 0x0FF5	; 0x800ff5 <egEvents1>
    339c:	90 91 f6 0f 	lds	r25, 0x0FF6	; 0x800ff6 <egEvents1+0x1>
    33a0:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				xEventGroupSetBits(egEvents1,E_GetLight);
    33a4:	48 e0       	ldi	r20, 0x08	; 8
    33a6:	50 e0       	ldi	r21, 0x00	; 0
    33a8:	60 e0       	ldi	r22, 0x00	; 0
    33aa:	70 e0       	ldi	r23, 0x00	; 0
    33ac:	80 91 f5 0f 	lds	r24, 0x0FF5	; 0x800ff5 <egEvents1>
    33b0:	90 91 f6 0f 	lds	r25, 0x0FF6	; 0x800ff6 <egEvents1+0x1>
    33b4:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				break;
    33b8:	21 c0       	rjmp	.+66     	; 0x33fc <T_UserInput+0x1b6>
				case'3':
				SensorReading.LCDState = MOIST_CONFIG_STATE;
    33ba:	d9 aa       	std	Y+49, r13	; 0x31
				xEventGroupSetBits(egEvents1,E_MoistConigDisp);
    33bc:	41 e0       	ldi	r20, 0x01	; 1
    33be:	50 e0       	ldi	r21, 0x00	; 0
    33c0:	60 e0       	ldi	r22, 0x00	; 0
    33c2:	70 e0       	ldi	r23, 0x00	; 0
    33c4:	80 91 f5 0f 	lds	r24, 0x0FF5	; 0x800ff5 <egEvents1>
    33c8:	90 91 f6 0f 	lds	r25, 0x0FF6	; 0x800ff6 <egEvents1+0x1>
    33cc:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				xEventGroupSetBits(egEvents1,E_GetMoist);
    33d0:	44 e0       	ldi	r20, 0x04	; 4
    33d2:	50 e0       	ldi	r21, 0x00	; 0
    33d4:	60 e0       	ldi	r22, 0x00	; 0
    33d6:	70 e0       	ldi	r23, 0x00	; 0
    33d8:	80 91 f5 0f 	lds	r24, 0x0FF5	; 0x800ff5 <egEvents1>
    33dc:	90 91 f6 0f 	lds	r25, 0x0FF6	; 0x800ff6 <egEvents1+0x1>
    33e0:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				break;
    33e4:	0b c0       	rjmp	.+22     	; 0x33fc <T_UserInput+0x1b6>
				case'#':
				SensorReading.LCDState=MAIN_STATE;
    33e6:	19 aa       	std	Y+49, r1	; 0x31
				xEventGroupSetBits(egEvents,E_MainDisp);
    33e8:	40 e0       	ldi	r20, 0x00	; 0
    33ea:	52 e0       	ldi	r21, 0x02	; 2
    33ec:	60 e0       	ldi	r22, 0x00	; 0
    33ee:	70 e0       	ldi	r23, 0x00	; 0
    33f0:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    33f4:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    33f8:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
				break;
				
			}
			
		}
		vTaskDelay(50);
    33fc:	62 e3       	ldi	r22, 0x32	; 50
    33fe:	70 e0       	ldi	r23, 0x00	; 0
    3400:	80 e0       	ldi	r24, 0x00	; 0
    3402:	90 e0       	ldi	r25, 0x00	; 0
    3404:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <vTaskDelay>
	}
    3408:	32 cf       	rjmp	.-412    	; 0x326e <T_UserInput+0x28>

0000340a <Project_Init>:
	}
}
/***********************************************************************************************************/

void Project_Init(void)
{
    340a:	af 92       	push	r10
    340c:	bf 92       	push	r11
    340e:	cf 92       	push	r12
    3410:	df 92       	push	r13
    3412:	ef 92       	push	r14
    3414:	ff 92       	push	r15
    3416:	0f 93       	push	r16
	KEYPAD_Init();
    3418:	0e 94 96 01 	call	0x32c	; 0x32c <KEYPAD_Init>
	LCD_init();
    341c:	0e 94 25 02 	call	0x44a	; 0x44a <LCD_init>
	ADC_init();
    3420:	0e 94 ca 02 	call	0x594	; 0x594 <ADC_init>
	Uart_Init(UART_0, 9600);
    3424:	40 e8       	ldi	r20, 0x80	; 128
    3426:	55 e2       	ldi	r21, 0x25	; 37
    3428:	60 e0       	ldi	r22, 0x00	; 0
    342a:	70 e0       	ldi	r23, 0x00	; 0
    342c:	80 e0       	ldi	r24, 0x00	; 0
    342e:	0e 94 4f 04 	call	0x89e	; 0x89e <Uart_Init>
	
	pinDirection(DOOR_LED,OUTPUT);
    3432:	61 e0       	ldi	r22, 0x01	; 1
    3434:	84 e1       	ldi	r24, 0x14	; 20
    3436:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	
	pinDirection(TV_PIN,OUTPUT);
    343a:	61 e0       	ldi	r22, 0x01	; 1
    343c:	8f e1       	ldi	r24, 0x1F	; 31
    343e:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	pinDirection(INNERLIGHT,OUTPUT);
    3442:	61 e0       	ldi	r22, 0x01	; 1
    3444:	8e e1       	ldi	r24, 0x1E	; 30
    3446:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	
	
	egEvents = xEventGroupCreate();					//Event Group Create
    344a:	0e 94 ac 04 	call	0x958	; 0x958 <xEventGroupCreate>
    344e:	90 93 f8 0f 	sts	0x0FF8, r25	; 0x800ff8 <egEvents+0x1>
    3452:	80 93 f7 0f 	sts	0x0FF7, r24	; 0x800ff7 <egEvents>
	egEvents1 = xEventGroupCreate();
    3456:	0e 94 ac 04 	call	0x958	; 0x958 <xEventGroupCreate>
    345a:	90 93 f6 0f 	sts	0x0FF6, r25	; 0x800ff6 <egEvents1+0x1>
    345e:	80 93 f5 0f 	sts	0x0FF5, r24	; 0x800ff5 <egEvents1>
	xEventGroupSetBits(egEvents,E_MainDisp);
    3462:	40 e0       	ldi	r20, 0x00	; 0
    3464:	52 e0       	ldi	r21, 0x02	; 2
    3466:	60 e0       	ldi	r22, 0x00	; 0
    3468:	70 e0       	ldi	r23, 0x00	; 0
    346a:	80 91 f7 0f 	lds	r24, 0x0FF7	; 0x800ff7 <egEvents>
    346e:	90 91 f8 0f 	lds	r25, 0x0FF8	; 0x800ff8 <egEvents+0x1>
    3472:	0e 94 7d 05 	call	0xafa	; 0xafa <xEventGroupSetBits>
	
	
	/* LCD Display config*/
	xTaskCreate(T_DisplayData,NULL,200,NULL,1,NULL);
    3476:	a1 2c       	mov	r10, r1
    3478:	b1 2c       	mov	r11, r1
    347a:	c1 2c       	mov	r12, r1
    347c:	d1 2c       	mov	r13, r1
    347e:	e1 2c       	mov	r14, r1
    3480:	f1 2c       	mov	r15, r1
    3482:	01 e0       	ldi	r16, 0x01	; 1
    3484:	20 e0       	ldi	r18, 0x00	; 0
    3486:	30 e0       	ldi	r19, 0x00	; 0
    3488:	48 ec       	ldi	r20, 0xC8	; 200
    348a:	50 e0       	ldi	r21, 0x00	; 0
    348c:	60 e0       	ldi	r22, 0x00	; 0
    348e:	70 e0       	ldi	r23, 0x00	; 0
    3490:	87 e5       	ldi	r24, 0x57	; 87
    3492:	91 e1       	ldi	r25, 0x11	; 17
    3494:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	
	
	/*fire system config*/
	xTaskCreate(T_FireDetect,NULL,100,NULL,9,NULL);
    3498:	09 e0       	ldi	r16, 0x09	; 9
    349a:	20 e0       	ldi	r18, 0x00	; 0
    349c:	30 e0       	ldi	r19, 0x00	; 0
    349e:	44 e6       	ldi	r20, 0x64	; 100
    34a0:	50 e0       	ldi	r21, 0x00	; 0
    34a2:	60 e0       	ldi	r22, 0x00	; 0
    34a4:	70 e0       	ldi	r23, 0x00	; 0
    34a6:	87 e4       	ldi	r24, 0x47	; 71
    34a8:	93 e1       	ldi	r25, 0x13	; 19
    34aa:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	xTaskCreate(T_FireAlarmAction,NULL,85,NULL,10,NULL);
    34ae:	0a e0       	ldi	r16, 0x0A	; 10
    34b0:	20 e0       	ldi	r18, 0x00	; 0
    34b2:	30 e0       	ldi	r19, 0x00	; 0
    34b4:	45 e5       	ldi	r20, 0x55	; 85
    34b6:	50 e0       	ldi	r21, 0x00	; 0
    34b8:	60 e0       	ldi	r22, 0x00	; 0
    34ba:	70 e0       	ldi	r23, 0x00	; 0
    34bc:	8c e5       	ldi	r24, 0x5C	; 92
    34be:	93 e1       	ldi	r25, 0x13	; 19
    34c0:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	pinDirection(FLAME_SENSOR,INPUT);//Flame sensor as input
    34c4:	60 e0       	ldi	r22, 0x00	; 0
    34c6:	8a e1       	ldi	r24, 0x1A	; 26
    34c8:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	pinDirection(FIREPUMP,OUTPUT);
    34cc:	61 e0       	ldi	r22, 0x01	; 1
    34ce:	8b e1       	ldi	r24, 0x1B	; 27
    34d0:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	pinDirection(BUZZER,OUTPUT);
    34d4:	61 e0       	ldi	r22, 0x01	; 1
    34d6:	8f e0       	ldi	r24, 0x0F	; 15
    34d8:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	
	/*irrigation system config*/
	xTaskCreate(T_SOIL_Input,NULL,100,NULL,2,NULL);
    34dc:	02 e0       	ldi	r16, 0x02	; 2
    34de:	20 e0       	ldi	r18, 0x00	; 0
    34e0:	30 e0       	ldi	r19, 0x00	; 0
    34e2:	44 e6       	ldi	r20, 0x64	; 100
    34e4:	50 e0       	ldi	r21, 0x00	; 0
    34e6:	60 e0       	ldi	r22, 0x00	; 0
    34e8:	70 e0       	ldi	r23, 0x00	; 0
    34ea:	8b ee       	ldi	r24, 0xEB	; 235
    34ec:	95 e1       	ldi	r25, 0x15	; 21
    34ee:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	xTaskCreate(T_SOIL_Action,NULL,85,NULL,3,NULL);
    34f2:	03 e0       	ldi	r16, 0x03	; 3
    34f4:	20 e0       	ldi	r18, 0x00	; 0
    34f6:	30 e0       	ldi	r19, 0x00	; 0
    34f8:	45 e5       	ldi	r20, 0x55	; 85
    34fa:	50 e0       	ldi	r21, 0x00	; 0
    34fc:	60 e0       	ldi	r22, 0x00	; 0
    34fe:	70 e0       	ldi	r23, 0x00	; 0
    3500:	80 e5       	ldi	r24, 0x50	; 80
    3502:	94 e1       	ldi	r25, 0x14	; 20
    3504:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	pinDirection(SOIL_PUMP,OUTPUT);
    3508:	61 e0       	ldi	r22, 0x01	; 1
    350a:	8c e1       	ldi	r24, 0x1C	; 28
    350c:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	
	/*Outer light system config*/
	xTaskCreate(T_LIGHT_Input,NULL,100,NULL,2,NULL);
    3510:	02 e0       	ldi	r16, 0x02	; 2
    3512:	20 e0       	ldi	r18, 0x00	; 0
    3514:	30 e0       	ldi	r19, 0x00	; 0
    3516:	44 e6       	ldi	r20, 0x64	; 100
    3518:	50 e0       	ldi	r21, 0x00	; 0
    351a:	60 e0       	ldi	r22, 0x00	; 0
    351c:	70 e0       	ldi	r23, 0x00	; 0
    351e:	82 eb       	ldi	r24, 0xB2	; 178
    3520:	95 e1       	ldi	r25, 0x15	; 21
    3522:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	xTaskCreate(T_LIGHT_Action,NULL,85,NULL,3,NULL);
    3526:	03 e0       	ldi	r16, 0x03	; 3
    3528:	20 e0       	ldi	r18, 0x00	; 0
    352a:	30 e0       	ldi	r19, 0x00	; 0
    352c:	45 e5       	ldi	r20, 0x55	; 85
    352e:	50 e0       	ldi	r21, 0x00	; 0
    3530:	60 e0       	ldi	r22, 0x00	; 0
    3532:	70 e0       	ldi	r23, 0x00	; 0
    3534:	89 ee       	ldi	r24, 0xE9	; 233
    3536:	93 e1       	ldi	r25, 0x13	; 19
    3538:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	pinDirection(OUTERLIGHT,OUTPUT);
    353c:	61 e0       	ldi	r22, 0x01	; 1
    353e:	8d e1       	ldi	r24, 0x1D	; 29
    3540:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	
	/*Temperature system config*/
	xTaskCreate(T_TempRead,NULL,200,NULL,7,NULL);
    3544:	07 e0       	ldi	r16, 0x07	; 7
    3546:	20 e0       	ldi	r18, 0x00	; 0
    3548:	30 e0       	ldi	r19, 0x00	; 0
    354a:	48 ec       	ldi	r20, 0xC8	; 200
    354c:	50 e0       	ldi	r21, 0x00	; 0
    354e:	60 e0       	ldi	r22, 0x00	; 0
    3550:	70 e0       	ldi	r23, 0x00	; 0
    3552:	8b e5       	ldi	r24, 0x5B	; 91
    3554:	95 e1       	ldi	r25, 0x15	; 21
    3556:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	xTaskCreate(T_TempAction,NULL,85,NULL,8,NULL);
    355a:	08 e0       	ldi	r16, 0x08	; 8
    355c:	20 e0       	ldi	r18, 0x00	; 0
    355e:	30 e0       	ldi	r19, 0x00	; 0
    3560:	45 e5       	ldi	r20, 0x55	; 85
    3562:	50 e0       	ldi	r21, 0x00	; 0
    3564:	60 e0       	ldi	r22, 0x00	; 0
    3566:	70 e0       	ldi	r23, 0x00	; 0
    3568:	80 ef       	ldi	r24, 0xF0	; 240
    356a:	94 e1       	ldi	r25, 0x14	; 20
    356c:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	pinDirection(FAN,OUTPUT);
    3570:	61 e0       	ldi	r22, 0x01	; 1
    3572:	83 e1       	ldi	r24, 0x13	; 19
    3574:	0e 94 68 03 	call	0x6d0	; 0x6d0 <pinDirection>
	/////////////////////////////////////
	xTaskCreate(T_UserInput,NULL,250,NULL,4,NULL);
    3578:	04 e0       	ldi	r16, 0x04	; 4
    357a:	20 e0       	ldi	r18, 0x00	; 0
    357c:	30 e0       	ldi	r19, 0x00	; 0
    357e:	4a ef       	ldi	r20, 0xFA	; 250
    3580:	50 e0       	ldi	r21, 0x00	; 0
    3582:	60 e0       	ldi	r22, 0x00	; 0
    3584:	70 e0       	ldi	r23, 0x00	; 0
    3586:	83 e2       	ldi	r24, 0x23	; 35
    3588:	99 e1       	ldi	r25, 0x19	; 25
    358a:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	
	
	/*Door Security system config*/
	xTaskCreate(T_PasswordGet,NULL,100,NULL,5,NULL);
    358e:	05 e0       	ldi	r16, 0x05	; 5
    3590:	20 e0       	ldi	r18, 0x00	; 0
    3592:	30 e0       	ldi	r19, 0x00	; 0
    3594:	44 e6       	ldi	r20, 0x64	; 100
    3596:	50 e0       	ldi	r21, 0x00	; 0
    3598:	60 e0       	ldi	r22, 0x00	; 0
    359a:	70 e0       	ldi	r23, 0x00	; 0
    359c:	8a e2       	ldi	r24, 0x2A	; 42
    359e:	98 e1       	ldi	r25, 0x18	; 24
    35a0:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	xTaskCreate(T_PasswordCheck,NULL,100,NULL,6,NULL);
    35a4:	06 e0       	ldi	r16, 0x06	; 6
    35a6:	20 e0       	ldi	r18, 0x00	; 0
    35a8:	30 e0       	ldi	r19, 0x00	; 0
    35aa:	44 e6       	ldi	r20, 0x64	; 100
    35ac:	50 e0       	ldi	r21, 0x00	; 0
    35ae:	60 e0       	ldi	r22, 0x00	; 0
    35b0:	70 e0       	ldi	r23, 0x00	; 0
    35b2:	8a e2       	ldi	r24, 0x2A	; 42
    35b4:	96 e1       	ldi	r25, 0x16	; 22
    35b6:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	bsPassCheck	=	xSemaphoreCreateBinary();
    35ba:	43 e0       	ldi	r20, 0x03	; 3
    35bc:	60 e0       	ldi	r22, 0x00	; 0
    35be:	81 e0       	ldi	r24, 0x01	; 1
    35c0:	0e 94 30 09 	call	0x1260	; 0x1260 <xQueueGenericCreate>
    35c4:	90 93 f2 0f 	sts	0x0FF2, r25	; 0x800ff2 <bsPassCheck+0x1>
    35c8:	80 93 f1 0f 	sts	0x0FF1, r24	; 0x800ff1 <bsPassCheck>
	bsPassEntered	=	xSemaphoreCreateBinary();
    35cc:	43 e0       	ldi	r20, 0x03	; 3
    35ce:	60 e0       	ldi	r22, 0x00	; 0
    35d0:	81 e0       	ldi	r24, 0x01	; 1
    35d2:	0e 94 30 09 	call	0x1260	; 0x1260 <xQueueGenericCreate>
    35d6:	90 93 f4 0f 	sts	0x0FF4, r25	; 0x800ff4 <bsPassEntered+0x1>
    35da:	80 93 f3 0f 	sts	0x0FF3, r24	; 0x800ff3 <bsPassEntered>
	mqPassword		=	xQueueCreate(PASS_NUM,PASS_LENGTH);
    35de:	40 e0       	ldi	r20, 0x00	; 0
    35e0:	65 e0       	ldi	r22, 0x05	; 5
    35e2:	81 e0       	ldi	r24, 0x01	; 1
    35e4:	0e 94 30 09 	call	0x1260	; 0x1260 <xQueueGenericCreate>
    35e8:	90 93 f0 0f 	sts	0x0FF0, r25	; 0x800ff0 <mqPassword+0x1>
    35ec:	80 93 ef 0f 	sts	0x0FEF, r24	; 0x800fef <mqPassword>
	
	/*TV,INNER LIGHTS USER CONTROL*/
	xTaskCreate(IOTcharinput,NULL,120,NULL,2,NULL);
    35f0:	02 e0       	ldi	r16, 0x02	; 2
    35f2:	20 e0       	ldi	r18, 0x00	; 0
    35f4:	30 e0       	ldi	r19, 0x00	; 0
    35f6:	48 e7       	ldi	r20, 0x78	; 120
    35f8:	50 e0       	ldi	r21, 0x00	; 0
    35fa:	60 e0       	ldi	r22, 0x00	; 0
    35fc:	70 e0       	ldi	r23, 0x00	; 0
    35fe:	87 eb       	ldi	r24, 0xB7	; 183
    3600:	94 e1       	ldi	r25, 0x14	; 20
    3602:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>
	
	/*System Modifications Tasks*/
	xTaskCreate(T_SystemModify,NULL,200,NULL,5,NULL);
    3606:	05 e0       	ldi	r16, 0x05	; 5
    3608:	20 e0       	ldi	r18, 0x00	; 0
    360a:	30 e0       	ldi	r19, 0x00	; 0
    360c:	48 ec       	ldi	r20, 0xC8	; 200
    360e:	50 e0       	ldi	r21, 0x00	; 0
    3610:	60 e0       	ldi	r22, 0x00	; 0
    3612:	70 e0       	ldi	r23, 0x00	; 0
    3614:	89 e9       	ldi	r24, 0x99	; 153
    3616:	96 e1       	ldi	r25, 0x16	; 22
    3618:	0e 94 28 0b 	call	0x1650	; 0x1650 <xTaskGenericCreate>

	
	MQTT_Connect((u8*)"1111");
    361c:	8a e3       	ldi	r24, 0x3A	; 58
    361e:	93 e0       	ldi	r25, 0x03	; 3
    3620:	0e 94 ab 10 	call	0x2156	; 0x2156 <MQTT_Connect>
	disp_strXY(1,1,(u8*)"** WELCOME TO **");
    3624:	4f e3       	ldi	r20, 0x3F	; 63
    3626:	53 e0       	ldi	r21, 0x03	; 3
    3628:	61 e0       	ldi	r22, 0x01	; 1
    362a:	81 e0       	ldi	r24, 0x01	; 1
    362c:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
	disp_strXY(2,1,(u8*)"**** SMART *****");
    3630:	40 e5       	ldi	r20, 0x50	; 80
    3632:	53 e0       	ldi	r21, 0x03	; 3
    3634:	61 e0       	ldi	r22, 0x01	; 1
    3636:	82 e0       	ldi	r24, 0x02	; 2
    3638:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
	disp_strXY(3,1,(u8*)"**** HOME ******");
    363c:	41 e6       	ldi	r20, 0x61	; 97
    363e:	53 e0       	ldi	r21, 0x03	; 3
    3640:	61 e0       	ldi	r22, 0x01	; 1
    3642:	83 e0       	ldi	r24, 0x03	; 3
    3644:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
	disp_strXY(4,1,(u8*)"****************");
    3648:	49 e4       	ldi	r20, 0x49	; 73
    364a:	52 e0       	ldi	r21, 0x02	; 2
    364c:	61 e0       	ldi	r22, 0x01	; 1
    364e:	84 e0       	ldi	r24, 0x04	; 4
    3650:	0e 94 80 02 	call	0x500	; 0x500 <disp_strXY>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3654:	2f ef       	ldi	r18, 0xFF	; 255
    3656:	8d e3       	ldi	r24, 0x3D	; 61
    3658:	99 e4       	ldi	r25, 0x49	; 73
    365a:	21 50       	subi	r18, 0x01	; 1
    365c:	80 40       	sbci	r24, 0x00	; 0
    365e:	90 40       	sbci	r25, 0x00	; 0
    3660:	e1 f7       	brne	.-8      	; 0x365a <Project_Init+0x250>
    3662:	00 c0       	rjmp	.+0      	; 0x3664 <Project_Init+0x25a>
    3664:	00 00       	nop
	_delay_ms(3000);
	LCD_CLEAR();
    3666:	0e 94 13 02 	call	0x426	; 0x426 <LCD_CLEAR>
	MQTT_Subscribe("G/devices");
    366a:	82 e7       	ldi	r24, 0x72	; 114
    366c:	93 e0       	ldi	r25, 0x03	; 3
    366e:	0e 94 23 11 	call	0x2246	; 0x2246 <MQTT_Subscribe>
	
	
	
	
	vTaskStartScheduler();
    3672:	0e 94 2f 0c 	call	0x185e	; 0x185e <vTaskStartScheduler>
}
    3676:	0f 91       	pop	r16
    3678:	ff 90       	pop	r15
    367a:	ef 90       	pop	r14
    367c:	df 90       	pop	r13
    367e:	cf 90       	pop	r12
    3680:	bf 90       	pop	r11
    3682:	af 90       	pop	r10
    3684:	08 95       	ret

00003686 <__udivmodsi4>:
    3686:	a1 e2       	ldi	r26, 0x21	; 33
    3688:	1a 2e       	mov	r1, r26
    368a:	aa 1b       	sub	r26, r26
    368c:	bb 1b       	sub	r27, r27
    368e:	fd 01       	movw	r30, r26
    3690:	0d c0       	rjmp	.+26     	; 0x36ac <__udivmodsi4_ep>

00003692 <__udivmodsi4_loop>:
    3692:	aa 1f       	adc	r26, r26
    3694:	bb 1f       	adc	r27, r27
    3696:	ee 1f       	adc	r30, r30
    3698:	ff 1f       	adc	r31, r31
    369a:	a2 17       	cp	r26, r18
    369c:	b3 07       	cpc	r27, r19
    369e:	e4 07       	cpc	r30, r20
    36a0:	f5 07       	cpc	r31, r21
    36a2:	20 f0       	brcs	.+8      	; 0x36ac <__udivmodsi4_ep>
    36a4:	a2 1b       	sub	r26, r18
    36a6:	b3 0b       	sbc	r27, r19
    36a8:	e4 0b       	sbc	r30, r20
    36aa:	f5 0b       	sbc	r31, r21

000036ac <__udivmodsi4_ep>:
    36ac:	66 1f       	adc	r22, r22
    36ae:	77 1f       	adc	r23, r23
    36b0:	88 1f       	adc	r24, r24
    36b2:	99 1f       	adc	r25, r25
    36b4:	1a 94       	dec	r1
    36b6:	69 f7       	brne	.-38     	; 0x3692 <__udivmodsi4_loop>
    36b8:	60 95       	com	r22
    36ba:	70 95       	com	r23
    36bc:	80 95       	com	r24
    36be:	90 95       	com	r25
    36c0:	9b 01       	movw	r18, r22
    36c2:	ac 01       	movw	r20, r24
    36c4:	bd 01       	movw	r22, r26
    36c6:	cf 01       	movw	r24, r30
    36c8:	08 95       	ret

000036ca <__tablejump2__>:
    36ca:	ee 0f       	add	r30, r30
    36cc:	ff 1f       	adc	r31, r31
    36ce:	00 24       	eor	r0, r0
    36d0:	00 1c       	adc	r0, r0
    36d2:	0b be       	out	0x3b, r0	; 59
    36d4:	07 90       	elpm	r0, Z+
    36d6:	f6 91       	elpm	r31, Z
    36d8:	e0 2d       	mov	r30, r0
    36da:	09 94       	ijmp

000036dc <__umulhisi3>:
    36dc:	a2 9f       	mul	r26, r18
    36de:	b0 01       	movw	r22, r0
    36e0:	b3 9f       	mul	r27, r19
    36e2:	c0 01       	movw	r24, r0
    36e4:	a3 9f       	mul	r26, r19
    36e6:	70 0d       	add	r23, r0
    36e8:	81 1d       	adc	r24, r1
    36ea:	11 24       	eor	r1, r1
    36ec:	91 1d       	adc	r25, r1
    36ee:	b2 9f       	mul	r27, r18
    36f0:	70 0d       	add	r23, r0
    36f2:	81 1d       	adc	r24, r1
    36f4:	11 24       	eor	r1, r1
    36f6:	91 1d       	adc	r25, r1
    36f8:	08 95       	ret

000036fa <atoi>:
    36fa:	fc 01       	movw	r30, r24
    36fc:	88 27       	eor	r24, r24
    36fe:	99 27       	eor	r25, r25
    3700:	e8 94       	clt
    3702:	21 91       	ld	r18, Z+
    3704:	20 32       	cpi	r18, 0x20	; 32
    3706:	e9 f3       	breq	.-6      	; 0x3702 <atoi+0x8>
    3708:	29 30       	cpi	r18, 0x09	; 9
    370a:	10 f0       	brcs	.+4      	; 0x3710 <atoi+0x16>
    370c:	2e 30       	cpi	r18, 0x0E	; 14
    370e:	c8 f3       	brcs	.-14     	; 0x3702 <atoi+0x8>
    3710:	2b 32       	cpi	r18, 0x2B	; 43
    3712:	39 f0       	breq	.+14     	; 0x3722 <atoi+0x28>
    3714:	2d 32       	cpi	r18, 0x2D	; 45
    3716:	31 f4       	brne	.+12     	; 0x3724 <atoi+0x2a>
    3718:	68 94       	set
    371a:	03 c0       	rjmp	.+6      	; 0x3722 <atoi+0x28>
    371c:	43 d0       	rcall	.+134    	; 0x37a4 <__mulhi_const_10>
    371e:	82 0f       	add	r24, r18
    3720:	91 1d       	adc	r25, r1
    3722:	21 91       	ld	r18, Z+
    3724:	20 53       	subi	r18, 0x30	; 48
    3726:	2a 30       	cpi	r18, 0x0A	; 10
    3728:	c8 f3       	brcs	.-14     	; 0x371c <atoi+0x22>
    372a:	1e f4       	brtc	.+6      	; 0x3732 <atoi+0x38>
    372c:	90 95       	com	r25
    372e:	81 95       	neg	r24
    3730:	9f 4f       	sbci	r25, 0xFF	; 255
    3732:	08 95       	ret

00003734 <memcpy>:
    3734:	fb 01       	movw	r30, r22
    3736:	dc 01       	movw	r26, r24
    3738:	02 c0       	rjmp	.+4      	; 0x373e <memcpy+0xa>
    373a:	01 90       	ld	r0, Z+
    373c:	0d 92       	st	X+, r0
    373e:	41 50       	subi	r20, 0x01	; 1
    3740:	50 40       	sbci	r21, 0x00	; 0
    3742:	d8 f7       	brcc	.-10     	; 0x373a <memcpy+0x6>
    3744:	08 95       	ret

00003746 <strcat>:
    3746:	fb 01       	movw	r30, r22
    3748:	dc 01       	movw	r26, r24
    374a:	0d 90       	ld	r0, X+
    374c:	00 20       	and	r0, r0
    374e:	e9 f7       	brne	.-6      	; 0x374a <strcat+0x4>
    3750:	11 97       	sbiw	r26, 0x01	; 1
    3752:	01 90       	ld	r0, Z+
    3754:	0d 92       	st	X+, r0
    3756:	00 20       	and	r0, r0
    3758:	e1 f7       	brne	.-8      	; 0x3752 <strcat+0xc>
    375a:	08 95       	ret

0000375c <strcmp>:
    375c:	fb 01       	movw	r30, r22
    375e:	dc 01       	movw	r26, r24
    3760:	8d 91       	ld	r24, X+
    3762:	01 90       	ld	r0, Z+
    3764:	80 19       	sub	r24, r0
    3766:	01 10       	cpse	r0, r1
    3768:	d9 f3       	breq	.-10     	; 0x3760 <strcmp+0x4>
    376a:	99 0b       	sbc	r25, r25
    376c:	08 95       	ret

0000376e <strcpy>:
    376e:	fb 01       	movw	r30, r22
    3770:	dc 01       	movw	r26, r24
    3772:	01 90       	ld	r0, Z+
    3774:	0d 92       	st	X+, r0
    3776:	00 20       	and	r0, r0
    3778:	e1 f7       	brne	.-8      	; 0x3772 <strcpy+0x4>
    377a:	08 95       	ret

0000377c <itoa>:
    377c:	45 32       	cpi	r20, 0x25	; 37
    377e:	51 05       	cpc	r21, r1
    3780:	18 f4       	brcc	.+6      	; 0x3788 <itoa+0xc>
    3782:	42 30       	cpi	r20, 0x02	; 2
    3784:	08 f0       	brcs	.+2      	; 0x3788 <itoa+0xc>
    3786:	04 c0       	rjmp	.+8      	; 0x3790 <__itoa_ncheck>
    3788:	fb 01       	movw	r30, r22
    378a:	10 82       	st	Z, r1
    378c:	cb 01       	movw	r24, r22
    378e:	08 95       	ret

00003790 <__itoa_ncheck>:
    3790:	bb 27       	eor	r27, r27
    3792:	4a 30       	cpi	r20, 0x0A	; 10
    3794:	31 f4       	brne	.+12     	; 0x37a2 <__itoa_ncheck+0x12>
    3796:	99 23       	and	r25, r25
    3798:	22 f4       	brpl	.+8      	; 0x37a2 <__itoa_ncheck+0x12>
    379a:	bd e2       	ldi	r27, 0x2D	; 45
    379c:	90 95       	com	r25
    379e:	81 95       	neg	r24
    37a0:	9f 4f       	sbci	r25, 0xFF	; 255
    37a2:	09 c0       	rjmp	.+18     	; 0x37b6 <__utoa_common>

000037a4 <__mulhi_const_10>:
    37a4:	7a e0       	ldi	r23, 0x0A	; 10
    37a6:	97 9f       	mul	r25, r23
    37a8:	90 2d       	mov	r25, r0
    37aa:	87 9f       	mul	r24, r23
    37ac:	80 2d       	mov	r24, r0
    37ae:	91 0d       	add	r25, r1
    37b0:	11 24       	eor	r1, r1
    37b2:	08 95       	ret

000037b4 <__utoa_ncheck>:
    37b4:	bb 27       	eor	r27, r27

000037b6 <__utoa_common>:
    37b6:	fb 01       	movw	r30, r22
    37b8:	55 27       	eor	r21, r21
    37ba:	aa 27       	eor	r26, r26
    37bc:	88 0f       	add	r24, r24
    37be:	99 1f       	adc	r25, r25
    37c0:	aa 1f       	adc	r26, r26
    37c2:	a4 17       	cp	r26, r20
    37c4:	10 f0       	brcs	.+4      	; 0x37ca <__utoa_common+0x14>
    37c6:	a4 1b       	sub	r26, r20
    37c8:	83 95       	inc	r24
    37ca:	50 51       	subi	r21, 0x10	; 16
    37cc:	b9 f7       	brne	.-18     	; 0x37bc <__utoa_common+0x6>
    37ce:	a0 5d       	subi	r26, 0xD0	; 208
    37d0:	aa 33       	cpi	r26, 0x3A	; 58
    37d2:	08 f0       	brcs	.+2      	; 0x37d6 <__utoa_common+0x20>
    37d4:	a9 5d       	subi	r26, 0xD9	; 217
    37d6:	a1 93       	st	Z+, r26
    37d8:	00 97       	sbiw	r24, 0x00	; 0
    37da:	79 f7       	brne	.-34     	; 0x37ba <__utoa_common+0x4>
    37dc:	b1 11       	cpse	r27, r1
    37de:	b1 93       	st	Z+, r27
    37e0:	11 92       	st	Z+, r1
    37e2:	cb 01       	movw	r24, r22
    37e4:	41 c2       	rjmp	.+1154   	; 0x3c68 <strrev>

000037e6 <sprintf>:
    37e6:	0f 93       	push	r16
    37e8:	1f 93       	push	r17
    37ea:	cf 93       	push	r28
    37ec:	df 93       	push	r29
    37ee:	cd b7       	in	r28, 0x3d	; 61
    37f0:	de b7       	in	r29, 0x3e	; 62
    37f2:	2e 97       	sbiw	r28, 0x0e	; 14
    37f4:	0f b6       	in	r0, 0x3f	; 63
    37f6:	f8 94       	cli
    37f8:	de bf       	out	0x3e, r29	; 62
    37fa:	0f be       	out	0x3f, r0	; 63
    37fc:	cd bf       	out	0x3d, r28	; 61
    37fe:	0d 89       	ldd	r16, Y+21	; 0x15
    3800:	1e 89       	ldd	r17, Y+22	; 0x16
    3802:	86 e0       	ldi	r24, 0x06	; 6
    3804:	8c 83       	std	Y+4, r24	; 0x04
    3806:	1a 83       	std	Y+2, r17	; 0x02
    3808:	09 83       	std	Y+1, r16	; 0x01
    380a:	8f ef       	ldi	r24, 0xFF	; 255
    380c:	9f e7       	ldi	r25, 0x7F	; 127
    380e:	9e 83       	std	Y+6, r25	; 0x06
    3810:	8d 83       	std	Y+5, r24	; 0x05
    3812:	ae 01       	movw	r20, r28
    3814:	47 5e       	subi	r20, 0xE7	; 231
    3816:	5f 4f       	sbci	r21, 0xFF	; 255
    3818:	6f 89       	ldd	r22, Y+23	; 0x17
    381a:	78 8d       	ldd	r23, Y+24	; 0x18
    381c:	ce 01       	movw	r24, r28
    381e:	01 96       	adiw	r24, 0x01	; 1
    3820:	10 d0       	rcall	.+32     	; 0x3842 <vfprintf>
    3822:	ef 81       	ldd	r30, Y+7	; 0x07
    3824:	f8 85       	ldd	r31, Y+8	; 0x08
    3826:	e0 0f       	add	r30, r16
    3828:	f1 1f       	adc	r31, r17
    382a:	10 82       	st	Z, r1
    382c:	2e 96       	adiw	r28, 0x0e	; 14
    382e:	0f b6       	in	r0, 0x3f	; 63
    3830:	f8 94       	cli
    3832:	de bf       	out	0x3e, r29	; 62
    3834:	0f be       	out	0x3f, r0	; 63
    3836:	cd bf       	out	0x3d, r28	; 61
    3838:	df 91       	pop	r29
    383a:	cf 91       	pop	r28
    383c:	1f 91       	pop	r17
    383e:	0f 91       	pop	r16
    3840:	08 95       	ret

00003842 <vfprintf>:
    3842:	2f 92       	push	r2
    3844:	3f 92       	push	r3
    3846:	4f 92       	push	r4
    3848:	5f 92       	push	r5
    384a:	6f 92       	push	r6
    384c:	7f 92       	push	r7
    384e:	8f 92       	push	r8
    3850:	9f 92       	push	r9
    3852:	af 92       	push	r10
    3854:	bf 92       	push	r11
    3856:	cf 92       	push	r12
    3858:	df 92       	push	r13
    385a:	ef 92       	push	r14
    385c:	ff 92       	push	r15
    385e:	0f 93       	push	r16
    3860:	1f 93       	push	r17
    3862:	cf 93       	push	r28
    3864:	df 93       	push	r29
    3866:	cd b7       	in	r28, 0x3d	; 61
    3868:	de b7       	in	r29, 0x3e	; 62
    386a:	2b 97       	sbiw	r28, 0x0b	; 11
    386c:	0f b6       	in	r0, 0x3f	; 63
    386e:	f8 94       	cli
    3870:	de bf       	out	0x3e, r29	; 62
    3872:	0f be       	out	0x3f, r0	; 63
    3874:	cd bf       	out	0x3d, r28	; 61
    3876:	6c 01       	movw	r12, r24
    3878:	7b 01       	movw	r14, r22
    387a:	8a 01       	movw	r16, r20
    387c:	fc 01       	movw	r30, r24
    387e:	17 82       	std	Z+7, r1	; 0x07
    3880:	16 82       	std	Z+6, r1	; 0x06
    3882:	83 81       	ldd	r24, Z+3	; 0x03
    3884:	81 ff       	sbrs	r24, 1
    3886:	bf c1       	rjmp	.+894    	; 0x3c06 <vfprintf+0x3c4>
    3888:	ce 01       	movw	r24, r28
    388a:	01 96       	adiw	r24, 0x01	; 1
    388c:	3c 01       	movw	r6, r24
    388e:	f6 01       	movw	r30, r12
    3890:	93 81       	ldd	r25, Z+3	; 0x03
    3892:	f7 01       	movw	r30, r14
    3894:	93 fd       	sbrc	r25, 3
    3896:	85 91       	lpm	r24, Z+
    3898:	93 ff       	sbrs	r25, 3
    389a:	81 91       	ld	r24, Z+
    389c:	7f 01       	movw	r14, r30
    389e:	88 23       	and	r24, r24
    38a0:	09 f4       	brne	.+2      	; 0x38a4 <vfprintf+0x62>
    38a2:	ad c1       	rjmp	.+858    	; 0x3bfe <vfprintf+0x3bc>
    38a4:	85 32       	cpi	r24, 0x25	; 37
    38a6:	39 f4       	brne	.+14     	; 0x38b6 <vfprintf+0x74>
    38a8:	93 fd       	sbrc	r25, 3
    38aa:	85 91       	lpm	r24, Z+
    38ac:	93 ff       	sbrs	r25, 3
    38ae:	81 91       	ld	r24, Z+
    38b0:	7f 01       	movw	r14, r30
    38b2:	85 32       	cpi	r24, 0x25	; 37
    38b4:	21 f4       	brne	.+8      	; 0x38be <vfprintf+0x7c>
    38b6:	b6 01       	movw	r22, r12
    38b8:	90 e0       	ldi	r25, 0x00	; 0
    38ba:	e6 d1       	rcall	.+972    	; 0x3c88 <fputc>
    38bc:	e8 cf       	rjmp	.-48     	; 0x388e <vfprintf+0x4c>
    38be:	91 2c       	mov	r9, r1
    38c0:	21 2c       	mov	r2, r1
    38c2:	31 2c       	mov	r3, r1
    38c4:	ff e1       	ldi	r31, 0x1F	; 31
    38c6:	f3 15       	cp	r31, r3
    38c8:	d8 f0       	brcs	.+54     	; 0x3900 <vfprintf+0xbe>
    38ca:	8b 32       	cpi	r24, 0x2B	; 43
    38cc:	79 f0       	breq	.+30     	; 0x38ec <vfprintf+0xaa>
    38ce:	38 f4       	brcc	.+14     	; 0x38de <vfprintf+0x9c>
    38d0:	80 32       	cpi	r24, 0x20	; 32
    38d2:	79 f0       	breq	.+30     	; 0x38f2 <vfprintf+0xb0>
    38d4:	83 32       	cpi	r24, 0x23	; 35
    38d6:	a1 f4       	brne	.+40     	; 0x3900 <vfprintf+0xbe>
    38d8:	23 2d       	mov	r18, r3
    38da:	20 61       	ori	r18, 0x10	; 16
    38dc:	1d c0       	rjmp	.+58     	; 0x3918 <vfprintf+0xd6>
    38de:	8d 32       	cpi	r24, 0x2D	; 45
    38e0:	61 f0       	breq	.+24     	; 0x38fa <vfprintf+0xb8>
    38e2:	80 33       	cpi	r24, 0x30	; 48
    38e4:	69 f4       	brne	.+26     	; 0x3900 <vfprintf+0xbe>
    38e6:	23 2d       	mov	r18, r3
    38e8:	21 60       	ori	r18, 0x01	; 1
    38ea:	16 c0       	rjmp	.+44     	; 0x3918 <vfprintf+0xd6>
    38ec:	83 2d       	mov	r24, r3
    38ee:	82 60       	ori	r24, 0x02	; 2
    38f0:	38 2e       	mov	r3, r24
    38f2:	e3 2d       	mov	r30, r3
    38f4:	e4 60       	ori	r30, 0x04	; 4
    38f6:	3e 2e       	mov	r3, r30
    38f8:	2a c0       	rjmp	.+84     	; 0x394e <vfprintf+0x10c>
    38fa:	f3 2d       	mov	r31, r3
    38fc:	f8 60       	ori	r31, 0x08	; 8
    38fe:	1d c0       	rjmp	.+58     	; 0x393a <vfprintf+0xf8>
    3900:	37 fc       	sbrc	r3, 7
    3902:	2d c0       	rjmp	.+90     	; 0x395e <vfprintf+0x11c>
    3904:	20 ed       	ldi	r18, 0xD0	; 208
    3906:	28 0f       	add	r18, r24
    3908:	2a 30       	cpi	r18, 0x0A	; 10
    390a:	40 f0       	brcs	.+16     	; 0x391c <vfprintf+0xda>
    390c:	8e 32       	cpi	r24, 0x2E	; 46
    390e:	b9 f4       	brne	.+46     	; 0x393e <vfprintf+0xfc>
    3910:	36 fc       	sbrc	r3, 6
    3912:	75 c1       	rjmp	.+746    	; 0x3bfe <vfprintf+0x3bc>
    3914:	23 2d       	mov	r18, r3
    3916:	20 64       	ori	r18, 0x40	; 64
    3918:	32 2e       	mov	r3, r18
    391a:	19 c0       	rjmp	.+50     	; 0x394e <vfprintf+0x10c>
    391c:	36 fe       	sbrs	r3, 6
    391e:	06 c0       	rjmp	.+12     	; 0x392c <vfprintf+0xea>
    3920:	8a e0       	ldi	r24, 0x0A	; 10
    3922:	98 9e       	mul	r9, r24
    3924:	20 0d       	add	r18, r0
    3926:	11 24       	eor	r1, r1
    3928:	92 2e       	mov	r9, r18
    392a:	11 c0       	rjmp	.+34     	; 0x394e <vfprintf+0x10c>
    392c:	ea e0       	ldi	r30, 0x0A	; 10
    392e:	2e 9e       	mul	r2, r30
    3930:	20 0d       	add	r18, r0
    3932:	11 24       	eor	r1, r1
    3934:	22 2e       	mov	r2, r18
    3936:	f3 2d       	mov	r31, r3
    3938:	f0 62       	ori	r31, 0x20	; 32
    393a:	3f 2e       	mov	r3, r31
    393c:	08 c0       	rjmp	.+16     	; 0x394e <vfprintf+0x10c>
    393e:	8c 36       	cpi	r24, 0x6C	; 108
    3940:	21 f4       	brne	.+8      	; 0x394a <vfprintf+0x108>
    3942:	83 2d       	mov	r24, r3
    3944:	80 68       	ori	r24, 0x80	; 128
    3946:	38 2e       	mov	r3, r24
    3948:	02 c0       	rjmp	.+4      	; 0x394e <vfprintf+0x10c>
    394a:	88 36       	cpi	r24, 0x68	; 104
    394c:	41 f4       	brne	.+16     	; 0x395e <vfprintf+0x11c>
    394e:	f7 01       	movw	r30, r14
    3950:	93 fd       	sbrc	r25, 3
    3952:	85 91       	lpm	r24, Z+
    3954:	93 ff       	sbrs	r25, 3
    3956:	81 91       	ld	r24, Z+
    3958:	7f 01       	movw	r14, r30
    395a:	81 11       	cpse	r24, r1
    395c:	b3 cf       	rjmp	.-154    	; 0x38c4 <vfprintf+0x82>
    395e:	98 2f       	mov	r25, r24
    3960:	9f 7d       	andi	r25, 0xDF	; 223
    3962:	95 54       	subi	r25, 0x45	; 69
    3964:	93 30       	cpi	r25, 0x03	; 3
    3966:	28 f4       	brcc	.+10     	; 0x3972 <vfprintf+0x130>
    3968:	0c 5f       	subi	r16, 0xFC	; 252
    396a:	1f 4f       	sbci	r17, 0xFF	; 255
    396c:	9f e3       	ldi	r25, 0x3F	; 63
    396e:	99 83       	std	Y+1, r25	; 0x01
    3970:	0d c0       	rjmp	.+26     	; 0x398c <vfprintf+0x14a>
    3972:	83 36       	cpi	r24, 0x63	; 99
    3974:	31 f0       	breq	.+12     	; 0x3982 <vfprintf+0x140>
    3976:	83 37       	cpi	r24, 0x73	; 115
    3978:	71 f0       	breq	.+28     	; 0x3996 <vfprintf+0x154>
    397a:	83 35       	cpi	r24, 0x53	; 83
    397c:	09 f0       	breq	.+2      	; 0x3980 <vfprintf+0x13e>
    397e:	55 c0       	rjmp	.+170    	; 0x3a2a <vfprintf+0x1e8>
    3980:	20 c0       	rjmp	.+64     	; 0x39c2 <vfprintf+0x180>
    3982:	f8 01       	movw	r30, r16
    3984:	80 81       	ld	r24, Z
    3986:	89 83       	std	Y+1, r24	; 0x01
    3988:	0e 5f       	subi	r16, 0xFE	; 254
    398a:	1f 4f       	sbci	r17, 0xFF	; 255
    398c:	88 24       	eor	r8, r8
    398e:	83 94       	inc	r8
    3990:	91 2c       	mov	r9, r1
    3992:	53 01       	movw	r10, r6
    3994:	12 c0       	rjmp	.+36     	; 0x39ba <vfprintf+0x178>
    3996:	28 01       	movw	r4, r16
    3998:	f2 e0       	ldi	r31, 0x02	; 2
    399a:	4f 0e       	add	r4, r31
    399c:	51 1c       	adc	r5, r1
    399e:	f8 01       	movw	r30, r16
    39a0:	a0 80       	ld	r10, Z
    39a2:	b1 80       	ldd	r11, Z+1	; 0x01
    39a4:	36 fe       	sbrs	r3, 6
    39a6:	03 c0       	rjmp	.+6      	; 0x39ae <vfprintf+0x16c>
    39a8:	69 2d       	mov	r22, r9
    39aa:	70 e0       	ldi	r23, 0x00	; 0
    39ac:	02 c0       	rjmp	.+4      	; 0x39b2 <vfprintf+0x170>
    39ae:	6f ef       	ldi	r22, 0xFF	; 255
    39b0:	7f ef       	ldi	r23, 0xFF	; 255
    39b2:	c5 01       	movw	r24, r10
    39b4:	4e d1       	rcall	.+668    	; 0x3c52 <strnlen>
    39b6:	4c 01       	movw	r8, r24
    39b8:	82 01       	movw	r16, r4
    39ba:	f3 2d       	mov	r31, r3
    39bc:	ff 77       	andi	r31, 0x7F	; 127
    39be:	3f 2e       	mov	r3, r31
    39c0:	15 c0       	rjmp	.+42     	; 0x39ec <vfprintf+0x1aa>
    39c2:	28 01       	movw	r4, r16
    39c4:	22 e0       	ldi	r18, 0x02	; 2
    39c6:	42 0e       	add	r4, r18
    39c8:	51 1c       	adc	r5, r1
    39ca:	f8 01       	movw	r30, r16
    39cc:	a0 80       	ld	r10, Z
    39ce:	b1 80       	ldd	r11, Z+1	; 0x01
    39d0:	36 fe       	sbrs	r3, 6
    39d2:	03 c0       	rjmp	.+6      	; 0x39da <vfprintf+0x198>
    39d4:	69 2d       	mov	r22, r9
    39d6:	70 e0       	ldi	r23, 0x00	; 0
    39d8:	02 c0       	rjmp	.+4      	; 0x39de <vfprintf+0x19c>
    39da:	6f ef       	ldi	r22, 0xFF	; 255
    39dc:	7f ef       	ldi	r23, 0xFF	; 255
    39de:	c5 01       	movw	r24, r10
    39e0:	2d d1       	rcall	.+602    	; 0x3c3c <strnlen_P>
    39e2:	4c 01       	movw	r8, r24
    39e4:	f3 2d       	mov	r31, r3
    39e6:	f0 68       	ori	r31, 0x80	; 128
    39e8:	3f 2e       	mov	r3, r31
    39ea:	82 01       	movw	r16, r4
    39ec:	33 fc       	sbrc	r3, 3
    39ee:	19 c0       	rjmp	.+50     	; 0x3a22 <vfprintf+0x1e0>
    39f0:	82 2d       	mov	r24, r2
    39f2:	90 e0       	ldi	r25, 0x00	; 0
    39f4:	88 16       	cp	r8, r24
    39f6:	99 06       	cpc	r9, r25
    39f8:	a0 f4       	brcc	.+40     	; 0x3a22 <vfprintf+0x1e0>
    39fa:	b6 01       	movw	r22, r12
    39fc:	80 e2       	ldi	r24, 0x20	; 32
    39fe:	90 e0       	ldi	r25, 0x00	; 0
    3a00:	43 d1       	rcall	.+646    	; 0x3c88 <fputc>
    3a02:	2a 94       	dec	r2
    3a04:	f5 cf       	rjmp	.-22     	; 0x39f0 <vfprintf+0x1ae>
    3a06:	f5 01       	movw	r30, r10
    3a08:	37 fc       	sbrc	r3, 7
    3a0a:	85 91       	lpm	r24, Z+
    3a0c:	37 fe       	sbrs	r3, 7
    3a0e:	81 91       	ld	r24, Z+
    3a10:	5f 01       	movw	r10, r30
    3a12:	b6 01       	movw	r22, r12
    3a14:	90 e0       	ldi	r25, 0x00	; 0
    3a16:	38 d1       	rcall	.+624    	; 0x3c88 <fputc>
    3a18:	21 10       	cpse	r2, r1
    3a1a:	2a 94       	dec	r2
    3a1c:	21 e0       	ldi	r18, 0x01	; 1
    3a1e:	82 1a       	sub	r8, r18
    3a20:	91 08       	sbc	r9, r1
    3a22:	81 14       	cp	r8, r1
    3a24:	91 04       	cpc	r9, r1
    3a26:	79 f7       	brne	.-34     	; 0x3a06 <vfprintf+0x1c4>
    3a28:	e1 c0       	rjmp	.+450    	; 0x3bec <vfprintf+0x3aa>
    3a2a:	84 36       	cpi	r24, 0x64	; 100
    3a2c:	11 f0       	breq	.+4      	; 0x3a32 <vfprintf+0x1f0>
    3a2e:	89 36       	cpi	r24, 0x69	; 105
    3a30:	39 f5       	brne	.+78     	; 0x3a80 <vfprintf+0x23e>
    3a32:	f8 01       	movw	r30, r16
    3a34:	37 fe       	sbrs	r3, 7
    3a36:	07 c0       	rjmp	.+14     	; 0x3a46 <vfprintf+0x204>
    3a38:	60 81       	ld	r22, Z
    3a3a:	71 81       	ldd	r23, Z+1	; 0x01
    3a3c:	82 81       	ldd	r24, Z+2	; 0x02
    3a3e:	93 81       	ldd	r25, Z+3	; 0x03
    3a40:	0c 5f       	subi	r16, 0xFC	; 252
    3a42:	1f 4f       	sbci	r17, 0xFF	; 255
    3a44:	08 c0       	rjmp	.+16     	; 0x3a56 <vfprintf+0x214>
    3a46:	60 81       	ld	r22, Z
    3a48:	71 81       	ldd	r23, Z+1	; 0x01
    3a4a:	07 2e       	mov	r0, r23
    3a4c:	00 0c       	add	r0, r0
    3a4e:	88 0b       	sbc	r24, r24
    3a50:	99 0b       	sbc	r25, r25
    3a52:	0e 5f       	subi	r16, 0xFE	; 254
    3a54:	1f 4f       	sbci	r17, 0xFF	; 255
    3a56:	f3 2d       	mov	r31, r3
    3a58:	ff 76       	andi	r31, 0x6F	; 111
    3a5a:	3f 2e       	mov	r3, r31
    3a5c:	97 ff       	sbrs	r25, 7
    3a5e:	09 c0       	rjmp	.+18     	; 0x3a72 <vfprintf+0x230>
    3a60:	90 95       	com	r25
    3a62:	80 95       	com	r24
    3a64:	70 95       	com	r23
    3a66:	61 95       	neg	r22
    3a68:	7f 4f       	sbci	r23, 0xFF	; 255
    3a6a:	8f 4f       	sbci	r24, 0xFF	; 255
    3a6c:	9f 4f       	sbci	r25, 0xFF	; 255
    3a6e:	f0 68       	ori	r31, 0x80	; 128
    3a70:	3f 2e       	mov	r3, r31
    3a72:	2a e0       	ldi	r18, 0x0A	; 10
    3a74:	30 e0       	ldi	r19, 0x00	; 0
    3a76:	a3 01       	movw	r20, r6
    3a78:	43 d1       	rcall	.+646    	; 0x3d00 <__ultoa_invert>
    3a7a:	88 2e       	mov	r8, r24
    3a7c:	86 18       	sub	r8, r6
    3a7e:	44 c0       	rjmp	.+136    	; 0x3b08 <vfprintf+0x2c6>
    3a80:	85 37       	cpi	r24, 0x75	; 117
    3a82:	31 f4       	brne	.+12     	; 0x3a90 <vfprintf+0x24e>
    3a84:	23 2d       	mov	r18, r3
    3a86:	2f 7e       	andi	r18, 0xEF	; 239
    3a88:	b2 2e       	mov	r11, r18
    3a8a:	2a e0       	ldi	r18, 0x0A	; 10
    3a8c:	30 e0       	ldi	r19, 0x00	; 0
    3a8e:	25 c0       	rjmp	.+74     	; 0x3ada <vfprintf+0x298>
    3a90:	93 2d       	mov	r25, r3
    3a92:	99 7f       	andi	r25, 0xF9	; 249
    3a94:	b9 2e       	mov	r11, r25
    3a96:	8f 36       	cpi	r24, 0x6F	; 111
    3a98:	c1 f0       	breq	.+48     	; 0x3aca <vfprintf+0x288>
    3a9a:	18 f4       	brcc	.+6      	; 0x3aa2 <vfprintf+0x260>
    3a9c:	88 35       	cpi	r24, 0x58	; 88
    3a9e:	79 f0       	breq	.+30     	; 0x3abe <vfprintf+0x27c>
    3aa0:	ae c0       	rjmp	.+348    	; 0x3bfe <vfprintf+0x3bc>
    3aa2:	80 37       	cpi	r24, 0x70	; 112
    3aa4:	19 f0       	breq	.+6      	; 0x3aac <vfprintf+0x26a>
    3aa6:	88 37       	cpi	r24, 0x78	; 120
    3aa8:	21 f0       	breq	.+8      	; 0x3ab2 <vfprintf+0x270>
    3aaa:	a9 c0       	rjmp	.+338    	; 0x3bfe <vfprintf+0x3bc>
    3aac:	e9 2f       	mov	r30, r25
    3aae:	e0 61       	ori	r30, 0x10	; 16
    3ab0:	be 2e       	mov	r11, r30
    3ab2:	b4 fe       	sbrs	r11, 4
    3ab4:	0d c0       	rjmp	.+26     	; 0x3ad0 <vfprintf+0x28e>
    3ab6:	fb 2d       	mov	r31, r11
    3ab8:	f4 60       	ori	r31, 0x04	; 4
    3aba:	bf 2e       	mov	r11, r31
    3abc:	09 c0       	rjmp	.+18     	; 0x3ad0 <vfprintf+0x28e>
    3abe:	34 fe       	sbrs	r3, 4
    3ac0:	0a c0       	rjmp	.+20     	; 0x3ad6 <vfprintf+0x294>
    3ac2:	29 2f       	mov	r18, r25
    3ac4:	26 60       	ori	r18, 0x06	; 6
    3ac6:	b2 2e       	mov	r11, r18
    3ac8:	06 c0       	rjmp	.+12     	; 0x3ad6 <vfprintf+0x294>
    3aca:	28 e0       	ldi	r18, 0x08	; 8
    3acc:	30 e0       	ldi	r19, 0x00	; 0
    3ace:	05 c0       	rjmp	.+10     	; 0x3ada <vfprintf+0x298>
    3ad0:	20 e1       	ldi	r18, 0x10	; 16
    3ad2:	30 e0       	ldi	r19, 0x00	; 0
    3ad4:	02 c0       	rjmp	.+4      	; 0x3ada <vfprintf+0x298>
    3ad6:	20 e1       	ldi	r18, 0x10	; 16
    3ad8:	32 e0       	ldi	r19, 0x02	; 2
    3ada:	f8 01       	movw	r30, r16
    3adc:	b7 fe       	sbrs	r11, 7
    3ade:	07 c0       	rjmp	.+14     	; 0x3aee <vfprintf+0x2ac>
    3ae0:	60 81       	ld	r22, Z
    3ae2:	71 81       	ldd	r23, Z+1	; 0x01
    3ae4:	82 81       	ldd	r24, Z+2	; 0x02
    3ae6:	93 81       	ldd	r25, Z+3	; 0x03
    3ae8:	0c 5f       	subi	r16, 0xFC	; 252
    3aea:	1f 4f       	sbci	r17, 0xFF	; 255
    3aec:	06 c0       	rjmp	.+12     	; 0x3afa <vfprintf+0x2b8>
    3aee:	60 81       	ld	r22, Z
    3af0:	71 81       	ldd	r23, Z+1	; 0x01
    3af2:	80 e0       	ldi	r24, 0x00	; 0
    3af4:	90 e0       	ldi	r25, 0x00	; 0
    3af6:	0e 5f       	subi	r16, 0xFE	; 254
    3af8:	1f 4f       	sbci	r17, 0xFF	; 255
    3afa:	a3 01       	movw	r20, r6
    3afc:	01 d1       	rcall	.+514    	; 0x3d00 <__ultoa_invert>
    3afe:	88 2e       	mov	r8, r24
    3b00:	86 18       	sub	r8, r6
    3b02:	fb 2d       	mov	r31, r11
    3b04:	ff 77       	andi	r31, 0x7F	; 127
    3b06:	3f 2e       	mov	r3, r31
    3b08:	36 fe       	sbrs	r3, 6
    3b0a:	0d c0       	rjmp	.+26     	; 0x3b26 <vfprintf+0x2e4>
    3b0c:	23 2d       	mov	r18, r3
    3b0e:	2e 7f       	andi	r18, 0xFE	; 254
    3b10:	a2 2e       	mov	r10, r18
    3b12:	89 14       	cp	r8, r9
    3b14:	58 f4       	brcc	.+22     	; 0x3b2c <vfprintf+0x2ea>
    3b16:	34 fe       	sbrs	r3, 4
    3b18:	0b c0       	rjmp	.+22     	; 0x3b30 <vfprintf+0x2ee>
    3b1a:	32 fc       	sbrc	r3, 2
    3b1c:	09 c0       	rjmp	.+18     	; 0x3b30 <vfprintf+0x2ee>
    3b1e:	83 2d       	mov	r24, r3
    3b20:	8e 7e       	andi	r24, 0xEE	; 238
    3b22:	a8 2e       	mov	r10, r24
    3b24:	05 c0       	rjmp	.+10     	; 0x3b30 <vfprintf+0x2ee>
    3b26:	b8 2c       	mov	r11, r8
    3b28:	a3 2c       	mov	r10, r3
    3b2a:	03 c0       	rjmp	.+6      	; 0x3b32 <vfprintf+0x2f0>
    3b2c:	b8 2c       	mov	r11, r8
    3b2e:	01 c0       	rjmp	.+2      	; 0x3b32 <vfprintf+0x2f0>
    3b30:	b9 2c       	mov	r11, r9
    3b32:	a4 fe       	sbrs	r10, 4
    3b34:	0f c0       	rjmp	.+30     	; 0x3b54 <vfprintf+0x312>
    3b36:	fe 01       	movw	r30, r28
    3b38:	e8 0d       	add	r30, r8
    3b3a:	f1 1d       	adc	r31, r1
    3b3c:	80 81       	ld	r24, Z
    3b3e:	80 33       	cpi	r24, 0x30	; 48
    3b40:	21 f4       	brne	.+8      	; 0x3b4a <vfprintf+0x308>
    3b42:	9a 2d       	mov	r25, r10
    3b44:	99 7e       	andi	r25, 0xE9	; 233
    3b46:	a9 2e       	mov	r10, r25
    3b48:	09 c0       	rjmp	.+18     	; 0x3b5c <vfprintf+0x31a>
    3b4a:	a2 fe       	sbrs	r10, 2
    3b4c:	06 c0       	rjmp	.+12     	; 0x3b5a <vfprintf+0x318>
    3b4e:	b3 94       	inc	r11
    3b50:	b3 94       	inc	r11
    3b52:	04 c0       	rjmp	.+8      	; 0x3b5c <vfprintf+0x31a>
    3b54:	8a 2d       	mov	r24, r10
    3b56:	86 78       	andi	r24, 0x86	; 134
    3b58:	09 f0       	breq	.+2      	; 0x3b5c <vfprintf+0x31a>
    3b5a:	b3 94       	inc	r11
    3b5c:	a3 fc       	sbrc	r10, 3
    3b5e:	10 c0       	rjmp	.+32     	; 0x3b80 <vfprintf+0x33e>
    3b60:	a0 fe       	sbrs	r10, 0
    3b62:	06 c0       	rjmp	.+12     	; 0x3b70 <vfprintf+0x32e>
    3b64:	b2 14       	cp	r11, r2
    3b66:	80 f4       	brcc	.+32     	; 0x3b88 <vfprintf+0x346>
    3b68:	28 0c       	add	r2, r8
    3b6a:	92 2c       	mov	r9, r2
    3b6c:	9b 18       	sub	r9, r11
    3b6e:	0d c0       	rjmp	.+26     	; 0x3b8a <vfprintf+0x348>
    3b70:	b2 14       	cp	r11, r2
    3b72:	58 f4       	brcc	.+22     	; 0x3b8a <vfprintf+0x348>
    3b74:	b6 01       	movw	r22, r12
    3b76:	80 e2       	ldi	r24, 0x20	; 32
    3b78:	90 e0       	ldi	r25, 0x00	; 0
    3b7a:	86 d0       	rcall	.+268    	; 0x3c88 <fputc>
    3b7c:	b3 94       	inc	r11
    3b7e:	f8 cf       	rjmp	.-16     	; 0x3b70 <vfprintf+0x32e>
    3b80:	b2 14       	cp	r11, r2
    3b82:	18 f4       	brcc	.+6      	; 0x3b8a <vfprintf+0x348>
    3b84:	2b 18       	sub	r2, r11
    3b86:	02 c0       	rjmp	.+4      	; 0x3b8c <vfprintf+0x34a>
    3b88:	98 2c       	mov	r9, r8
    3b8a:	21 2c       	mov	r2, r1
    3b8c:	a4 fe       	sbrs	r10, 4
    3b8e:	0f c0       	rjmp	.+30     	; 0x3bae <vfprintf+0x36c>
    3b90:	b6 01       	movw	r22, r12
    3b92:	80 e3       	ldi	r24, 0x30	; 48
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	78 d0       	rcall	.+240    	; 0x3c88 <fputc>
    3b98:	a2 fe       	sbrs	r10, 2
    3b9a:	16 c0       	rjmp	.+44     	; 0x3bc8 <vfprintf+0x386>
    3b9c:	a1 fc       	sbrc	r10, 1
    3b9e:	03 c0       	rjmp	.+6      	; 0x3ba6 <vfprintf+0x364>
    3ba0:	88 e7       	ldi	r24, 0x78	; 120
    3ba2:	90 e0       	ldi	r25, 0x00	; 0
    3ba4:	02 c0       	rjmp	.+4      	; 0x3baa <vfprintf+0x368>
    3ba6:	88 e5       	ldi	r24, 0x58	; 88
    3ba8:	90 e0       	ldi	r25, 0x00	; 0
    3baa:	b6 01       	movw	r22, r12
    3bac:	0c c0       	rjmp	.+24     	; 0x3bc6 <vfprintf+0x384>
    3bae:	8a 2d       	mov	r24, r10
    3bb0:	86 78       	andi	r24, 0x86	; 134
    3bb2:	51 f0       	breq	.+20     	; 0x3bc8 <vfprintf+0x386>
    3bb4:	a1 fe       	sbrs	r10, 1
    3bb6:	02 c0       	rjmp	.+4      	; 0x3bbc <vfprintf+0x37a>
    3bb8:	8b e2       	ldi	r24, 0x2B	; 43
    3bba:	01 c0       	rjmp	.+2      	; 0x3bbe <vfprintf+0x37c>
    3bbc:	80 e2       	ldi	r24, 0x20	; 32
    3bbe:	a7 fc       	sbrc	r10, 7
    3bc0:	8d e2       	ldi	r24, 0x2D	; 45
    3bc2:	b6 01       	movw	r22, r12
    3bc4:	90 e0       	ldi	r25, 0x00	; 0
    3bc6:	60 d0       	rcall	.+192    	; 0x3c88 <fputc>
    3bc8:	89 14       	cp	r8, r9
    3bca:	30 f4       	brcc	.+12     	; 0x3bd8 <vfprintf+0x396>
    3bcc:	b6 01       	movw	r22, r12
    3bce:	80 e3       	ldi	r24, 0x30	; 48
    3bd0:	90 e0       	ldi	r25, 0x00	; 0
    3bd2:	5a d0       	rcall	.+180    	; 0x3c88 <fputc>
    3bd4:	9a 94       	dec	r9
    3bd6:	f8 cf       	rjmp	.-16     	; 0x3bc8 <vfprintf+0x386>
    3bd8:	8a 94       	dec	r8
    3bda:	f3 01       	movw	r30, r6
    3bdc:	e8 0d       	add	r30, r8
    3bde:	f1 1d       	adc	r31, r1
    3be0:	80 81       	ld	r24, Z
    3be2:	b6 01       	movw	r22, r12
    3be4:	90 e0       	ldi	r25, 0x00	; 0
    3be6:	50 d0       	rcall	.+160    	; 0x3c88 <fputc>
    3be8:	81 10       	cpse	r8, r1
    3bea:	f6 cf       	rjmp	.-20     	; 0x3bd8 <vfprintf+0x396>
    3bec:	22 20       	and	r2, r2
    3bee:	09 f4       	brne	.+2      	; 0x3bf2 <vfprintf+0x3b0>
    3bf0:	4e ce       	rjmp	.-868    	; 0x388e <vfprintf+0x4c>
    3bf2:	b6 01       	movw	r22, r12
    3bf4:	80 e2       	ldi	r24, 0x20	; 32
    3bf6:	90 e0       	ldi	r25, 0x00	; 0
    3bf8:	47 d0       	rcall	.+142    	; 0x3c88 <fputc>
    3bfa:	2a 94       	dec	r2
    3bfc:	f7 cf       	rjmp	.-18     	; 0x3bec <vfprintf+0x3aa>
    3bfe:	f6 01       	movw	r30, r12
    3c00:	86 81       	ldd	r24, Z+6	; 0x06
    3c02:	97 81       	ldd	r25, Z+7	; 0x07
    3c04:	02 c0       	rjmp	.+4      	; 0x3c0a <vfprintf+0x3c8>
    3c06:	8f ef       	ldi	r24, 0xFF	; 255
    3c08:	9f ef       	ldi	r25, 0xFF	; 255
    3c0a:	2b 96       	adiw	r28, 0x0b	; 11
    3c0c:	0f b6       	in	r0, 0x3f	; 63
    3c0e:	f8 94       	cli
    3c10:	de bf       	out	0x3e, r29	; 62
    3c12:	0f be       	out	0x3f, r0	; 63
    3c14:	cd bf       	out	0x3d, r28	; 61
    3c16:	df 91       	pop	r29
    3c18:	cf 91       	pop	r28
    3c1a:	1f 91       	pop	r17
    3c1c:	0f 91       	pop	r16
    3c1e:	ff 90       	pop	r15
    3c20:	ef 90       	pop	r14
    3c22:	df 90       	pop	r13
    3c24:	cf 90       	pop	r12
    3c26:	bf 90       	pop	r11
    3c28:	af 90       	pop	r10
    3c2a:	9f 90       	pop	r9
    3c2c:	8f 90       	pop	r8
    3c2e:	7f 90       	pop	r7
    3c30:	6f 90       	pop	r6
    3c32:	5f 90       	pop	r5
    3c34:	4f 90       	pop	r4
    3c36:	3f 90       	pop	r3
    3c38:	2f 90       	pop	r2
    3c3a:	08 95       	ret

00003c3c <strnlen_P>:
    3c3c:	fc 01       	movw	r30, r24
    3c3e:	05 90       	lpm	r0, Z+
    3c40:	61 50       	subi	r22, 0x01	; 1
    3c42:	70 40       	sbci	r23, 0x00	; 0
    3c44:	01 10       	cpse	r0, r1
    3c46:	d8 f7       	brcc	.-10     	; 0x3c3e <strnlen_P+0x2>
    3c48:	80 95       	com	r24
    3c4a:	90 95       	com	r25
    3c4c:	8e 0f       	add	r24, r30
    3c4e:	9f 1f       	adc	r25, r31
    3c50:	08 95       	ret

00003c52 <strnlen>:
    3c52:	fc 01       	movw	r30, r24
    3c54:	61 50       	subi	r22, 0x01	; 1
    3c56:	70 40       	sbci	r23, 0x00	; 0
    3c58:	01 90       	ld	r0, Z+
    3c5a:	01 10       	cpse	r0, r1
    3c5c:	d8 f7       	brcc	.-10     	; 0x3c54 <strnlen+0x2>
    3c5e:	80 95       	com	r24
    3c60:	90 95       	com	r25
    3c62:	8e 0f       	add	r24, r30
    3c64:	9f 1f       	adc	r25, r31
    3c66:	08 95       	ret

00003c68 <strrev>:
    3c68:	dc 01       	movw	r26, r24
    3c6a:	fc 01       	movw	r30, r24
    3c6c:	67 2f       	mov	r22, r23
    3c6e:	71 91       	ld	r23, Z+
    3c70:	77 23       	and	r23, r23
    3c72:	e1 f7       	brne	.-8      	; 0x3c6c <strrev+0x4>
    3c74:	32 97       	sbiw	r30, 0x02	; 2
    3c76:	04 c0       	rjmp	.+8      	; 0x3c80 <strrev+0x18>
    3c78:	7c 91       	ld	r23, X
    3c7a:	6d 93       	st	X+, r22
    3c7c:	70 83       	st	Z, r23
    3c7e:	62 91       	ld	r22, -Z
    3c80:	ae 17       	cp	r26, r30
    3c82:	bf 07       	cpc	r27, r31
    3c84:	c8 f3       	brcs	.-14     	; 0x3c78 <strrev+0x10>
    3c86:	08 95       	ret

00003c88 <fputc>:
    3c88:	0f 93       	push	r16
    3c8a:	1f 93       	push	r17
    3c8c:	cf 93       	push	r28
    3c8e:	df 93       	push	r29
    3c90:	fb 01       	movw	r30, r22
    3c92:	23 81       	ldd	r18, Z+3	; 0x03
    3c94:	21 fd       	sbrc	r18, 1
    3c96:	03 c0       	rjmp	.+6      	; 0x3c9e <fputc+0x16>
    3c98:	8f ef       	ldi	r24, 0xFF	; 255
    3c9a:	9f ef       	ldi	r25, 0xFF	; 255
    3c9c:	2c c0       	rjmp	.+88     	; 0x3cf6 <fputc+0x6e>
    3c9e:	22 ff       	sbrs	r18, 2
    3ca0:	16 c0       	rjmp	.+44     	; 0x3cce <fputc+0x46>
    3ca2:	46 81       	ldd	r20, Z+6	; 0x06
    3ca4:	57 81       	ldd	r21, Z+7	; 0x07
    3ca6:	24 81       	ldd	r18, Z+4	; 0x04
    3ca8:	35 81       	ldd	r19, Z+5	; 0x05
    3caa:	42 17       	cp	r20, r18
    3cac:	53 07       	cpc	r21, r19
    3cae:	44 f4       	brge	.+16     	; 0x3cc0 <fputc+0x38>
    3cb0:	a0 81       	ld	r26, Z
    3cb2:	b1 81       	ldd	r27, Z+1	; 0x01
    3cb4:	9d 01       	movw	r18, r26
    3cb6:	2f 5f       	subi	r18, 0xFF	; 255
    3cb8:	3f 4f       	sbci	r19, 0xFF	; 255
    3cba:	31 83       	std	Z+1, r19	; 0x01
    3cbc:	20 83       	st	Z, r18
    3cbe:	8c 93       	st	X, r24
    3cc0:	26 81       	ldd	r18, Z+6	; 0x06
    3cc2:	37 81       	ldd	r19, Z+7	; 0x07
    3cc4:	2f 5f       	subi	r18, 0xFF	; 255
    3cc6:	3f 4f       	sbci	r19, 0xFF	; 255
    3cc8:	37 83       	std	Z+7, r19	; 0x07
    3cca:	26 83       	std	Z+6, r18	; 0x06
    3ccc:	14 c0       	rjmp	.+40     	; 0x3cf6 <fputc+0x6e>
    3cce:	8b 01       	movw	r16, r22
    3cd0:	ec 01       	movw	r28, r24
    3cd2:	fb 01       	movw	r30, r22
    3cd4:	00 84       	ldd	r0, Z+8	; 0x08
    3cd6:	f1 85       	ldd	r31, Z+9	; 0x09
    3cd8:	e0 2d       	mov	r30, r0
    3cda:	09 95       	icall
    3cdc:	89 2b       	or	r24, r25
    3cde:	e1 f6       	brne	.-72     	; 0x3c98 <fputc+0x10>
    3ce0:	d8 01       	movw	r26, r16
    3ce2:	16 96       	adiw	r26, 0x06	; 6
    3ce4:	8d 91       	ld	r24, X+
    3ce6:	9c 91       	ld	r25, X
    3ce8:	17 97       	sbiw	r26, 0x07	; 7
    3cea:	01 96       	adiw	r24, 0x01	; 1
    3cec:	17 96       	adiw	r26, 0x07	; 7
    3cee:	9c 93       	st	X, r25
    3cf0:	8e 93       	st	-X, r24
    3cf2:	16 97       	sbiw	r26, 0x06	; 6
    3cf4:	ce 01       	movw	r24, r28
    3cf6:	df 91       	pop	r29
    3cf8:	cf 91       	pop	r28
    3cfa:	1f 91       	pop	r17
    3cfc:	0f 91       	pop	r16
    3cfe:	08 95       	ret

00003d00 <__ultoa_invert>:
    3d00:	fa 01       	movw	r30, r20
    3d02:	aa 27       	eor	r26, r26
    3d04:	28 30       	cpi	r18, 0x08	; 8
    3d06:	51 f1       	breq	.+84     	; 0x3d5c <__ultoa_invert+0x5c>
    3d08:	20 31       	cpi	r18, 0x10	; 16
    3d0a:	81 f1       	breq	.+96     	; 0x3d6c <__ultoa_invert+0x6c>
    3d0c:	e8 94       	clt
    3d0e:	6f 93       	push	r22
    3d10:	6e 7f       	andi	r22, 0xFE	; 254
    3d12:	6e 5f       	subi	r22, 0xFE	; 254
    3d14:	7f 4f       	sbci	r23, 0xFF	; 255
    3d16:	8f 4f       	sbci	r24, 0xFF	; 255
    3d18:	9f 4f       	sbci	r25, 0xFF	; 255
    3d1a:	af 4f       	sbci	r26, 0xFF	; 255
    3d1c:	b1 e0       	ldi	r27, 0x01	; 1
    3d1e:	3e d0       	rcall	.+124    	; 0x3d9c <__ultoa_invert+0x9c>
    3d20:	b4 e0       	ldi	r27, 0x04	; 4
    3d22:	3c d0       	rcall	.+120    	; 0x3d9c <__ultoa_invert+0x9c>
    3d24:	67 0f       	add	r22, r23
    3d26:	78 1f       	adc	r23, r24
    3d28:	89 1f       	adc	r24, r25
    3d2a:	9a 1f       	adc	r25, r26
    3d2c:	a1 1d       	adc	r26, r1
    3d2e:	68 0f       	add	r22, r24
    3d30:	79 1f       	adc	r23, r25
    3d32:	8a 1f       	adc	r24, r26
    3d34:	91 1d       	adc	r25, r1
    3d36:	a1 1d       	adc	r26, r1
    3d38:	6a 0f       	add	r22, r26
    3d3a:	71 1d       	adc	r23, r1
    3d3c:	81 1d       	adc	r24, r1
    3d3e:	91 1d       	adc	r25, r1
    3d40:	a1 1d       	adc	r26, r1
    3d42:	20 d0       	rcall	.+64     	; 0x3d84 <__ultoa_invert+0x84>
    3d44:	09 f4       	brne	.+2      	; 0x3d48 <__ultoa_invert+0x48>
    3d46:	68 94       	set
    3d48:	3f 91       	pop	r19
    3d4a:	2a e0       	ldi	r18, 0x0A	; 10
    3d4c:	26 9f       	mul	r18, r22
    3d4e:	11 24       	eor	r1, r1
    3d50:	30 19       	sub	r19, r0
    3d52:	30 5d       	subi	r19, 0xD0	; 208
    3d54:	31 93       	st	Z+, r19
    3d56:	de f6       	brtc	.-74     	; 0x3d0e <__ultoa_invert+0xe>
    3d58:	cf 01       	movw	r24, r30
    3d5a:	08 95       	ret
    3d5c:	46 2f       	mov	r20, r22
    3d5e:	47 70       	andi	r20, 0x07	; 7
    3d60:	40 5d       	subi	r20, 0xD0	; 208
    3d62:	41 93       	st	Z+, r20
    3d64:	b3 e0       	ldi	r27, 0x03	; 3
    3d66:	0f d0       	rcall	.+30     	; 0x3d86 <__ultoa_invert+0x86>
    3d68:	c9 f7       	brne	.-14     	; 0x3d5c <__ultoa_invert+0x5c>
    3d6a:	f6 cf       	rjmp	.-20     	; 0x3d58 <__ultoa_invert+0x58>
    3d6c:	46 2f       	mov	r20, r22
    3d6e:	4f 70       	andi	r20, 0x0F	; 15
    3d70:	40 5d       	subi	r20, 0xD0	; 208
    3d72:	4a 33       	cpi	r20, 0x3A	; 58
    3d74:	18 f0       	brcs	.+6      	; 0x3d7c <__ultoa_invert+0x7c>
    3d76:	49 5d       	subi	r20, 0xD9	; 217
    3d78:	31 fd       	sbrc	r19, 1
    3d7a:	40 52       	subi	r20, 0x20	; 32
    3d7c:	41 93       	st	Z+, r20
    3d7e:	02 d0       	rcall	.+4      	; 0x3d84 <__ultoa_invert+0x84>
    3d80:	a9 f7       	brne	.-22     	; 0x3d6c <__ultoa_invert+0x6c>
    3d82:	ea cf       	rjmp	.-44     	; 0x3d58 <__ultoa_invert+0x58>
    3d84:	b4 e0       	ldi	r27, 0x04	; 4
    3d86:	a6 95       	lsr	r26
    3d88:	97 95       	ror	r25
    3d8a:	87 95       	ror	r24
    3d8c:	77 95       	ror	r23
    3d8e:	67 95       	ror	r22
    3d90:	ba 95       	dec	r27
    3d92:	c9 f7       	brne	.-14     	; 0x3d86 <__ultoa_invert+0x86>
    3d94:	00 97       	sbiw	r24, 0x00	; 0
    3d96:	61 05       	cpc	r22, r1
    3d98:	71 05       	cpc	r23, r1
    3d9a:	08 95       	ret
    3d9c:	9b 01       	movw	r18, r22
    3d9e:	ac 01       	movw	r20, r24
    3da0:	0a 2e       	mov	r0, r26
    3da2:	06 94       	lsr	r0
    3da4:	57 95       	ror	r21
    3da6:	47 95       	ror	r20
    3da8:	37 95       	ror	r19
    3daa:	27 95       	ror	r18
    3dac:	ba 95       	dec	r27
    3dae:	c9 f7       	brne	.-14     	; 0x3da2 <__ultoa_invert+0xa2>
    3db0:	62 0f       	add	r22, r18
    3db2:	73 1f       	adc	r23, r19
    3db4:	84 1f       	adc	r24, r20
    3db6:	95 1f       	adc	r25, r21
    3db8:	a0 1d       	adc	r26, r0
    3dba:	08 95       	ret

00003dbc <_exit>:
    3dbc:	f8 94       	cli

00003dbe <__stop_program>:
    3dbe:	ff cf       	rjmp	.-2      	; 0x3dbe <__stop_program>
